{
  "spec": "specs/adapter-agent-routing/02-specification.md",
  "slug": "adapter-agent-routing",
  "generatedAt": "2026-02-28T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-agent-routing] [P1] Add AdapterBinding and SessionStrategy schemas to relay-schemas.ts",
      "description": "Add new Zod schemas to `packages/shared/src/relay-schemas.ts` for adapter-agent binding configuration.\n\n## Implementation\n\nAdd the following schemas after the existing `AdaptersConfigFileSchema` section in `packages/shared/src/relay-schemas.ts`:\n\n```typescript\n// === Adapter Bindings ===\n\nexport const SessionStrategySchema = z\n  .enum(['per-chat', 'per-user', 'stateless'])\n  .openapi('SessionStrategy');\nexport type SessionStrategy = z.infer<typeof SessionStrategySchema>;\n\nexport const AdapterBindingSchema = z\n  .object({\n    id: z.string().uuid(),\n    adapterId: z.string(),\n    agentId: z.string(),\n    agentDir: z.string(),\n    chatId: z.string().optional(),\n    channelType: ChannelTypeSchema.optional(),\n    sessionStrategy: SessionStrategySchema.default('per-chat'),\n    label: z.string().default(''),\n    createdAt: z.string().datetime(),\n    updatedAt: z.string().datetime(),\n  })\n  .openapi('AdapterBinding');\nexport type AdapterBinding = z.infer<typeof AdapterBindingSchema>;\n\nexport const CreateBindingRequestSchema = AdapterBindingSchema.omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true,\n}).openapi('CreateBindingRequest');\nexport type CreateBindingRequest = z.infer<typeof CreateBindingRequestSchema>;\n\nexport const BindingListResponseSchema = z\n  .object({\n    bindings: z.array(AdapterBindingSchema),\n  })\n  .openapi('BindingListResponse');\n\nexport const BindingResponseSchema = z\n  .object({\n    binding: AdapterBindingSchema,\n  })\n  .openapi('BindingResponse');\n```\n\nAlso add the new types to the re-exports in `packages/shared/src/types.ts` if needed.\n\n## Acceptance Criteria\n\n- `SessionStrategySchema` validates 'per-chat', 'per-user', 'stateless' and rejects other values\n- `AdapterBindingSchema` validates a complete binding object with UUID id, datetime fields, and optional chatId/channelType\n- `CreateBindingRequestSchema` omits id/createdAt/updatedAt and applies defaults for sessionStrategy and label\n- `BindingListResponseSchema` and `BindingResponseSchema` wrap binding(s) in response objects\n- All schemas have `.openapi()` metadata for auto-generated API docs\n- `ChannelTypeSchema` (already exists as 'dm' | 'group' | 'channel' | 'thread') is reused for channelType field\n- Running `pnpm typecheck` passes with no errors in shared package\n\n## Tests\n\nAdd a test file `packages/shared/src/__tests__/relay-binding-schemas.test.ts`:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport {\n  SessionStrategySchema,\n  AdapterBindingSchema,\n  CreateBindingRequestSchema,\n} from '../relay-schemas';\n\ndescribe('SessionStrategySchema', () => {\n  it('accepts valid strategies', () => {\n    expect(SessionStrategySchema.parse('per-chat')).toBe('per-chat');\n    expect(SessionStrategySchema.parse('per-user')).toBe('per-user');\n    expect(SessionStrategySchema.parse('stateless')).toBe('stateless');\n  });\n\n  it('rejects invalid strategies', () => {\n    expect(() => SessionStrategySchema.parse('invalid')).toThrow();\n  });\n});\n\ndescribe('AdapterBindingSchema', () => {\n  it('validates a complete binding', () => {\n    const binding = {\n      id: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',\n      adapterId: 'telegram-main',\n      agentId: 'agent-1',\n      agentDir: '/home/user/agents/alpha',\n      sessionStrategy: 'per-chat',\n      label: 'Main bot',\n      createdAt: '2026-01-01T00:00:00.000Z',\n      updatedAt: '2026-01-01T00:00:00.000Z',\n    };\n    expect(AdapterBindingSchema.parse(binding)).toEqual(binding);\n  });\n\n  it('accepts optional chatId and channelType', () => {\n    const binding = {\n      id: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',\n      adapterId: 'telegram-main',\n      agentId: 'agent-1',\n      agentDir: '/home/user/agents/alpha',\n      chatId: '12345',\n      channelType: 'dm',\n      sessionStrategy: 'per-user',\n      label: '',\n      createdAt: '2026-01-01T00:00:00.000Z',\n      updatedAt: '2026-01-01T00:00:00.000Z',\n    };\n    expect(AdapterBindingSchema.parse(binding)).toEqual(binding);\n  });\n});\n\ndescribe('CreateBindingRequestSchema', () => {\n  it('applies defaults for sessionStrategy and label', () => {\n    const input = {\n      adapterId: 'telegram-main',\n      agentId: 'agent-1',\n      agentDir: '/home/user/agents/alpha',\n    };\n    const parsed = CreateBindingRequestSchema.parse(input);\n    expect(parsed.sessionStrategy).toBe('per-chat');\n    expect(parsed.label).toBe('');\n  });\n\n  it('rejects if id is present', () => {\n    const input = {\n      id: 'should-not-be-here',\n      adapterId: 'telegram-main',\n      agentId: 'agent-1',\n      agentDir: '/home/user/agents/alpha',\n    };\n    // omit strips unknown keys but doesn't reject them in Zod v3 by default\n    // so we check the output doesn't contain id\n    const parsed = CreateBindingRequestSchema.parse(input);\n    expect(parsed).not.toHaveProperty('id');\n  });\n});\n```",
      "activeForm": "Adding adapter binding schemas to relay-schemas.ts",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-agent-routing] [P1] Verify Bug #70 relay publish pipeline fix",
      "description": "Verify that the relay publish pipeline fix (Bug #70 / spec `relay-publish-pipeline-fix`) is in place. The fix removes the early-return at `relay-core.ts:308-315` that skips adapter delivery when no Maildir endpoints match.\n\n## What to Verify\n\n1. Open the RelayCore `publish()` method (in the `@dorkos/relay` package or `apps/server/src/services/relay/`).\n2. Confirm that after endpoint matching, the code does NOT early-return before reaching the adapter delivery path.\n3. The publish pipeline should always attempt adapter delivery regardless of how many Maildir endpoints matched.\n4. If the fix is not yet applied, apply it: remove the early-return guard so that the adapter delivery path (the code that calls `this.adapterRegistry.deliver()` or equivalent) is always reached.\n\n## Context\n\nThe original bug was at `relay-core.ts:308-315` where code like this existed:\n```typescript\n// BUG: This early return skips adapter delivery\nif (deliveredEndpoints.length === 0) {\n  await this.deadLetter(envelope, 'no_endpoints');\n  return { messageId: envelope.id, deliveredTo: 0 };\n}\n```\n\nThe fix restructures so adapter delivery always happens:\n```typescript\n// Deliver to maildir endpoints\nconst deliveredEndpoints = await this.deliverToEndpoints(envelope);\n// ALWAYS attempt adapter delivery (regardless of endpoint match count)\nconst adapterDeliveries = await this.deliverToAdapters(envelope);\nconst totalDelivered = deliveredEndpoints.length + adapterDeliveries;\nif (totalDelivered === 0) {\n  await this.deadLetter(envelope, 'no_recipients');\n}\n```\n\n## Acceptance Criteria\n\n- The relay publish pipeline does not early-return before adapter delivery when no Maildir endpoints match\n- A message published to `relay.human.telegram.12345` reaches adapter delivery even if no Maildir endpoints subscribe to that subject\n- If the fix was not applied, it is now applied and the existing relay tests still pass (`pnpm vitest run` for relay tests)\n- Document the verification in a brief comment or commit message\n\n## Tests\n\nRun existing relay tests to confirm no regressions:\n```bash\npnpm vitest run apps/server/src/services/relay/__tests__/\n```\n\nIf writing a new test, add to the existing relay test suite:\n```typescript\nit('delivers to adapters even when no maildir endpoints match', async () => {\n  // Publish to a subject with no registered Maildir endpoints\n  const result = await relayCore.publish('relay.human.telegram.99999', { text: 'hello' }, {\n    from: 'test',\n  });\n  // Adapter delivery should have been attempted (not dead-lettered immediately)\n  expect(mockAdapterRegistry.deliver).toHaveBeenCalled();\n});\n```",
      "activeForm": "Verifying Bug #70 relay publish pipeline fix",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-agent-routing] [P1] Implement BindingStore with JSON persistence and resolution logic",
      "description": "Create the `BindingStore` class that manages adapter-agent bindings with JSON file persistence at `~/.dork/relay/bindings.json`, CRUD operations, and most-specific-first resolution.\n\n## File Location\n\nCreate `apps/server/src/services/relay/binding-store.ts` (following existing relay service patterns like `trace-store.ts` and `adapter-manager.ts`).\n\n## Implementation\n\n```typescript\nimport { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { dirname, join as pathJoin } from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport chokidar, { type FSWatcher } from 'chokidar';\nimport {\n  AdapterBindingSchema,\n  CreateBindingRequestSchema,\n  type AdapterBinding,\n  type CreateBindingRequest,\n} from '@dorkos/shared/relay-schemas';\nimport { z } from 'zod';\nimport { logger } from '../../lib/logger.js';\n\nconst BindingsFileSchema = z.object({\n  bindings: z.array(AdapterBindingSchema),\n});\n\n/** Chokidar stability threshold before triggering hot-reload (ms). */\nconst STABILITY_THRESHOLD_MS = 150;\n/** Chokidar poll interval for write-finish detection (ms). */\nconst POLL_INTERVAL_MS = 50;\n\n/**\n * JSON file-backed store for adapter-agent bindings.\n *\n * Persists to `~/.dork/relay/bindings.json` and watches for external\n * changes via chokidar for hot-reload.\n */\nexport class BindingStore {\n  private bindings: Map<string, AdapterBinding> = new Map();\n  private filePath: string;\n  private watcher?: FSWatcher;\n  /** Guard to skip reload when we just wrote the file ourselves. */\n  private skipNextReload = false;\n\n  constructor(relayDir: string) {\n    this.filePath = pathJoin(relayDir, 'bindings.json');\n  }\n\n  async init(): Promise<void> {\n    await this.load();\n    this.watch();\n  }\n\n  /** Return all bindings as an array. */\n  getAll(): AdapterBinding[] {\n    return Array.from(this.bindings.values());\n  }\n\n  /** Find a binding by its UUID. */\n  getById(id: string): AdapterBinding | undefined {\n    return this.bindings.get(id);\n  }\n\n  /** Find all bindings for a given adapter ID. */\n  getByAdapterId(adapterId: string): AdapterBinding[] {\n    return this.getAll().filter((b) => b.adapterId === adapterId);\n  }\n\n  /** Create a new binding. Returns the created binding with generated id and timestamps. */\n  async create(input: CreateBindingRequest): Promise<AdapterBinding> {\n    const now = new Date().toISOString();\n    const binding: AdapterBinding = {\n      ...input,\n      id: randomUUID(),\n      createdAt: now,\n      updatedAt: now,\n    };\n    this.bindings.set(binding.id, binding);\n    await this.save();\n    return binding;\n  }\n\n  /** Delete a binding by ID. Returns true if found and deleted, false if not found. */\n  async delete(id: string): Promise<boolean> {\n    const existed = this.bindings.delete(id);\n    if (existed) {\n      await this.save();\n    }\n    return existed;\n  }\n\n  /**\n   * Resolve the best matching binding for an inbound message.\n   *\n   * Uses most-specific-first scoring:\n   * 1. adapterId + chatId + channelType (score 7)\n   * 2. adapterId + chatId (score 5)\n   * 3. adapterId + channelType (score 3)\n   * 4. adapterId only / wildcard (score 1)\n   * 5. no match → undefined (dead-letter)\n   */\n  resolve(\n    adapterId: string,\n    chatId?: string,\n    channelType?: string,\n  ): AdapterBinding | undefined {\n    const candidates = this.getByAdapterId(adapterId);\n    if (candidates.length === 0) return undefined;\n\n    return candidates\n      .map((binding) => ({ binding, score: this.scoreMatch(binding, chatId, channelType) }))\n      .filter(({ score }) => score > 0)\n      .sort((a, b) => b.score - a.score)[0]?.binding;\n  }\n\n  private scoreMatch(\n    binding: AdapterBinding,\n    chatId?: string,\n    channelType?: string,\n  ): number {\n    let score = 1; // base: adapterId already matches (filtered by caller)\n    if (binding.chatId) {\n      if (binding.chatId === chatId) score += 4;\n      else return 0; // explicit chatId mismatch\n    }\n    if (binding.channelType) {\n      if (binding.channelType === channelType) score += 2;\n      else return 0; // explicit channelType mismatch\n    }\n    return score;\n  }\n\n  private async load(): Promise<void> {\n    try {\n      const raw = await readFile(this.filePath, 'utf-8');\n      const parsed = BindingsFileSchema.parse(JSON.parse(raw));\n      this.bindings.clear();\n      for (const b of parsed.bindings) {\n        this.bindings.set(b.id, b);\n      }\n      logger.info(`Loaded ${this.bindings.size} binding(s) from ${this.filePath}`);\n    } catch (err) {\n      if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n        logger.info('No bindings.json found, starting with empty bindings');\n        this.bindings.clear();\n      } else {\n        logger.error('Failed to load bindings.json, starting with empty bindings', err);\n        this.bindings.clear();\n      }\n    }\n  }\n\n  private async save(): Promise<void> {\n    this.skipNextReload = true;\n    const data = { bindings: this.getAll() };\n    await mkdir(dirname(this.filePath), { recursive: true });\n    // Atomic write: temp file + rename\n    const tmpPath = `${this.filePath}.tmp`;\n    await writeFile(tmpPath, JSON.stringify(data, null, 2), 'utf-8');\n    const { rename } = await import('node:fs/promises');\n    await rename(tmpPath, this.filePath);\n  }\n\n  private watch(): void {\n    this.watcher = chokidar.watch(this.filePath, {\n      awaitWriteFinish: {\n        stabilityThreshold: STABILITY_THRESHOLD_MS,\n        pollInterval: POLL_INTERVAL_MS,\n      },\n    });\n    this.watcher.on('change', async () => {\n      if (this.skipNextReload) {\n        this.skipNextReload = false;\n        return;\n      }\n      logger.info('bindings.json changed on disk, reloading');\n      await this.load();\n    });\n  }\n\n  async shutdown(): Promise<void> {\n    await this.watcher?.close();\n    this.bindings.clear();\n  }\n}\n```\n\n## Acceptance Criteria\n\n- BindingStore reads and writes `~/.dork/relay/bindings.json`\n- `create()` generates a UUID id and ISO datetime timestamps\n- `delete()` returns true if binding existed, false otherwise\n- `resolve()` returns the most-specific match using the scoring system:\n  - adapterId + chatId + channelType = score 7 (highest)\n  - adapterId + chatId = score 5\n  - adapterId + channelType = score 3\n  - adapterId only (wildcard) = score 1 (lowest)\n  - Explicit mismatch on chatId or channelType = score 0 (no match)\n- File write uses atomic temp-file + rename pattern\n- chokidar watches for external changes and reloads (with skip-on-self-write guard)\n- `shutdown()` closes the watcher and clears state\n\n## Tests\n\nCreate `apps/server/src/services/relay/__tests__/binding-store.test.ts`:\n\n```typescript\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { BindingStore } from '../binding-store.js';\nimport { readFile, writeFile, mkdir, rename } from 'node:fs/promises';\n\nvi.mock('node:fs/promises');\nvi.mock('chokidar', () => ({\n  default: { watch: () => ({ on: vi.fn(), close: vi.fn() }) },\n}));\n\ndescribe('BindingStore', () => {\n  let store: BindingStore;\n\n  beforeEach(async () => {\n    vi.mocked(readFile).mockRejectedValue(Object.assign(new Error('ENOENT'), { code: 'ENOENT' }));\n    vi.mocked(mkdir).mockResolvedValue(undefined);\n    vi.mocked(writeFile).mockResolvedValue();\n    vi.mocked(rename).mockResolvedValue();\n    store = new BindingStore('/tmp/relay');\n    await store.init();\n  });\n\n  afterEach(async () => {\n    await store.shutdown();\n    vi.restoreAllMocks();\n  });\n\n  describe('CRUD', () => {\n    it('starts empty when no file exists', () => {\n      expect(store.getAll()).toEqual([]);\n    });\n\n    it('creates a binding with generated id and timestamps', async () => {\n      const binding = await store.create({\n        adapterId: 'telegram-1',\n        agentId: 'agent-a',\n        agentDir: '/agents/a',\n        sessionStrategy: 'per-chat',\n        label: 'Test',\n      });\n      expect(binding.id).toMatch(/^[0-9a-f-]{36}$/);\n      expect(binding.createdAt).toBeDefined();\n      expect(binding.updatedAt).toBeDefined();\n      expect(store.getById(binding.id)).toEqual(binding);\n    });\n\n    it('deletes a binding and returns true', async () => {\n      const binding = await store.create({\n        adapterId: 'telegram-1',\n        agentId: 'agent-a',\n        agentDir: '/agents/a',\n      });\n      expect(await store.delete(binding.id)).toBe(true);\n      expect(store.getById(binding.id)).toBeUndefined();\n    });\n\n    it('returns false when deleting non-existent binding', async () => {\n      expect(await store.delete('non-existent')).toBe(false);\n    });\n\n    it('filters by adapterId', async () => {\n      await store.create({ adapterId: 'tg-1', agentId: 'a', agentDir: '/a' });\n      await store.create({ adapterId: 'tg-2', agentId: 'b', agentDir: '/b' });\n      await store.create({ adapterId: 'tg-1', agentId: 'c', agentDir: '/c' });\n      expect(store.getByAdapterId('tg-1')).toHaveLength(2);\n      expect(store.getByAdapterId('tg-2')).toHaveLength(1);\n    });\n  });\n\n  describe('resolve()', () => {\n    it('returns undefined when no bindings exist for adapterId', () => {\n      expect(store.resolve('unknown')).toBeUndefined();\n    });\n\n    it('matches wildcard binding (adapterId only)', async () => {\n      const b = await store.create({ adapterId: 'tg', agentId: 'a', agentDir: '/a' });\n      expect(store.resolve('tg', '12345')?.id).toBe(b.id);\n    });\n\n    it('prefers chatId match over wildcard', async () => {\n      const wildcard = await store.create({ adapterId: 'tg', agentId: 'a', agentDir: '/a' });\n      const specific = await store.create({\n        adapterId: 'tg', agentId: 'b', agentDir: '/b', chatId: '123',\n      });\n      expect(store.resolve('tg', '123')?.id).toBe(specific.id);\n      expect(store.resolve('tg', '999')?.id).toBe(wildcard.id);\n    });\n\n    it('prefers chatId+channelType over chatId alone', async () => {\n      const chatOnly = await store.create({\n        adapterId: 'tg', agentId: 'a', agentDir: '/a', chatId: '123',\n      });\n      const chatAndChannel = await store.create({\n        adapterId: 'tg', agentId: 'b', agentDir: '/b', chatId: '123', channelType: 'dm',\n      });\n      expect(store.resolve('tg', '123', 'dm')?.id).toBe(chatAndChannel.id);\n      expect(store.resolve('tg', '123', 'group')?.id).toBe(chatOnly.id);\n    });\n\n    it('returns 0 score (no match) on explicit chatId mismatch', async () => {\n      await store.create({\n        adapterId: 'tg', agentId: 'a', agentDir: '/a', chatId: '123',\n      });\n      // No wildcard binding exists, so mismatch yields no result\n      expect(store.resolve('tg', '999')).toBeUndefined();\n    });\n  });\n});\n```",
      "activeForm": "Implementing BindingStore with JSON persistence",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Core Routing",
      "subject": "[adapter-agent-routing] [P2] Implement BindingRouter with inbound interception and session management",
      "description": "Create the `BindingRouter` class that subscribes to `relay.human.*` messages, resolves adapter-agent bindings, manages session lifecycle based on session strategies, and republishes to `relay.agent.*`.\n\n## File Location\n\nCreate `apps/server/src/services/relay/binding-router.ts`.\n\n## Implementation\n\n```typescript\nimport { join as pathJoin } from 'node:path';\nimport { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport type { RelayEnvelope } from '@dorkos/shared/relay-schemas';\nimport type { AdapterBinding } from '@dorkos/shared/relay-schemas';\nimport { logger } from '../../lib/logger.js';\nimport type { BindingStore } from './binding-store.js';\n\n/** Minimal interface for AgentManager session creation. */\nexport interface AgentSessionCreator {\n  createSession(cwd: string): Promise<{ id: string }>;\n}\n\n/** Minimal interface for RelayCore publish and event subscription. */\nexport interface RelayCoreLike {\n  publish(subject: string, payload: unknown, opts?: Record<string, unknown>): Promise<unknown>;\n  on(pattern: string, handler: (envelope: RelayEnvelope) => Promise<void>): void;\n  deadLetter(envelope: RelayEnvelope, reason: string): Promise<void>;\n}\n\nexport interface BindingRouterDeps {\n  bindingStore: BindingStore;\n  relayCore: RelayCoreLike;\n  agentManager: AgentSessionCreator;\n  relayDir: string;\n}\n\n/**\n * Central routing service that intercepts relay.human.* messages,\n * resolves adapter-agent bindings, and republishes to relay.agent.*\n * for ClaudeCodeAdapter to handle.\n */\nexport class BindingRouter {\n  /** Maps bindingId:context → sessionId for session reuse. */\n  private sessionMap: Map<string, string> = new Map();\n  private sessionMapPath: string;\n\n  constructor(private deps: BindingRouterDeps) {\n    this.sessionMapPath = pathJoin(deps.relayDir, 'sessions.json');\n  }\n\n  async init(): Promise<void> {\n    await this.loadSessionMap();\n    this.deps.relayCore.on('relay.human.*', this.handleInbound.bind(this));\n    logger.info(`BindingRouter initialized with ${this.sessionMap.size} persisted session(s)`);\n  }\n\n  private async loadSessionMap(): Promise<void> {\n    try {\n      const raw = await readFile(this.sessionMapPath, 'utf-8');\n      const entries: [string, string][] = JSON.parse(raw);\n      this.sessionMap = new Map(entries);\n    } catch {\n      // File doesn't exist yet or is invalid — start fresh\n      this.sessionMap = new Map();\n    }\n  }\n\n  private async saveSessionMap(): Promise<void> {\n    await mkdir(pathJoin(this.deps.relayDir), { recursive: true });\n    const data = JSON.stringify(Array.from(this.sessionMap.entries()));\n    const tmpPath = `${this.sessionMapPath}.tmp`;\n    await writeFile(tmpPath, data, 'utf-8');\n    const { rename } = await import('node:fs/promises');\n    await rename(tmpPath, this.sessionMapPath);\n  }\n\n  private async handleInbound(envelope: RelayEnvelope): Promise<void> {\n    const { adapterId, chatId, channelType } = this.parseSubject(envelope.subject);\n    if (!adapterId) {\n      logger.warn(`BindingRouter: could not parse subject '${envelope.subject}'`);\n      return;\n    }\n\n    const binding = this.deps.bindingStore.resolve(adapterId, chatId, channelType);\n    if (!binding) {\n      logger.info(`BindingRouter: no binding for adapter=${adapterId} chat=${chatId}, dead-lettering`);\n      await this.deps.relayCore.deadLetter(envelope, 'no_binding');\n      return;\n    }\n\n    const sessionId = await this.resolveSession(binding, chatId, envelope);\n\n    await this.deps.relayCore.publish(`relay.agent.${sessionId}`, envelope.payload, {\n      from: envelope.from,\n      replyTo: envelope.replyTo,\n      budget: envelope.budget,\n      metadata: {\n        bindingId: binding.id,\n        originalSubject: envelope.subject,\n      },\n    });\n\n    logger.info(`BindingRouter: routed ${envelope.subject} → relay.agent.${sessionId} (binding=${binding.id})`);\n  }\n\n  private async resolveSession(\n    binding: AdapterBinding,\n    chatId: string | undefined,\n    envelope: RelayEnvelope,\n  ): Promise<string> {\n    switch (binding.sessionStrategy) {\n      case 'stateless':\n        return this.createNewSession(binding);\n\n      case 'per-user': {\n        const userId = (envelope as Record<string, unknown>).metadata?.userId ?? chatId ?? 'unknown';\n        const key = `${binding.id}:user:${userId}`;\n        return this.getOrCreateSession(key, binding);\n      }\n\n      case 'per-chat':\n      default: {\n        const key = `${binding.id}:chat:${chatId ?? 'default'}`;\n        return this.getOrCreateSession(key, binding);\n      }\n    }\n  }\n\n  private async getOrCreateSession(key: string, binding: AdapterBinding): Promise<string> {\n    const existing = this.sessionMap.get(key);\n    if (existing) return existing;\n    const sessionId = await this.createNewSession(binding);\n    this.sessionMap.set(key, sessionId);\n    await this.saveSessionMap();\n    return sessionId;\n  }\n\n  private async createNewSession(binding: AdapterBinding): Promise<string> {\n    const session = await this.deps.agentManager.createSession(binding.agentDir);\n    return session.id;\n  }\n\n  private parseSubject(subject: string): {\n    adapterId?: string;\n    chatId?: string;\n    channelType?: string;\n  } {\n    // Pattern: relay.human.{platform}.{chatId}\n    const parts = subject.split('.');\n    if (parts[0] !== 'relay' || parts[1] !== 'human') return {};\n    return {\n      adapterId: parts[2],\n      chatId: parts[3],\n      channelType: undefined, // extracted from envelope metadata if present\n    };\n  }\n\n  async shutdown(): Promise<void> {\n    await this.saveSessionMap();\n    this.sessionMap.clear();\n  }\n}\n```\n\n## Acceptance Criteria\n\n- BindingRouter subscribes to `relay.human.*` on init\n- `handleInbound()` parses subject to extract adapterId and chatId\n- Resolves binding via BindingStore.resolve() and dead-letters when no match\n- `per-chat` strategy reuses sessions keyed by `bindingId:chat:chatId`\n- `per-user` strategy reuses sessions keyed by `bindingId:user:userId`\n- `stateless` strategy always creates a new session\n- Republishes to `relay.agent.{sessionId}` with binding metadata\n- Session map is persisted to `~/.dork/relay/sessions.json` and restored on init\n- `shutdown()` saves session map and clears state\n\n## Tests\n\nCreate `apps/server/src/services/relay/__tests__/binding-router.test.ts`:\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { BindingRouter, type RelayCoreLike, type AgentSessionCreator } from '../binding-router.js';\nimport type { BindingStore } from '../binding-store.js';\nimport { readFile } from 'node:fs/promises';\n\nvi.mock('node:fs/promises');\n\ndescribe('BindingRouter', () => {\n  let router: BindingRouter;\n  let mockRelayCore: RelayCoreLike;\n  let mockAgentManager: AgentSessionCreator;\n  let mockBindingStore: Partial<BindingStore>;\n  let capturedHandler: ((envelope: any) => Promise<void>) | undefined;\n\n  beforeEach(async () => {\n    vi.mocked(readFile).mockRejectedValue(new Error('ENOENT'));\n    capturedHandler = undefined;\n\n    mockRelayCore = {\n      publish: vi.fn().mockResolvedValue({ messageId: 'msg-1', deliveredTo: 1 }),\n      on: vi.fn((pattern: string, handler: any) => { capturedHandler = handler; }),\n      deadLetter: vi.fn().mockResolvedValue(undefined),\n    };\n\n    mockAgentManager = {\n      createSession: vi.fn().mockResolvedValue({ id: 'session-abc' }),\n    };\n\n    mockBindingStore = {\n      resolve: vi.fn(),\n    };\n\n    router = new BindingRouter({\n      bindingStore: mockBindingStore as BindingStore,\n      relayCore: mockRelayCore,\n      agentManager: mockAgentManager,\n      relayDir: '/tmp/relay',\n    });\n    await router.init();\n  });\n\n  it('subscribes to relay.human.* on init', () => {\n    expect(mockRelayCore.on).toHaveBeenCalledWith('relay.human.*', expect.any(Function));\n  });\n\n  it('dead-letters when no binding matches', async () => {\n    vi.mocked(mockBindingStore.resolve!).mockReturnValue(undefined);\n    const envelope = { subject: 'relay.human.telegram.123', payload: 'hi', from: 'tg', budget: {} };\n    await capturedHandler!(envelope);\n    expect(mockRelayCore.deadLetter).toHaveBeenCalledWith(envelope, 'no_binding');\n    expect(mockRelayCore.publish).not.toHaveBeenCalled();\n  });\n\n  it('routes to relay.agent.{sessionId} when binding matches', async () => {\n    vi.mocked(mockBindingStore.resolve!).mockReturnValue({\n      id: 'bind-1', adapterId: 'telegram', agentId: 'agent-a',\n      agentDir: '/agents/a', sessionStrategy: 'per-chat',\n      label: '', createdAt: '', updatedAt: '',\n    });\n    const envelope = { subject: 'relay.human.telegram.123', payload: { text: 'hello' }, from: 'tg', budget: {} };\n    await capturedHandler!(envelope);\n    expect(mockAgentManager.createSession).toHaveBeenCalledWith('/agents/a');\n    expect(mockRelayCore.publish).toHaveBeenCalledWith(\n      'relay.agent.session-abc',\n      { text: 'hello' },\n      expect.objectContaining({ metadata: expect.objectContaining({ bindingId: 'bind-1' }) }),\n    );\n  });\n\n  it('reuses session for per-chat strategy', async () => {\n    vi.mocked(mockBindingStore.resolve!).mockReturnValue({\n      id: 'bind-1', adapterId: 'telegram', agentId: 'agent-a',\n      agentDir: '/agents/a', sessionStrategy: 'per-chat',\n      label: '', createdAt: '', updatedAt: '',\n    });\n    const envelope = { subject: 'relay.human.telegram.123', payload: 'hi', from: 'tg', budget: {} };\n    await capturedHandler!(envelope);\n    await capturedHandler!(envelope); // second call\n    // createSession should only be called once (reuse)\n    expect(mockAgentManager.createSession).toHaveBeenCalledTimes(1);\n  });\n\n  it('creates new session for stateless strategy', async () => {\n    vi.mocked(mockBindingStore.resolve!).mockReturnValue({\n      id: 'bind-1', adapterId: 'telegram', agentId: 'agent-a',\n      agentDir: '/agents/a', sessionStrategy: 'stateless',\n      label: '', createdAt: '', updatedAt: '',\n    });\n    const envelope = { subject: 'relay.human.telegram.123', payload: 'hi', from: 'tg', budget: {} };\n    await capturedHandler!(envelope);\n    await capturedHandler!(envelope); // second call\n    expect(mockAgentManager.createSession).toHaveBeenCalledTimes(2);\n  });\n\n  it('ignores non-relay.human subjects', async () => {\n    const envelope = { subject: 'relay.agent.xxx', payload: 'hi', from: 'tg', budget: {} };\n    await capturedHandler!(envelope);\n    expect(mockBindingStore.resolve).not.toHaveBeenCalled();\n  });\n});\n```",
      "activeForm": "Implementing BindingRouter with session management",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Core Routing",
      "subject": "[adapter-agent-routing] [P2] Wire BindingRouter into AdapterManager startup and add HTTP routes",
      "description": "Integrate BindingStore and BindingRouter into the AdapterManager lifecycle, and add CRUD HTTP routes for bindings to the relay router.\n\n## Server Integration — AdapterManager\n\nModify `apps/server/src/services/relay/adapter-manager.ts`:\n\n1. Add imports:\n```typescript\nimport { BindingStore } from './binding-store.js';\nimport { BindingRouter } from './binding-router.js';\n```\n\n2. Add new properties to the `AdapterManager` class:\n```typescript\nprivate bindingStore?: BindingStore;\nprivate bindingRouter?: BindingRouter;\n```\n\n3. In the `init()` method (or equivalent startup), after adapter loading, add:\n```typescript\n// Initialize binding store and router\nthis.bindingStore = new BindingStore(this.relayDir);\nawait this.bindingStore.init();\n\nthis.bindingRouter = new BindingRouter({\n  bindingStore: this.bindingStore,\n  relayCore: this.relayCore,\n  agentManager: this.deps.agentManager,\n  relayDir: this.relayDir,\n});\nawait this.bindingRouter.init();\n```\n\n4. In `shutdown()`, add:\n```typescript\nawait this.bindingRouter?.shutdown();\nawait this.bindingStore?.shutdown();\n```\n\n5. Expose a getter:\n```typescript\ngetBindingStore(): BindingStore | undefined {\n  return this.bindingStore;\n}\n```\n\n## HTTP Routes\n\nAdd binding CRUD endpoints to `apps/server/src/routes/relay.ts` inside `createRelayRouter()`:\n\n```typescript\nimport { CreateBindingRequestSchema } from '@dorkos/shared/relay-schemas';\n\n// --- Bindings ---\n\n// GET /bindings — List all bindings\nrouter.get('/bindings', (_req, res) => {\n  if (!adapterManager) {\n    return res.status(503).json({ error: 'Adapter manager not available' });\n  }\n  const store = adapterManager.getBindingStore();\n  if (!store) {\n    return res.status(503).json({ error: 'Binding store not initialized' });\n  }\n  return res.json({ bindings: store.getAll() });\n});\n\n// POST /bindings — Create a binding\nrouter.post('/bindings', async (req, res) => {\n  if (!adapterManager) {\n    return res.status(503).json({ error: 'Adapter manager not available' });\n  }\n  const store = adapterManager.getBindingStore();\n  if (!store) {\n    return res.status(503).json({ error: 'Binding store not initialized' });\n  }\n  const result = CreateBindingRequestSchema.safeParse(req.body);\n  if (!result.success) {\n    return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n  }\n  try {\n    const binding = await store.create(result.data);\n    return res.status(201).json({ binding });\n  } catch (err) {\n    return res.status(500).json({ error: err instanceof Error ? err.message : 'Create failed' });\n  }\n});\n\n// GET /bindings/:id — Get single binding\nrouter.get('/bindings/:id', (req, res) => {\n  if (!adapterManager) {\n    return res.status(503).json({ error: 'Adapter manager not available' });\n  }\n  const store = adapterManager.getBindingStore();\n  if (!store) {\n    return res.status(503).json({ error: 'Binding store not initialized' });\n  }\n  const binding = store.getById(req.params.id);\n  if (!binding) {\n    return res.status(404).json({ error: 'Binding not found' });\n  }\n  return res.json({ binding });\n});\n\n// DELETE /bindings/:id — Delete binding\nrouter.delete('/bindings/:id', async (req, res) => {\n  if (!adapterManager) {\n    return res.status(503).json({ error: 'Adapter manager not available' });\n  }\n  const store = adapterManager.getBindingStore();\n  if (!store) {\n    return res.status(503).json({ error: 'Binding store not initialized' });\n  }\n  const deleted = await store.delete(req.params.id);\n  if (!deleted) {\n    return res.status(404).json({ error: 'Binding not found' });\n  }\n  return res.json({ ok: true });\n});\n```\n\n## Acceptance Criteria\n\n- BindingStore and BindingRouter are initialized during AdapterManager.init()\n- Both are shut down during AdapterManager.shutdown()\n- `getBindingStore()` exposes the store for route handlers\n- GET `/api/relay/bindings` returns `{ bindings: AdapterBinding[] }`\n- POST `/api/relay/bindings` validates with CreateBindingRequestSchema, returns 201 with `{ binding }`\n- GET `/api/relay/bindings/:id` returns `{ binding }` or 404\n- DELETE `/api/relay/bindings/:id` returns `{ ok: true }` or 404\n- All binding routes return 503 if adapter manager or binding store is unavailable\n- Running `pnpm typecheck` passes\n\n## Tests\n\nAdd route tests or extend existing relay route tests to cover binding endpoints. Mock AdapterManager.getBindingStore() to return a mock BindingStore.",
      "activeForm": "Wiring BindingRouter into AdapterManager and adding HTTP routes",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Core Routing",
      "subject": "[adapter-agent-routing] [P2] Add Transport interface methods and implement in all transports",
      "description": "Extend the Transport interface with binding CRUD methods and implement them in HttpTransport, DirectTransport, and MockTransport.\n\n## Transport Interface\n\nAdd to `packages/shared/src/transport.ts`, in a new `// --- Relay Bindings ---` section after the Relay Adapters section:\n\n```typescript\nimport type { AdapterBinding, CreateBindingRequest } from './relay-schemas.js';\n\n// Add to the Transport interface:\n\n  // --- Relay Bindings ---\n\n  /** List all adapter-agent bindings. */\n  getBindings(): Promise<AdapterBinding[]>;\n  /** Create a new adapter-agent binding. */\n  createBinding(input: CreateBindingRequest): Promise<AdapterBinding>;\n  /** Delete an adapter-agent binding by ID. */\n  deleteBinding(id: string): Promise<void>;\n```\n\n## HttpTransport Implementation\n\nIn `apps/client/src/layers/shared/lib/http-transport.ts` (or wherever HttpTransport is defined), add:\n\n```typescript\nasync getBindings(): Promise<AdapterBinding[]> {\n  const res = await this.fetch('/api/relay/bindings');\n  const data = await res.json();\n  return data.bindings;\n}\n\nasync createBinding(input: CreateBindingRequest): Promise<AdapterBinding> {\n  const res = await this.fetch('/api/relay/bindings', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(input),\n  });\n  const data = await res.json();\n  return data.binding;\n}\n\nasync deleteBinding(id: string): Promise<void> {\n  await this.fetch(`/api/relay/bindings/${id}`, { method: 'DELETE' });\n}\n```\n\n## DirectTransport Implementation\n\nIn the DirectTransport (Obsidian plugin transport), add passthrough calls to BindingStore:\n\n```typescript\nasync getBindings(): Promise<AdapterBinding[]> {\n  return this.bindingStore?.getAll() ?? [];\n}\n\nasync createBinding(input: CreateBindingRequest): Promise<AdapterBinding> {\n  if (!this.bindingStore) throw new Error('Binding store not available');\n  return this.bindingStore.create(input);\n}\n\nasync deleteBinding(id: string): Promise<void> {\n  if (!this.bindingStore) throw new Error('Binding store not available');\n  await this.bindingStore.delete(id);\n}\n```\n\n## MockTransport (test-utils)\n\nIn `packages/test-utils/`, add to `createMockTransport()`:\n\n```typescript\ngetBindings: vi.fn().mockResolvedValue([]),\ncreateBinding: vi.fn().mockResolvedValue({\n  id: 'mock-binding-id',\n  adapterId: 'mock-adapter',\n  agentId: 'mock-agent',\n  agentDir: '/mock/agent',\n  sessionStrategy: 'per-chat',\n  label: '',\n  createdAt: new Date().toISOString(),\n  updatedAt: new Date().toISOString(),\n}),\ndeleteBinding: vi.fn().mockResolvedValue(undefined),\n```\n\n## Acceptance Criteria\n\n- Transport interface includes `getBindings()`, `createBinding()`, `deleteBinding()`\n- HttpTransport calls the correct API endpoints (GET/POST/DELETE `/api/relay/bindings`)\n- DirectTransport passes through to BindingStore methods\n- MockTransport returns sensible defaults and can be overridden in tests\n- `pnpm typecheck` passes across all packages (shared, client, server, test-utils, obsidian-plugin)\n\n## Tests\n\nVerify HttpTransport methods make correct fetch calls by checking existing transport test patterns. The MockTransport implementation will be tested implicitly by client component tests in Phase 3.",
      "activeForm": "Adding binding methods to Transport interface and all implementations",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.4",
      "phase": 2,
      "phaseName": "Core Routing",
      "subject": "[adapter-agent-routing] [P2] Add MCP tools for binding management",
      "description": "Add `binding_list`, `binding_create`, and `binding_delete` MCP tools so agents can manage their own bindings programmatically.\n\n## File to Modify\n\nLocate the MCP tool server file (referenced as `apps/server/src/services/mcp-tool-server.ts` in CLAUDE.md — may be in a different path if restructured). The factory function `createDorkOsToolServer(deps)` accepts `McpToolDeps` which needs `bindingStore` added.\n\n## Implementation\n\n1. Add `bindingStore` to `McpToolDeps` interface:\n```typescript\nexport interface McpToolDeps {\n  transcriptReader: TranscriptReader;\n  defaultCwd: string;\n  pulseStore?: PulseStore;\n  relayCore?: RelayCore;\n  meshCore?: MeshCore;\n  bindingStore?: BindingStore; // NEW\n}\n```\n\n2. Add the three binding tools inside the factory function, after the existing Relay tools section:\n\n```typescript\n// --- Binding Tools ---\n\ntool('binding_list', {}, async () => {\n  const bindings = deps.bindingStore?.getAll() ?? [];\n  return {\n    content: [{ type: 'text', text: JSON.stringify(bindings, null, 2) }],\n  };\n});\n\ntool(\n  'binding_create',\n  {\n    adapterId: z.string().describe('ID of the adapter to bind'),\n    agentId: z.string().describe('ID of the target agent'),\n    agentDir: z.string().describe('Working directory of the target agent'),\n    sessionStrategy: SessionStrategySchema.optional().describe('Session reuse strategy'),\n    chatId: z.string().optional().describe('Optional chat ID for specific chat binding'),\n    channelType: z.string().optional().describe('Optional channel type filter'),\n    label: z.string().optional().describe('Human-readable label for the binding'),\n  },\n  async (params) => {\n    if (!deps.bindingStore) {\n      return { content: [{ type: 'text', text: 'Error: Binding store not available' }] };\n    }\n    try {\n      const binding = await deps.bindingStore.create(params);\n      return {\n        content: [{ type: 'text', text: JSON.stringify(binding, null, 2) }],\n      };\n    } catch (err) {\n      return {\n        content: [\n          { type: 'text', text: `Error: ${err instanceof Error ? err.message : 'Unknown error'}` },\n        ],\n      };\n    }\n  },\n);\n\ntool(\n  'binding_delete',\n  {\n    id: z.string().describe('UUID of the binding to delete'),\n  },\n  async (params) => {\n    if (!deps.bindingStore) {\n      return { content: [{ type: 'text', text: 'Error: Binding store not available' }] };\n    }\n    const success = await deps.bindingStore.delete(params.id);\n    return {\n      content: [{ type: 'text', text: success ? 'Deleted' : 'Not found' }],\n    };\n  },\n);\n```\n\n3. Where `createDorkOsToolServer()` is called (likely in `index.ts` or server startup), pass `bindingStore` from AdapterManager:\n\n```typescript\nconst toolServer = createDorkOsToolServer({\n  // ... existing deps ...\n  bindingStore: adapterManager?.getBindingStore(),\n});\n```\n\n## Acceptance Criteria\n\n- `binding_list` returns all bindings as formatted JSON (empty array if store not available)\n- `binding_create` creates a binding with the provided params and returns the created binding\n- `binding_create` returns an error message if binding store is not available\n- `binding_delete` returns 'Deleted' on success, 'Not found' when ID doesn't exist\n- All three tools are registered and visible to agent sessions via MCP\n- `pnpm typecheck` passes\n\n## Tests\n\nIf MCP tool tests exist, add test cases for the three new tools. Otherwise, the tools will be tested via integration tests in Phase 2 testing.",
      "activeForm": "Adding MCP tools for binding management",
      "size": "small",
      "priority": "medium",
      "dependencies": ["1.3", "2.2"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Visual Configuration",
      "subject": "[adapter-agent-routing] [P3] Create entities/binding FSD entity with TanStack Query hooks",
      "description": "Create the `entities/binding/` FSD entity layer with TanStack Query hooks for binding CRUD, following existing patterns from `entities/relay/`.\n\n## File Structure\n\nCreate the following files in `apps/client/src/layers/entities/binding/`:\n\n```\nentities/binding/\n├── model/\n│   ├── use-bindings.ts\n│   ├── use-create-binding.ts\n│   └── use-delete-binding.ts\n└── index.ts\n```\n\n## `model/use-bindings.ts`\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Fetch all adapter-agent bindings from the server. */\nexport function useBindings() {\n  const transport = useTransport();\n  return useQuery({\n    queryKey: ['relay', 'bindings'],\n    queryFn: () => transport.getBindings(),\n  });\n}\n```\n\n## `model/use-create-binding.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport type { CreateBindingRequest } from '@dorkos/shared/relay-schemas';\n\n/** Create a new adapter-agent binding. Invalidates bindings cache on success. */\nexport function useCreateBinding() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (input: CreateBindingRequest) => transport.createBinding(input),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['relay', 'bindings'] });\n    },\n  });\n}\n```\n\n## `model/use-delete-binding.ts`\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/** Delete an adapter-agent binding by ID. Invalidates bindings cache on success. */\nexport function useDeleteBinding() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (id: string) => transport.deleteBinding(id),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['relay', 'bindings'] });\n    },\n  });\n}\n```\n\n## `index.ts`\n\n```typescript\n/**\n * Binding entity — domain hooks for adapter-agent binding lifecycle.\n *\n * @module entities/binding\n */\nexport { useBindings } from './model/use-bindings';\nexport { useCreateBinding } from './model/use-create-binding';\nexport { useDeleteBinding } from './model/use-delete-binding';\n```\n\n## Acceptance Criteria\n\n- `useBindings()` returns a TanStack Query result with `data: AdapterBinding[]`\n- `useCreateBinding()` returns a mutation that posts to the server and invalidates the `['relay', 'bindings']` query key on success\n- `useDeleteBinding()` returns a mutation that deletes and invalidates on success\n- All hooks use `useTransport()` from shared model layer (FSD compliant — entities can import from shared)\n- Barrel exports are clean and follow TSDoc conventions\n- `pnpm typecheck` passes for the client app\n\n## Tests\n\nCreate `apps/client/src/layers/entities/binding/__tests__/use-bindings.test.ts`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { useBindings } from '../model/use-bindings';\n\nfunction createWrapper() {\n  const queryClient = new QueryClient({ defaultOptions: { queries: { retry: false } } });\n  const transport = createMockTransport();\n  return {\n    transport,\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <QueryClientProvider client={queryClient}>\n        <TransportProvider transport={transport}>{children}</TransportProvider>\n      </QueryClientProvider>\n    ),\n  };\n}\n\ndescribe('useBindings', () => {\n  it('fetches bindings via transport', async () => {\n    const { wrapper, transport } = createWrapper();\n    vi.mocked(transport.getBindings).mockResolvedValue([\n      { id: '1', adapterId: 'tg', agentId: 'a', agentDir: '/a', sessionStrategy: 'per-chat', label: '', createdAt: '', updatedAt: '' },\n    ]);\n    const { result } = renderHook(() => useBindings(), { wrapper });\n    await waitFor(() => expect(result.current.isSuccess).toBe(true));\n    expect(result.current.data).toHaveLength(1);\n  });\n});\n```",
      "activeForm": "Creating binding entity hooks with TanStack Query",
      "size": "small",
      "priority": "high",
      "dependencies": ["2.3"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Visual Configuration",
      "subject": "[adapter-agent-routing] [P3] Create AdapterNode and BindingEdge React Flow components",
      "description": "Create custom React Flow node and edge components for adapters and bindings in the TopologyGraph.\n\n## AdapterNode Component\n\nCreate `apps/client/src/layers/features/mesh/ui/AdapterNode.tsx`:\n\n```typescript\nimport { memo } from 'react';\nimport { Handle, Position, type NodeProps } from '@xyflow/react';\nimport { cn } from '@/layers/shared/lib';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { MessageSquare, Webhook, Bot } from 'lucide-react';\n\n/** Data shape for adapter nodes in React Flow. */\nexport interface AdapterNodeData extends Record<string, unknown> {\n  adapterName: string;\n  adapterType: string;\n  adapterStatus: 'running' | 'stopped' | 'error';\n  bindingCount: number;\n  platformIcon?: string;\n}\n\nconst STATUS_COLORS: Record<string, string> = {\n  running: 'bg-green-500',\n  stopped: 'bg-zinc-400',\n  error: 'bg-red-500',\n};\n\nconst PLATFORM_ICONS: Record<string, React.ElementType> = {\n  telegram: MessageSquare,\n  webhook: Webhook,\n  default: Bot,\n};\n\nexport const ADAPTER_NODE_WIDTH = 200;\nexport const ADAPTER_NODE_HEIGHT = 100;\n\nfunction AdapterNodeInner({ data, selected }: NodeProps<AdapterNodeData>) {\n  const Icon = PLATFORM_ICONS[data.adapterType] ?? PLATFORM_ICONS.default;\n\n  return (\n    <div\n      className={cn(\n        'rounded-xl border bg-card p-4 shadow-soft transition-shadow',\n        selected && 'ring-2 ring-primary',\n      )}\n      style={{ width: ADAPTER_NODE_WIDTH, minHeight: ADAPTER_NODE_HEIGHT }}\n    >\n      <Handle type=\"source\" position={Position.Right} isConnectable />\n\n      <div className=\"flex items-center gap-2\">\n        <div className={cn('size-2.5 rounded-full', STATUS_COLORS[data.adapterStatus] ?? 'bg-zinc-400')} />\n        <Icon className=\"size-4 text-muted-foreground\" />\n        <span className=\"truncate text-sm font-medium\">{data.adapterName}</span>\n      </div>\n\n      <div className=\"mt-2 flex items-center justify-between\">\n        <span className=\"text-xs text-muted-foreground capitalize\">{data.adapterType}</span>\n        {data.bindingCount > 0 && (\n          <Badge variant=\"secondary\" className=\"text-xs\">\n            {data.bindingCount} binding{data.bindingCount !== 1 ? 's' : ''}\n          </Badge>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport const AdapterNode = memo(AdapterNodeInner);\n```\n\n## BindingEdge Component\n\nCreate `apps/client/src/layers/features/mesh/ui/BindingEdge.tsx`:\n\n```typescript\nimport { memo } from 'react';\nimport {\n  BaseEdge,\n  EdgeLabelRenderer,\n  getBezierPath,\n  type EdgeProps,\n} from '@xyflow/react';\nimport { X } from 'lucide-react';\nimport { cn } from '@/layers/shared/lib';\n\nexport interface BindingEdgeData extends Record<string, unknown> {\n  label?: string;\n  sessionStrategy?: string;\n  onDelete?: (edgeId: string) => void;\n}\n\nfunction BindingEdgeInner({\n  id,\n  sourceX,\n  sourceY,\n  targetX,\n  targetY,\n  sourcePosition,\n  targetPosition,\n  data,\n  selected,\n}: EdgeProps<BindingEdgeData>) {\n  const [edgePath, labelX, labelY] = getBezierPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n    sourcePosition,\n    targetPosition,\n  });\n\n  const displayLabel = data?.label || data?.sessionStrategy || 'Binding';\n\n  return (\n    <>\n      <BaseEdge\n        id={id}\n        path={edgePath}\n        className={cn('stroke-primary/60 stroke-2', selected && 'stroke-primary')}\n      />\n      <EdgeLabelRenderer>\n        <div\n          style={{\n            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n            pointerEvents: 'all',\n          }}\n          className=\"nodrag nopan flex items-center gap-1 rounded-md bg-background/90 px-2 py-1 text-xs shadow-sm\"\n        >\n          <span className=\"text-muted-foreground\">{displayLabel}</span>\n          {data?.onDelete && (\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                data.onDelete?.(id);\n              }}\n              className=\"ml-1 rounded-sm p-0.5 text-destructive/60 hover:bg-destructive/10 hover:text-destructive\"\n              aria-label=\"Delete binding\"\n            >\n              <X className=\"size-3\" />\n            </button>\n          )}\n        </div>\n      </EdgeLabelRenderer>\n    </>\n  );\n}\n\nexport const BindingEdge = memo(BindingEdgeInner);\n```\n\n## Acceptance Criteria\n\n- `AdapterNode` renders adapter name, type icon, status indicator, and binding count badge\n- `AdapterNode` has a right-side Handle for creating connections to agents\n- `AdapterNode` is memoized with `memo()`\n- `BindingEdge` renders a bezier path with a label showing the binding label or session strategy\n- `BindingEdge` has a delete button (X icon) that calls `data.onDelete(id)` on click\n- Both components follow existing styling patterns (rounded-xl, shadow-soft, cn utility)\n- Both components accept Record<string, unknown> in their data type (React Flow requirement)\n\n## Tests\n\nCreate `apps/client/src/layers/features/mesh/ui/__tests__/AdapterNode.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { ReactFlowProvider } from '@xyflow/react';\nimport { AdapterNode } from '../AdapterNode';\n\nconst mockProps = {\n  id: 'adapter-1',\n  type: 'adapter' as const,\n  data: {\n    adapterName: 'Telegram Bot',\n    adapterType: 'telegram',\n    adapterStatus: 'running' as const,\n    bindingCount: 2,\n  },\n  selected: false,\n  isConnectable: true,\n  positionAbsoluteX: 0,\n  positionAbsoluteY: 0,\n  zIndex: 0,\n  dragging: false,\n};\n\ndescribe('AdapterNode', () => {\n  it('renders adapter name and type', () => {\n    render(\n      <ReactFlowProvider>\n        <AdapterNode {...mockProps} />\n      </ReactFlowProvider>,\n    );\n    expect(screen.getByText('Telegram Bot')).toBeInTheDocument();\n    expect(screen.getByText('telegram')).toBeInTheDocument();\n  });\n\n  it('shows binding count badge', () => {\n    render(\n      <ReactFlowProvider>\n        <AdapterNode {...mockProps} />\n      </ReactFlowProvider>,\n    );\n    expect(screen.getByText('2 bindings')).toBeInTheDocument();\n  });\n});\n```",
      "activeForm": "Creating AdapterNode and BindingEdge React Flow components",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["3.1"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Visual Configuration",
      "subject": "[adapter-agent-routing] [P3] Create BindingDialog for connection configuration",
      "description": "Create a dialog component that appears when the user drags a connection from an adapter to an agent, allowing them to configure the binding's session strategy and label before creation.\n\n## File Location\n\nCreate `apps/client/src/layers/features/mesh/ui/BindingDialog.tsx`.\n\n## Implementation\n\n```typescript\nimport { useState } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/layers/shared/ui/dialog';\nimport { Button } from '@/layers/shared/ui/button';\nimport { Input } from '@/layers/shared/ui/input';\nimport { Label } from '@/layers/shared/ui/label';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/layers/shared/ui/select';\nimport type { SessionStrategy } from '@dorkos/shared/relay-schemas';\n\nconst SESSION_STRATEGIES: { value: SessionStrategy; label: string; description: string }[] = [\n  { value: 'per-chat', label: 'Per Chat', description: 'One session per chat/conversation. Messages from the same chat resume the same session.' },\n  { value: 'per-user', label: 'Per User', description: 'One session per user. All messages from a user share a session across chats.' },\n  { value: 'stateless', label: 'Stateless', description: 'Every message starts a new session. No conversation history.' },\n];\n\nexport interface BindingDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  adapterName: string;\n  agentName: string;\n  onConfirm: (opts: { sessionStrategy: SessionStrategy; label: string }) => void;\n}\n\nexport function BindingDialog({\n  open,\n  onOpenChange,\n  adapterName,\n  agentName,\n  onConfirm,\n}: BindingDialogProps) {\n  const [strategy, setStrategy] = useState<SessionStrategy>('per-chat');\n  const [label, setLabel] = useState('');\n\n  const handleConfirm = () => {\n    onConfirm({ sessionStrategy: strategy, label });\n    setStrategy('per-chat');\n    setLabel('');\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle>Create Binding</DialogTitle>\n        </DialogHeader>\n\n        <div className=\"space-y-4 py-4\">\n          <p className=\"text-sm text-muted-foreground\">\n            Connect <span className=\"font-medium text-foreground\">{adapterName}</span> to{' '}\n            <span className=\"font-medium text-foreground\">{agentName}</span>\n          </p>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"session-strategy\">Session Strategy</Label>\n            <Select value={strategy} onValueChange={(v) => setStrategy(v as SessionStrategy)}>\n              <SelectTrigger id=\"session-strategy\">\n                <SelectValue />\n              </SelectTrigger>\n              <SelectContent>\n                {SESSION_STRATEGIES.map((s) => (\n                  <SelectItem key={s.value} value={s.value}>\n                    {s.label}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n            <p className=\"text-xs text-muted-foreground\">\n              {SESSION_STRATEGIES.find((s) => s.value === strategy)?.description}\n            </p>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"binding-label\">Label (optional)</Label>\n            <Input\n              id=\"binding-label\"\n              placeholder=\"e.g., Customer support bot\"\n              value={label}\n              onChange={(e) => setLabel(e.target.value)}\n            />\n          </div>\n        </div>\n\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\n            Cancel\n          </Button>\n          <Button onClick={handleConfirm}>Create Binding</Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n```\n\n## Acceptance Criteria\n\n- Dialog shows adapter name and agent name in the description\n- Session strategy selector defaults to 'per-chat' with three options\n- Each strategy option has a description shown below the selector\n- Label input is optional with a placeholder\n- Confirm button calls `onConfirm` with the selected strategy and label\n- Cancel button closes the dialog without creating a binding\n- State resets on confirm (ready for next use)\n- Component follows existing Dialog patterns from shadcn/ui\n\n## Tests\n\nCreate `apps/client/src/layers/features/mesh/ui/__tests__/BindingDialog.test.tsx`:\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport { BindingDialog } from '../BindingDialog';\n\ndescribe('BindingDialog', () => {\n  it('renders adapter and agent names', () => {\n    render(\n      <BindingDialog\n        open={true}\n        onOpenChange={vi.fn()}\n        adapterName=\"Telegram Bot\"\n        agentName=\"Support Agent\"\n        onConfirm={vi.fn()}\n      />,\n    );\n    expect(screen.getByText('Telegram Bot')).toBeInTheDocument();\n    expect(screen.getByText('Support Agent')).toBeInTheDocument();\n  });\n\n  it('calls onConfirm with default strategy', async () => {\n    const user = userEvent.setup();\n    const onConfirm = vi.fn();\n    render(\n      <BindingDialog\n        open={true}\n        onOpenChange={vi.fn()}\n        adapterName=\"Telegram\"\n        agentName=\"Agent\"\n        onConfirm={onConfirm}\n      />,\n    );\n    await user.click(screen.getByText('Create Binding'));\n    expect(onConfirm).toHaveBeenCalledWith({ sessionStrategy: 'per-chat', label: '' });\n  });\n});\n```",
      "activeForm": "Creating BindingDialog for connection configuration",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Visual Configuration",
      "subject": "[adapter-agent-routing] [P3] Extend TopologyGraph with adapter nodes, binding edges, and connection validation",
      "description": "Modify the existing `TopologyGraph.tsx` to include adapter nodes on the left, agent nodes on the right, binding edges between them, and drag-to-connect interaction with validation.\n\n## File to Modify\n\n`apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`\n\n## Changes\n\n### 1. Import new components and hooks\n\nAdd to the imports at the top of the file:\n```typescript\nimport { AdapterNode, ADAPTER_NODE_WIDTH, ADAPTER_NODE_HEIGHT, type AdapterNodeData } from './AdapterNode';\nimport { BindingEdge, type BindingEdgeData } from './BindingEdge';\nimport { BindingDialog } from './BindingDialog';\nimport { useBindings, useCreateBinding, useDeleteBinding } from '@/layers/entities/binding';\nimport { useRelayAdapters } from '@/layers/entities/relay';\nimport type { Connection } from '@xyflow/react';\nimport type { SessionStrategy } from '@dorkos/shared/relay-schemas';\n```\n\n### 2. Register new node/edge types\n\nUpdate the NODE_TYPES and EDGE_TYPES constants:\n```typescript\nconst NODE_TYPES: NodeTypes = {\n  agent: AgentNode,\n  'namespace-group': NamespaceGroupNode,\n  adapter: AdapterNode,  // NEW\n};\n\nconst EDGE_TYPES: EdgeTypes = {\n  'cross-namespace': CrossNamespaceEdge,\n  'cross-namespace-deny': DenyEdge,\n  binding: BindingEdge,  // NEW\n};\n```\n\n### 3. Fetch bindings and adapters data\n\nInside the component (alongside the existing `useTopology()` call), add:\n```typescript\nconst { data: bindings = [] } = useBindings();\nconst { data: adapters = [] } = useRelayAdapters();\nconst createBinding = useCreateBinding();\nconst deleteBinding = useDeleteBinding();\n```\n\n### 4. Convert adapters to nodes\n\nAdd a helper function and merge adapter nodes into the nodes array:\n```typescript\nfunction adapterToNode(adapter: AdapterListItem, index: number, allBindings: AdapterBinding[]): Node<AdapterNodeData> {\n  return {\n    id: `adapter-${adapter.config.id}`,\n    type: 'adapter',\n    position: { x: 0, y: index * (ADAPTER_NODE_HEIGHT + 24) },\n    data: {\n      adapterName: adapter.config.id,\n      adapterType: adapter.config.type,\n      adapterStatus: adapter.status,\n      bindingCount: allBindings.filter(b => b.adapterId === adapter.config.id).length,\n    },\n  };\n}\n```\n\n### 5. Convert bindings to edges\n\n```typescript\nfunction bindingToEdge(binding: AdapterBinding, onDelete: (id: string) => void): Edge<BindingEdgeData> {\n  return {\n    id: `binding-${binding.id}`,\n    type: 'binding',\n    source: `adapter-${binding.adapterId}`,\n    target: `agent-${binding.agentId}`,\n    data: {\n      label: binding.label || binding.sessionStrategy,\n      sessionStrategy: binding.sessionStrategy,\n      onDelete: (edgeId: string) => {\n        const bindingId = edgeId.replace('binding-', '');\n        onDelete(bindingId);\n      },\n    },\n  };\n}\n```\n\n### 6. Connection validation\n\nAdd connection validation that only allows adapter→agent connections:\n```typescript\nconst isValidConnection = useCallback((connection: Connection) => {\n  const sourceNode = allNodes.find(n => n.id === connection.source);\n  const targetNode = allNodes.find(n => n.id === connection.target);\n  if (!sourceNode || !targetNode) return false;\n  return sourceNode.type === 'adapter' && targetNode.type === 'agent';\n}, [allNodes]);\n```\n\n### 7. Connection handler with BindingDialog\n\nAdd state for the pending connection and dialog:\n```typescript\nconst [pendingConnection, setPendingConnection] = useState<{\n  adapterId: string;\n  adapterName: string;\n  agentId: string;\n  agentName: string;\n} | null>(null);\n\nconst onConnect = useCallback((connection: Connection) => {\n  const sourceNode = allNodes.find(n => n.id === connection.source);\n  const targetNode = allNodes.find(n => n.id === connection.target);\n  if (!sourceNode || !targetNode) return;\n  setPendingConnection({\n    adapterId: sourceNode.id.replace('adapter-', ''),\n    adapterName: (sourceNode.data as AdapterNodeData).adapterName,\n    agentId: targetNode.id.replace('agent-', ''),\n    agentName: (targetNode.data as AgentNodeData).label,\n  });\n}, [allNodes]);\n\nconst handleCreateBinding = (opts: { sessionStrategy: SessionStrategy; label: string }) => {\n  if (!pendingConnection) return;\n  const agentNode = allNodes.find(n => n.id === `agent-${pendingConnection.agentId}`);\n  createBinding.mutate({\n    adapterId: pendingConnection.adapterId,\n    agentId: pendingConnection.agentId,\n    agentDir: '', // resolved from agent node data if available\n    sessionStrategy: opts.sessionStrategy,\n    label: opts.label,\n  });\n  setPendingConnection(null);\n};\n\nconst handleDeleteBinding = (bindingId: string) => {\n  deleteBinding.mutate(bindingId);\n};\n```\n\n### 8. Update ReactFlow props\n\nChange `nodesConnectable={false}` to `nodesConnectable={true}` and add:\n```typescript\n<ReactFlow\n  nodes={allNodes}\n  edges={allEdges}\n  nodeTypes={NODE_TYPES}\n  edgeTypes={EDGE_TYPES}\n  nodesConnectable={true}\n  isValidConnection={isValidConnection}\n  onConnect={onConnect}\n  // ... existing props\n>\n```\n\n### 9. ELK layout update\n\nUpdate the ELK layout options to position adapters left, agents right:\n```typescript\nconst elkOptions = {\n  'elk.algorithm': 'layered',\n  'elk.direction': 'RIGHT',\n  'elk.layered.spacing.nodeNodeBetweenLayers': '120',\n};\n// Adapter nodes: layoutOptions 'elk.layered.layerConstraint' = 'FIRST'\n// Agent nodes: layoutOptions 'elk.layered.layerConstraint' = 'LAST'\n```\n\n### 10. Render BindingDialog\n\nAdd after the ReactFlow component:\n```typescript\n<BindingDialog\n  open={!!pendingConnection}\n  onOpenChange={(open) => !open && setPendingConnection(null)}\n  adapterName={pendingConnection?.adapterName ?? ''}\n  agentName={pendingConnection?.agentName ?? ''}\n  onConfirm={handleCreateBinding}\n/>\n```\n\n## Acceptance Criteria\n\n- Adapters appear as nodes on the left side of the topology canvas\n- Agents appear on the right side (existing behavior, now with layer constraint)\n- Bindings render as bezier edges between adapter and agent nodes\n- Dragging from an adapter handle to an agent handle opens the BindingDialog\n- Invalid connections (adapter→adapter, agent→agent) are rejected\n- Edge labels show binding label or session strategy\n- Edge delete button removes the binding via the DELETE endpoint\n- ELK layout positions adapters left, agents right\n- The component handles empty states (no adapters, no bindings)\n\n## Tests\n\nThe TopologyGraph is complex to unit test due to React Flow dependencies. Verify via:\n1. `pnpm typecheck` passes\n2. Manual testing: adapters visible, connections work, dialog appears\n3. AdapterNode and BindingEdge are tested individually (task 3.2)",
      "activeForm": "Extending TopologyGraph with adapter nodes and connection interaction",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1", "3.2", "3.3"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Polish",
      "subject": "[adapter-agent-routing] [P4] Handle edge cases: orphaned bindings, stale sessions, and empty states",
      "description": "Add resilience for edge cases: orphaned bindings when adapters are deleted, stale session cleanup, and empty state UI.\n\n## Orphaned Binding Detection\n\nIn `BindingStore`, add a method to find bindings that reference non-existent adapters:\n\n```typescript\n/** Find bindings whose adapterId doesn't match any known adapter. */\ngetOrphaned(knownAdapterIds: string[]): AdapterBinding[] {\n  const known = new Set(knownAdapterIds);\n  return this.getAll().filter(b => !known.has(b.adapterId));\n}\n```\n\nIn the TopologyGraph, filter out binding edges where the source adapter node doesn't exist:\n\n```typescript\n// Only create edges for bindings where both adapter and agent nodes exist\nconst validBindingEdges = bindings\n  .filter(b => {\n    const hasAdapter = adapters.some(a => a.config.id === b.adapterId);\n    const hasAgent = allAgentNodes.some(n => n.id === `agent-${b.agentId}`);\n    return hasAdapter && hasAgent;\n  })\n  .map(b => bindingToEdge(b, handleDeleteBinding));\n```\n\n## Stale Session Handling\n\nIn `BindingRouter`, add session validation before reuse:\n\n```typescript\nprivate async getOrCreateSession(key: string, binding: AdapterBinding): Promise<string> {\n  const existing = this.sessionMap.get(key);\n  if (existing) {\n    // Optionally validate session still exists\n    // For now, trust the session map — SDK handles invalid session IDs gracefully\n    return existing;\n  }\n  const sessionId = await this.createNewSession(binding);\n  this.sessionMap.set(key, sessionId);\n  await this.saveSessionMap();\n  return sessionId;\n}\n```\n\nAdd a cleanup method that can be called periodically or on demand:\n```typescript\n/** Remove session mappings for bindings that no longer exist. */\nasync cleanupOrphanedSessions(activeBindingIds: Set<string>): Promise<number> {\n  let removed = 0;\n  for (const [key, _sessionId] of this.sessionMap) {\n    const bindingId = key.split(':')[0];\n    if (!activeBindingIds.has(bindingId)) {\n      this.sessionMap.delete(key);\n      removed++;\n    }\n  }\n  if (removed > 0) {\n    await this.saveSessionMap();\n    logger.info(`Cleaned up ${removed} orphaned session mapping(s)`);\n  }\n  return removed;\n}\n```\n\n## Empty State UI\n\nIn TopologyGraph, when there are no adapters at all, show a helpful empty state:\n\n```typescript\n{adapters.length === 0 && agents.length === 0 && (\n  <div className=\"flex h-full items-center justify-center\">\n    <div className=\"text-center\">\n      <p className=\"text-sm text-muted-foreground\">\n        No adapters or agents configured.\n      </p>\n      <p className=\"mt-1 text-xs text-muted-foreground\">\n        Register agents in the Mesh panel and configure adapters in the Relay panel.\n      </p>\n    </div>\n  </div>\n)}\n```\n\nWhen adapters exist but no bindings, show adapter nodes with a hint:\n\n```typescript\n// In TopologyLegend or as a banner:\n{adapters.length > 0 && bindings.length === 0 && (\n  <p className=\"text-xs text-muted-foreground italic\">\n    Drag from an adapter to an agent to create a binding.\n  </p>\n)}\n```\n\n## Acceptance Criteria\n\n- Bindings referencing deleted adapters don't cause rendering errors in the topology\n- Binding edges are only rendered when both source (adapter) and target (agent) nodes exist\n- BindingRouter handles invalid session IDs gracefully (SDK creates new session on invalid resume)\n- `cleanupOrphanedSessions()` removes session map entries for deleted bindings\n- TopologyGraph shows helpful empty states when no adapters/agents or no bindings exist\n- No runtime errors when adapter list is empty, binding list is empty, or agent list is empty\n\n## Tests\n\nAdd test cases to existing BindingStore tests:\n```typescript\ndescribe('getOrphaned()', () => {\n  it('returns bindings with unknown adapter IDs', async () => {\n    await store.create({ adapterId: 'known-1', agentId: 'a', agentDir: '/a' });\n    await store.create({ adapterId: 'unknown-1', agentId: 'b', agentDir: '/b' });\n    const orphaned = store.getOrphaned(['known-1']);\n    expect(orphaned).toHaveLength(1);\n    expect(orphaned[0].adapterId).toBe('unknown-1');\n  });\n});\n```\n\nAdd test cases to BindingRouter tests:\n```typescript\ndescribe('cleanupOrphanedSessions()', () => {\n  it('removes session entries for deleted bindings', async () => {\n    // Setup: create sessions for two bindings\n    // Then cleanup with only one binding active\n    // Verify the orphaned session entry is removed\n  });\n});\n```",
      "activeForm": "Handling edge cases for orphaned bindings and empty states",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["3.4"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Polish",
      "subject": "[adapter-agent-routing] [P4] Update documentation with BindingStore, BindingRouter, and binding entity",
      "description": "Update project documentation to reflect the new binding system.\n\n## Files to Update\n\n### 1. `CLAUDE.md` — Service inventory\n\nIn the server services list (the numbered list of twenty-six services), add entries for BindingStore and BindingRouter:\n\n```markdown\n- **`services/relay/binding-store.ts`** - JSON file-backed store for adapter-agent bindings at `~/.dork/relay/bindings.json`. CRUD operations, most-specific-first resolution scoring, chokidar hot-reload. Atomic write via temp file + rename.\n- **`services/relay/binding-router.ts`** - Central routing service that subscribes to `relay.human.*`, resolves adapter-agent bindings via BindingStore, manages session lifecycle (per-chat, per-user, stateless strategies), and republishes to `relay.agent.*` for ClaudeCodeAdapter. Persists session map to `~/.dork/relay/sessions.json`.\n```\n\nIn the route descriptions for `routes/relay.ts`, add:\n```markdown\nBinding CRUD: GET/POST/DELETE `/api/relay/bindings`, GET `/api/relay/bindings/:id`.\n```\n\nIn the FSD layer table for the client, add:\n```markdown\n| `entities/binding/`    | useBindings, useCreateBinding, useDeleteBinding                    | Binding domain hooks        |\n```\n\nIn the MCP tools description, add:\n```markdown\nBinding tools: `binding_list`, `binding_create`, `binding_delete`.\n```\n\n### 2. `contributing/architecture.md` — Architecture overview\n\nAdd BindingRouter to the service inventory section, describing its role in the relay message flow.\n\n### 3. `contributing/api-reference.md` — API endpoints\n\nAdd the four binding endpoints:\n- `GET /api/relay/bindings` — List all adapter-agent bindings\n- `POST /api/relay/bindings` — Create a binding (validates with CreateBindingRequestSchema)\n- `GET /api/relay/bindings/:id` — Get single binding\n- `DELETE /api/relay/bindings/:id` — Delete binding\n\n## Acceptance Criteria\n\n- CLAUDE.md accurately lists BindingStore and BindingRouter in the service inventory\n- CLAUDE.md includes binding routes in the relay routes description\n- CLAUDE.md includes `entities/binding/` in the FSD layer table\n- CLAUDE.md includes binding MCP tools\n- contributing/architecture.md mentions the BindingRouter in the appropriate section\n- contributing/api-reference.md documents the binding endpoints\n- All documentation is factually accurate and matches the implemented code",
      "activeForm": "Updating documentation with binding system details",
      "size": "small",
      "priority": "low",
      "dependencies": ["3.4"],
      "parallelWith": ["4.1"]
    }
  ]
}
