{
  "spec": "specs/db-drizzle-consolidation/02-specification.md",
  "slug": "db-drizzle-consolidation",
  "generatedAt": "2026-02-26T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation — packages/db",
      "subject": "[db-drizzle-consolidation] [P1] Scaffold packages/db workspace package",
      "description": "Create the `packages/db` workspace package with all configuration files.\n\n## Steps\n\n1. Create directory `packages/db/src/schema/`.\n\n2. Create `packages/db/package.json`:\n```json\n{\n  \"name\": \"@dorkos/db\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./src/index.ts\",\n      \"default\": \"./src/index.ts\"\n    }\n  },\n  \"scripts\": {\n    \"db:generate\": \"drizzle-kit generate --config drizzle.config.ts\",\n    \"db:check\": \"drizzle-kit generate --config drizzle.config.ts && git diff --exit-code drizzle/\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"better-sqlite3\": \"^11.0.0\",\n    \"drizzle-orm\": \"^0.39.0\",\n    \"ulidx\": \"^2.4.0\"\n  },\n  \"devDependencies\": {\n    \"@dorkos/typescript-config\": \"workspace:*\",\n    \"@types/better-sqlite3\": \"^7.6.0\",\n    \"drizzle-kit\": \"^0.30.0\",\n    \"typescript\": \"^5.7.0\"\n  }\n}\n```\n\n3. Create `packages/db/tsconfig.json` extending the shared base config:\n```json\n{\n  \"extends\": \"@dorkos/typescript-config/base\",\n  \"compilerOptions\": {\n    \"rootDir\": \"src\",\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n4. Create `packages/db/drizzle.config.ts`:\n```typescript\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  schema: './src/schema/index.ts',\n  out: './drizzle',\n  dialect: 'sqlite',\n  driver: 'better-sqlite3',\n});\n```\n\n5. Run `pnpm install` from repo root to link the new workspace.\n\n6. Add `drizzle-orm: ^0.39.0` to root `package.json` dependencies for monorepo-wide deduplication (prevents `instanceof` check failures when drizzle-orm is instantiated from multiple locations).\n\n7. Verify `pnpm --filter=@dorkos/db run typecheck` passes (will pass once schema files exist in task 1.2).\n\n## Acceptance Criteria\n- `packages/db/package.json` exists with correct name, exports, scripts, and dependencies\n- `packages/db/tsconfig.json` extends the shared base config\n- `packages/db/drizzle.config.ts` exists with sqlite dialect and better-sqlite3 driver\n- `pnpm install` succeeds with the new workspace linked\n- `drizzle-orm` is listed in root package.json dependencies",
      "activeForm": "Scaffolding packages/db workspace package",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation — packages/db",
      "subject": "[db-drizzle-consolidation] [P1] Define Drizzle schema files for all tables",
      "description": "Create the three Drizzle schema files covering all 7 tables from the consolidated database.\n\n## Steps\n\n1. Create `packages/db/src/schema/pulse.ts`:\n```typescript\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\n\n/** Schedule definitions for the Pulse scheduler. Replaces schedules.json. */\nexport const pulseSchedules = sqliteTable('pulse_schedules', {\n  id: text('id').primaryKey(),                    // ULID\n  name: text('name').notNull(),\n  description: text('description'),\n  cron: text('cron').notNull(),\n  timezone: text('timezone').notNull().default('UTC'),\n  prompt: text('prompt').notNull(),\n  cwd: text('cwd'),\n  status: text('status', {\n    enum: ['active', 'paused', 'pending_approval'],\n  }).notNull().default('active'),\n  createdAt: text('created_at').notNull(),\n  updatedAt: text('updated_at').notNull(),\n});\n\n/** Execution history for Pulse scheduler runs. Replaces pulse.db 'runs' table. */\nexport const pulseRuns = sqliteTable('pulse_runs', {\n  id: text('id').primaryKey(),                    // ULID\n  scheduleId: text('schedule_id')\n    .notNull()\n    .references(() => pulseSchedules.id),\n  status: text('status', {\n    enum: ['running', 'completed', 'failed', 'cancelled', 'timeout'],\n  }).notNull(),\n  startedAt: text('started_at').notNull(),        // ISO 8601 TEXT\n  finishedAt: text('finished_at'),\n  durationMs: integer('duration_ms'),\n  output: text('output'),                         // was: output_summary\n  error: text('error'),\n  sessionId: text('session_id'),\n  trigger: text('trigger', {\n    enum: ['scheduled', 'manual', 'agent'],\n  }).notNull().default('scheduled'),\n  createdAt: text('created_at').notNull(),\n});\n```\n\n2. Create `packages/db/src/schema/relay.ts`:\n```typescript\nimport { sqliteTable, text } from 'drizzle-orm/sqlite-core';\n\n/**\n * Derived SQLite index over Maildir message files.\n * This table is fully rebuildable from the Maildir filesystem.\n * Replaces relay/index.db 'messages' table.\n */\nexport const relayIndex = sqliteTable('relay_index', {\n  id: text('id').primaryKey(),                    // ULID (message ID)\n  subject: text('subject').notNull(),\n  endpointHash: text('endpoint_hash').notNull(),\n  status: text('status', {\n    enum: ['pending', 'delivered', 'failed'],     // was: 'new'/'cur' (Maildir terms)\n  }).notNull().default('pending'),\n  expiresAt: text('expires_at'),                  // was: ttl INTEGER (Unix ms)\n  payload: text('payload'),\n  metadata: text('metadata'),\n  createdAt: text('created_at').notNull(),\n});\n\n/** Delivery telemetry for Relay messages. Replaces relay/index.db 'message_traces' table. */\nexport const relayTraces = sqliteTable('relay_traces', {\n  id: text('id').primaryKey(),                    // ULID\n  messageId: text('message_id').notNull().unique(),\n  traceId: text('trace_id').notNull(),\n  subject: text('subject').notNull(),\n  status: text('status', {\n    enum: ['sent', 'delivered', 'failed', 'timeout'],\n  }).notNull(),\n  sentAt: text('sent_at').notNull(),              // ISO 8601 TEXT (was: INTEGER Unix ms)\n  deliveredAt: text('delivered_at'),\n  processedAt: text('processed_at'),\n  errorMessage: text('error_message'),\n  metadata: text('metadata'),\n});\n```\n\n3. Create `packages/db/src/schema/mesh.ts`:\n```typescript\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\n\n/** Registered mesh agents. Replaces mesh/mesh.db 'agents' table. */\nexport const agents = sqliteTable('agents', {\n  id: text('id').primaryKey(),                    // ULID\n  name: text('name').notNull(),\n  runtime: text('runtime').notNull(),\n  projectPath: text('project_path').notNull().unique(),\n  namespace: text('namespace').notNull().default('default'),\n  capabilities: text('capabilities_json').notNull().default('[]'), // JSON array\n  entrypoint: text('entrypoint'),\n  version: text('version'),\n  description: text('description'),\n  approver: text('approver'),\n  status: text('status', {\n    enum: ['active', 'inactive'],\n  }).notNull().default('active'),\n  lastSeenAt: text('last_seen_at'),               // ISO 8601 TEXT\n  lastSeenEvent: text('last_seen_event'),\n  registeredAt: text('registered_at').notNull(),\n  updatedAt: text('updated_at').notNull(),\n  // manifest_json DROPPED — redundant with individual structured columns\n});\n\n/** Paths denied from mesh registration. Replaces 'denials' table. */\nexport const agentDenials = sqliteTable('agent_denials', {\n  id: text('id').primaryKey(),\n  path: text('path').notNull().unique(),\n  reason: text('reason'),\n  denier: text('denier'),\n  createdAt: text('created_at').notNull(),\n});\n\n/**\n * Sliding-window rate limiting buckets per agent per minute.\n * Replaces 'budget_counters' table.\n */\nexport const rateLimitBuckets = sqliteTable('rate_limit_buckets', {\n  agentId: text('agent_id').notNull(),\n  bucketMinute: integer('bucket_minute').notNull(), // minutes since Unix epoch\n  count: integer('count').notNull().default(0),\n});\n```\n\n4. Create `packages/db/src/schema/index.ts`:\n```typescript\n/**\n * Consolidated Drizzle ORM schema for the DorkOS database.\n *\n * Re-exports all table definitions from domain-specific schema files.\n * Used by drizzle.config.ts for migration generation and by createDb()\n * for query type inference.\n *\n * @module db/schema\n */\nexport * from './pulse.js';\nexport * from './relay.js';\nexport * from './mesh.js';\n```\n\n5. Verify `pnpm --filter=@dorkos/db run typecheck` passes.\n\n## Key Design Decisions\n- All IDs are ULID (text primary keys), replacing crypto.randomUUID() in Pulse\n- All timestamps are ISO 8601 TEXT strings, replacing INTEGER Unix ms in relay_traces\n- relay_index status uses 'pending'/'delivered'/'failed' instead of Maildir 'new'/'cur'/'failed'\n- relay_index uses `expires_at` (ISO 8601 TEXT) instead of `ttl` (INTEGER Unix ms)\n- agents table drops `manifest_json` column (was redundant with individual structured columns)\n- pulse_runs renames `output_summary` to `output`\n\n## Acceptance Criteria\n- All three schema files exist and export table definitions using `sqliteTable()`\n- `packages/db/src/schema/index.ts` re-exports all tables\n- TypeScript compiles without errors\n- Table names: pulse_schedules, pulse_runs, relay_index, relay_traces, agents, agent_denials, rate_limit_buckets\n- All text columns for timestamps, all IDs as text (ULID)",
      "activeForm": "Defining Drizzle schema files for all tables",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation — packages/db",
      "subject": "[db-drizzle-consolidation] [P1] Implement createDb, runMigrations, and generate initial migration",
      "description": "Create the main entry point for `packages/db` with the database factory and migration runner, then generate the initial migration SQL.\n\n## Steps\n\n1. Create `packages/db/src/index.ts`:\n```typescript\n/**\n * @dorkos/db — Unified Drizzle ORM database for DorkOS.\n *\n * Provides `createDb()` to open/create the SQLite database, `runMigrations()`\n * to apply pending migrations at startup, and re-exports all schema tables\n * and inferred types.\n *\n * @module db\n */\nimport Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport { migrate } from 'drizzle-orm/better-sqlite3/migrator';\nimport * as schema from './schema/index.js';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n/**\n * Opens (or creates) the DorkOS SQLite database at the given path.\n * Applies WAL mode, NORMAL sync, 5s busy timeout, and foreign key enforcement.\n *\n * @param dbPath - Absolute path to the database file, or ':memory:' for tests\n */\nexport function createDb(dbPath: string) {\n  const sqlite = new Database(dbPath);\n  sqlite.pragma('journal_mode = WAL');\n  sqlite.pragma('synchronous = NORMAL');\n  sqlite.pragma('busy_timeout = 5000');\n  sqlite.pragma('foreign_keys = ON');\n  return drizzle(sqlite, { schema });\n}\n\n/**\n * Applies all pending Drizzle migrations synchronously.\n * Safe to call before server.listen() — no async required.\n * Resolves migrations folder relative to this file (works in both dev and CLI bundle).\n *\n * @param db - Drizzle database instance from createDb()\n */\nexport function runMigrations(db: ReturnType<typeof createDb>): void {\n  const migrationsFolder = path.join(__dirname, '../../drizzle');\n  migrate(db, { migrationsFolder });\n}\n\n/** The Drizzle DB instance type. Use as the parameter type for all stores. */\nexport type Db = ReturnType<typeof createDb>;\n\n// Re-export all schema tables and inferred types\nexport * from './schema/index.js';\n```\n\n2. Generate the initial migration by running:\n```bash\ncd packages/db && npx drizzle-kit generate --config drizzle.config.ts\n```\nThis creates `packages/db/drizzle/0000_initial.sql` and `packages/db/drizzle/meta/_journal.json`.\n\n3. Verify the generated SQL contains CREATE TABLE statements for all 7 tables: `pulse_schedules`, `pulse_runs`, `relay_index`, `relay_traces`, `agents`, `agent_denials`, `rate_limit_buckets`.\n\n4. Commit the `drizzle/` directory to git (migration SQL files are tracked).\n\n## Path Resolution for CLI Bundle\nThe `__dirname` in bundled output resolves to `dist/server/`. So `../../drizzle` resolves to `dist/drizzle/` — where the CLI build script copies the migration SQL files (handled in task 5.1).\n\n## Acceptance Criteria\n- `packages/db/src/index.ts` exports `createDb`, `runMigrations`, `Db` type, and all schema re-exports\n- `createDb(':memory:')` returns a Drizzle instance with WAL mode, foreign keys ON, 5s busy timeout\n- `runMigrations()` applies the initial migration without errors\n- `packages/db/drizzle/0000_initial.sql` exists and is committed to git\n- `packages/db/drizzle/meta/_journal.json` exists with migration metadata\n- Running `runMigrations()` twice on the same DB does not throw (idempotent via `__drizzle_migrations` table)",
      "activeForm": "Implementing createDb, runMigrations, and generating initial migration",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": []
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation — packages/db",
      "subject": "[db-drizzle-consolidation] [P1] Write migration smoke tests and createTestDb helper",
      "description": "Create migration smoke tests in `packages/db` and a reusable `createTestDb()` helper in `packages/test-utils`.\n\n## Steps\n\n1. Create `packages/db/src/__tests__/migrations.test.ts`:\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { createDb, runMigrations } from '../index.js';\n\ndescribe('Database Migrations', () => {\n  it('applies all migrations to a fresh database without errors', () => {\n    expect(() => {\n      const db = createDb(':memory:');\n      runMigrations(db);\n    }).not.toThrow();\n  });\n\n  it('migrations are idempotent — running twice does not throw', () => {\n    const db = createDb(':memory:');\n    runMigrations(db);\n    expect(() => runMigrations(db)).not.toThrow();\n  });\n\n  it('creates all expected tables', () => {\n    const db = createDb(':memory:');\n    runMigrations(db);\n    // Query sqlite_master for table names\n    const tables = db.all<{ name: string }>(\n      db.select({ name: sql`name` }).from(sql`sqlite_master`).where(sql`type = 'table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '__drizzle%'`)\n    );\n    // Alternative approach: use raw SQL via the underlying better-sqlite3 connection\n    // Since Drizzle wraps better-sqlite3, we can use db.$client for raw queries\n    const result = db.$client.prepare(\n      \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '__drizzle%' ORDER BY name\"\n    ).all() as { name: string }[];\n    const tableNames = result.map(r => r.name).sort();\n    expect(tableNames).toEqual([\n      'agent_denials',\n      'agents',\n      'pulse_runs',\n      'pulse_schedules',\n      'rate_limit_buckets',\n      'relay_index',\n      'relay_traces',\n    ]);\n  });\n\n  it('foreign key constraint is enforced on pulse_runs.schedule_id', () => {\n    const db = createDb(':memory:');\n    runMigrations(db);\n    // Attempt to insert a run with a non-existent schedule_id should fail\n    expect(() => {\n      db.$client.prepare(\n        \"INSERT INTO pulse_runs (id, schedule_id, status, started_at, trigger, created_at) VALUES ('01ABC', 'nonexistent', 'running', '2026-01-01T00:00:00Z', 'manual', '2026-01-01T00:00:00Z')\"\n      ).run();\n    }).toThrow(/FOREIGN KEY/);\n  });\n\n  it('WAL mode is enabled', () => {\n    const db = createDb(':memory:');\n    const mode = db.$client.pragma('journal_mode') as { journal_mode: string }[];\n    // In-memory databases use 'memory' journal mode, but the pragma was set.\n    // For file-based databases it would be 'wal'. For :memory: we just verify no error.\n    expect(mode).toBeDefined();\n  });\n});\n```\n\n2. Add `createTestDb()` helper to `packages/test-utils/src/db.ts`:\n```typescript\nimport { createDb, runMigrations } from '@dorkos/db';\nimport type { Db } from '@dorkos/db';\n\n/**\n * Creates a fresh in-memory database with all migrations applied.\n * Use in beforeEach() blocks for isolated test databases.\n */\nexport function createTestDb(): Db {\n  const db = createDb(':memory:');\n  runMigrations(db);\n  return db;\n}\n```\n\n3. Re-export from `packages/test-utils/src/index.ts`:\n```typescript\nexport { createTestDb } from './db.js';\n```\n\n4. Add `@dorkos/db: workspace:*` to `packages/test-utils/package.json` dependencies.\n\n5. Run `pnpm vitest run packages/db/src/__tests__/migrations.test.ts` to verify all tests pass.\n\n## Acceptance Criteria\n- Migration smoke test verifies all 7 tables are created\n- Migration idempotency test passes (run twice, no error)\n- Foreign key enforcement test passes (inserting pulse_run with non-existent schedule_id throws)\n- `createTestDb()` is exported from `@dorkos/test-utils` and returns a fully-migrated in-memory Drizzle DB\n- All tests pass: `pnpm vitest run packages/db/src/__tests__/migrations.test.ts`",
      "activeForm": "Writing migration smoke tests and createTestDb helper",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Foundation — packages/db",
      "subject": "[db-drizzle-consolidation] [P1] Install lefthook and configure pre-commit migration enforcement",
      "description": "Set up lefthook for automatic migration generation when schema files change, and add Turbo tasks for manual generation and CI checks.\n\n## Steps\n\n1. Install lefthook as a root dev dependency:\n```bash\npnpm add -D lefthook -w\n```\n\n2. Add `prepare` script to root `package.json` scripts:\n```json\n{\n  \"scripts\": {\n    \"prepare\": \"lefthook install\"\n  }\n}\n```\n\n3. Create `lefthook.yml` at the repository root:\n```yaml\npre-commit:\n  commands:\n    db-migrations:\n      glob: \"packages/db/src/schema/*.ts\"\n      run: |\n        npx drizzle-kit generate --config packages/db/drizzle.config.ts\n        git add packages/db/drizzle/\n      fail_text: \"DB schema changed — migrations generated and staged. Review and re-commit.\"\n```\n\nHow this works: The `glob` filter means the hook only runs when schema files are staged. When triggered, `drizzle-kit generate` computes the diff between the current schema and the last snapshot, generates a new SQL file in `drizzle/`, and stages it automatically. The commit proceeds with both the schema change and the migration file together. Developers don't need to manually run `drizzle-kit`.\n\n4. Add Turbo tasks to `turbo.json`:\n```json\n{\n  \"tasks\": {\n    \"db:generate\": {\n      \"inputs\": [\n        \"packages/db/src/schema/**/*.ts\",\n        \"packages/db/drizzle.config.ts\"\n      ],\n      \"outputs\": [\"packages/db/drizzle/**\"],\n      \"cache\": true\n    },\n    \"db:check\": {\n      \"inputs\": [\n        \"packages/db/src/schema/**/*.ts\",\n        \"packages/db/drizzle.config.ts\"\n      ],\n      \"cache\": false\n    }\n  }\n}\n```\n\n5. Run `lefthook install` to verify hooks are installed.\n\n6. Verify `turbo run db:generate --filter=@dorkos/db` succeeds.\n\n## Acceptance Criteria\n- `lefthook` is in root devDependencies\n- `prepare` script exists in root package.json\n- `lefthook.yml` exists at repo root with `db-migrations` pre-commit command\n- `lefthook.yml` glob filter targets `packages/db/src/schema/*.ts`\n- `turbo.json` has `db:generate` and `db:check` tasks with correct inputs/outputs\n- `lefthook install` completes without error\n- `turbo run db:generate --filter=@dorkos/db` completes without error",
      "activeForm": "Installing lefthook and configuring pre-commit migration enforcement",
      "size": "small",
      "priority": "medium",
      "dependencies": ["1.3"],
      "parallelWith": ["1.4"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Migrate Pulse",
      "subject": "[db-drizzle-consolidation] [P2] Wire createDb and runMigrations into server startup",
      "description": "Modify `apps/server/src/index.ts` to create the consolidated database at startup and pass the `Db` instance to downstream services.\n\n## Steps\n\n1. Add `@dorkos/db: workspace:*` to `apps/server/package.json` dependencies.\n\n2. In `apps/server/src/index.ts`, add imports:\n```typescript\nimport { createDb, runMigrations } from '@dorkos/db';\nimport type { Db } from '@dorkos/db';\n```\n\n3. In the `start()` function, after `resolveDorkHome()` and before any service instantiation, add:\n```typescript\nconst dorkHome = resolveDorkHome();\nprocess.env.DORK_HOME = dorkHome;\n\n// Create consolidated database\nconst db = createDb(path.join(dorkHome, 'dork.db'));\nrunMigrations(db);\nlogger.info('[db] Migrations applied to ~/.dork/dork.db');\nlogger.info('[db] Legacy databases preserved at previous paths');\n```\n\n4. Pass `db` to PulseStore constructor (change from `new PulseStore(dorkHome)` to `new PulseStore(db)`) — this will be implemented in task 2.2.\n\n5. For now, keep the existing PulseStore constructor signature working — this task only adds the `createDb`/`runMigrations` call. The PulseStore refactor in task 2.2 will change the constructor.\n\n6. Verify server starts successfully with `dotenv -- turbo dev --filter=@dorkos/server`. Check logs for:\n```\n[db] Migrations applied to ~/.dork/dork.db\n[db] Legacy databases preserved at previous paths\n```\n\n7. Verify `~/.dork/dork.db` file is created on disk.\n\n## Acceptance Criteria\n- `@dorkos/db` is in server package.json dependencies\n- Server startup calls `createDb()` and `runMigrations()` before service instantiation\n- `~/.dork/dork.db` is created on first server start\n- Log messages confirm migration application\n- Existing PulseStore/RelayCore/MeshCore constructors still work (backward compatible during migration)\n- Server starts and serves requests normally",
      "activeForm": "Wiring createDb and runMigrations into server startup",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Migrate Pulse",
      "subject": "[db-drizzle-consolidation] [P2] Rewrite PulseStore to use Drizzle ORM",
      "description": "Replace PulseStore's hand-written SQLite prepared statements and schedules.json sidecar with Drizzle query builders against the consolidated database.\n\n## Steps\n\n1. Modify `apps/server/src/services/pulse/pulse-store.ts`:\n\n**Remove these imports:**\n```typescript\nimport Database from 'better-sqlite3';\nimport fs from 'fs';\nimport crypto from 'crypto';\n```\n\n**Add these imports:**\n```typescript\nimport { eq, desc, and, inArray, sql } from 'drizzle-orm';\nimport { pulseSchedules, pulseRuns, type Db } from '@dorkos/db';\nimport { ulid } from 'ulidx';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(dorkHome: string) {\n  // Opens pulse.db, runs PRAGMA user_version migrations, loads schedules.json\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n2. Replace all 9 prepared statements with Drizzle queries. Key method rewrites:\n\n**listSchedules():**\n```typescript\nasync listSchedules(): Promise<PulseSchedule[]> {\n  const rows = this.db.select().from(pulseSchedules).all();\n  return rows.map(this.mapScheduleRow);\n}\n```\n\n**getSchedule(id):**\n```typescript\nasync getSchedule(id: string): Promise<PulseSchedule | undefined> {\n  const [row] = this.db.select().from(pulseSchedules).where(eq(pulseSchedules.id, id)).all();\n  return row ? this.mapScheduleRow(row) : undefined;\n}\n```\n\n**createSchedule(input):**\n```typescript\nasync createSchedule(input: CreateScheduleInput): Promise<PulseSchedule> {\n  const now = new Date().toISOString();\n  const id = ulid();\n  const values = {\n    id,\n    name: input.name,\n    description: input.description ?? null,\n    cron: input.cron,\n    timezone: input.timezone ?? 'UTC',\n    prompt: input.prompt,\n    cwd: input.cwd ?? null,\n    status: (input.status ?? 'active') as 'active' | 'paused' | 'pending_approval',\n    createdAt: now,\n    updatedAt: now,\n  };\n  this.db.insert(pulseSchedules).values(values).run();\n  return this.mapScheduleRow(values);\n}\n```\n\n**updateSchedule(id, updates):**\n```typescript\nasync updateSchedule(id: string, updates: UpdateScheduleRequest): Promise<PulseSchedule | undefined> {\n  const now = new Date().toISOString();\n  this.db.update(pulseSchedules)\n    .set({ ...updates, updatedAt: now })\n    .where(eq(pulseSchedules.id, id))\n    .run();\n  return this.getSchedule(id);\n}\n```\n\n**deleteSchedule(id):**\n```typescript\nasync deleteSchedule(id: string): Promise<boolean> {\n  const result = this.db.delete(pulseSchedules).where(eq(pulseSchedules.id, id)).run();\n  return result.changes > 0;\n}\n```\n\n**createRun(scheduleId, trigger):**\n```typescript\nasync createRun(scheduleId: string, trigger: PulseRunTrigger): Promise<PulseRun> {\n  const now = new Date().toISOString();\n  const id = ulid();\n  const values = {\n    id,\n    scheduleId,\n    status: 'running' as const,\n    startedAt: now,\n    trigger,\n    createdAt: now,\n  };\n  this.db.insert(pulseRuns).values(values).run();\n  return this.mapRunRow({ ...values, finishedAt: null, durationMs: null, output: null, error: null, sessionId: null });\n}\n```\n\n**updateRun(id, updates):**\n```typescript\nasync updateRun(id: string, updates: RunUpdate): Promise<void> {\n  this.db.update(pulseRuns)\n    .set({\n      status: updates.status,\n      finishedAt: updates.finishedAt ?? undefined,\n      durationMs: updates.durationMs ?? undefined,\n      output: updates.outputSummary ?? undefined,\n      error: updates.error ?? undefined,\n      sessionId: updates.sessionId ?? undefined,\n    })\n    .where(eq(pulseRuns.id, id))\n    .run();\n}\n```\n\n**listRuns(options):**\n```typescript\nasync listRuns(options: ListRunsOptions = {}): Promise<PulseRun[]> {\n  let query = this.db.select().from(pulseRuns);\n  const conditions = [];\n  if (options.scheduleId) conditions.push(eq(pulseRuns.scheduleId, options.scheduleId));\n  if (options.status) conditions.push(eq(pulseRuns.status, options.status as any));\n  if (conditions.length > 0) query = query.where(and(...conditions));\n  const rows = query\n    .orderBy(desc(pulseRuns.startedAt))\n    .limit(options.limit ?? 50)\n    .offset(options.offset ?? 0)\n    .all();\n  return rows.map(this.mapRunRow);\n}\n```\n\n3. Remove all `schedules.json` read/write code — schedules are now in the `pulse_schedules` table.\n\n4. Remove `RunRow` interface (Drizzle infers types from schema).\n\n5. Remove `crypto.randomUUID()` — replaced by `ulid()` from `ulidx`.\n\n6. Remove the entire Database constructor, PRAGMA user_version migration chain, and all `this.db.prepare()` calls.\n\n7. Add private helper methods for row mapping (converting Drizzle result rows to PulseSchedule and PulseRun types).\n\n8. Update `apps/server/src/index.ts` to pass `db` to PulseStore:\n```typescript\npulseStore = new PulseStore(db);\n```\n\n## Acceptance Criteria\n- PulseStore constructor accepts `Db` instead of `dorkHome: string`\n- No `better-sqlite3` import in pulse-store.ts\n- No `crypto.randomUUID()` calls — all IDs generated via `ulid()`\n- No `schedules.json` file I/O\n- No prepared statements (`this.db.prepare()`)\n- All CRUD operations use Drizzle query builders\n- Server starts and Pulse routes work correctly in dev\n- `pnpm typecheck` passes",
      "activeForm": "Rewriting PulseStore to use Drizzle ORM",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Migrate Pulse",
      "subject": "[db-drizzle-consolidation] [P2] Update Pulse tests to use createTestDb",
      "description": "Rewrite PulseStore tests to use the in-memory Drizzle database instead of tmpdir SQLite files, and add anti-regression tests for ULID and timestamp standardization.\n\n## Steps\n\n1. Rewrite `apps/server/src/services/pulse/__tests__/pulse-store.test.ts`:\n\n**Remove:**\n- `tmpdir` creation and cleanup\n- Direct `better-sqlite3` Database assertions\n- Any `schedules.json` file assertions\n\n**Replace test setup with:**\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createTestDb } from '@dorkos/test-utils';\nimport type { Db } from '@dorkos/db';\nimport { PulseStore } from '../pulse-store.js';\n\nlet db: Db;\nlet store: PulseStore;\n\nbeforeEach(() => {\n  db = createTestDb();\n  store = new PulseStore(db);\n});\n```\n\n2. Update existing test cases to work with the new constructor and return types. Key tests to verify:\n\n```typescript\nit('createSchedule stores schedule in pulse_schedules', async () => {\n  const schedule = await store.createSchedule({\n    name: 'Test',\n    cron: '* * * * *',\n    prompt: 'run tests',\n    timezone: 'UTC',\n  });\n  expect(schedule.id).toMatch(/^[0-9A-Z]{26}$/); // ULID pattern\n  const found = await store.getSchedule(schedule.id);\n  expect(found?.name).toBe('Test');\n});\n\nit('createRun generates ULID id, not UUID', async () => {\n  const schedule = await store.createSchedule({\n    name: 'Test',\n    cron: '* * * * *',\n    prompt: 'run',\n    timezone: 'UTC',\n  });\n  const run = await store.createRun(schedule.id, 'manual');\n  expect(run.id).toMatch(/^[0-9A-Z]{26}$/); // ULID pattern\n  expect(run.id).not.toMatch(/-/); // ULIDs have no hyphens, UUIDs do\n});\n```\n\n3. Add anti-regression test:\n```typescript\nit('does not use crypto.randomUUID', async () => {\n  const spy = vi.spyOn(crypto, 'randomUUID');\n  await store.createSchedule({\n    name: 'Test',\n    cron: '* * * * *',\n    prompt: 'run',\n    timezone: 'UTC',\n  });\n  expect(spy).not.toHaveBeenCalled();\n  spy.mockRestore();\n});\n```\n\n4. Add timestamp format test:\n```typescript\nit('timestamps are ISO 8601 strings', async () => {\n  const schedule = await store.createSchedule({\n    name: 'Test',\n    cron: '* * * * *',\n    prompt: 'run',\n    timezone: 'UTC',\n  });\n  expect(schedule.createdAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T/);\n  expect(schedule.updatedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T/);\n});\n```\n\n5. Run `pnpm vitest run apps/server/src/services/pulse/__tests__/pulse-store.test.ts` and verify all tests pass.\n\n6. Also verify scheduler-service tests still pass: `pnpm vitest run apps/server/src/services/pulse/__tests__/scheduler-service.test.ts`\n\n## Acceptance Criteria\n- All Pulse tests use `createTestDb()` from `@dorkos/test-utils`\n- No tmpdir file creation or cleanup in Pulse tests\n- Anti-regression test for ULID (no crypto.randomUUID) passes\n- Anti-regression test for ISO 8601 timestamps passes\n- All existing Pulse test scenarios continue to pass\n- `pnpm test -- --run` passes for server tests",
      "activeForm": "Updating Pulse tests to use createTestDb",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.2", "1.4"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Migrate Relay",
      "subject": "[db-drizzle-consolidation] [P3] Rewrite SqliteIndex to use Drizzle ORM",
      "description": "Replace SqliteIndex's 13 hand-written prepared statements with Drizzle query builders, mapping status values from Maildir terms to semantic terms.\n\n## Steps\n\n1. Add `@dorkos/db: workspace:*` to `packages/relay/package.json` dependencies.\n\n2. Modify `packages/relay/src/sqlite-index.ts`:\n\n**Remove these imports:**\n```typescript\nimport Database from 'better-sqlite3';\n```\n\n**Add these imports:**\n```typescript\nimport { eq, and, gt, asc, sql, count } from 'drizzle-orm';\nimport { relayIndex, type Db } from '@dorkos/db';\n```\n\n**Change status type:**\n```typescript\n// Old:\nexport type MessageStatus = 'new' | 'cur' | 'failed';\n// New:\nexport type MessageStatus = 'pending' | 'delivered' | 'failed';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(options: SqliteIndexOptions) {\n  this.db = new Database(options.dbPath);\n  // PRAGMA user_version migration chain\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n3. Replace key prepared statements with Drizzle queries:\n\n**indexMessage (insert):**\n```typescript\nindexMessage(msg: { id: string; subject: string; endpointHash: string; expiresAt?: string; payload?: string; metadata?: string }): void {\n  this.db.insert(relayIndex).values({\n    id: msg.id,\n    subject: msg.subject,\n    endpointHash: msg.endpointHash,\n    status: 'pending',\n    expiresAt: msg.expiresAt ?? null,\n    payload: msg.payload ?? null,\n    metadata: msg.metadata ?? null,\n    createdAt: new Date().toISOString(),\n  }).run();\n}\n```\n\n**markDelivered (update status to 'delivered'):**\n```typescript\nmarkDelivered(id: string): void {\n  this.db.update(relayIndex)\n    .set({ status: 'delivered' })\n    .where(eq(relayIndex.id, id))\n    .run();\n}\n```\n\n**queryMessages with cursor support:**\n```typescript\nqueryMessages(endpointHash: string, options?: { cursor?: string; limit?: number }): IndexedMessage[] {\n  const conditions = [\n    eq(relayIndex.endpointHash, endpointHash),\n    eq(relayIndex.status, 'pending'),\n  ];\n  if (options?.cursor) {\n    conditions.push(gt(relayIndex.id, options.cursor));\n  }\n  const rows = this.db.select()\n    .from(relayIndex)\n    .where(and(...conditions))\n    .orderBy(asc(relayIndex.id))\n    .limit(options?.limit ?? 50)\n    .all();\n  return rows.map(this.mapRow);\n}\n```\n\n**getMetrics():**\n```typescript\ngetMetrics(): RelayMetrics {\n  const [result] = this.db.select({\n    total: count(),\n    pending: count(sql`CASE WHEN status = 'pending' THEN 1 END`),\n    delivered: count(sql`CASE WHEN status = 'delivered' THEN 1 END`),\n    failed: count(sql`CASE WHEN status = 'failed' THEN 1 END`),\n  }).from(relayIndex).all();\n  return {\n    totalMessages: result.total,\n    pendingMessages: result.pending,\n    deliveredMessages: result.delivered,\n    failedMessages: result.failed,\n  };\n}\n```\n\n**rebuild():**\n```typescript\nrebuild(messages: Array<{ id: string; subject: string; endpointHash: string; status: MessageStatus; createdAt: string }>): void {\n  // Delete all existing rows\n  this.db.delete(relayIndex).run();\n  // Re-insert from Maildir scan\n  for (const msg of messages) {\n    this.db.insert(relayIndex).values({\n      id: msg.id,\n      subject: msg.subject,\n      endpointHash: msg.endpointHash,\n      status: msg.status,\n      createdAt: msg.createdAt,\n    }).run();\n  }\n}\n```\n\n4. Update `IndexedMessage` interface to use new status values and `expiresAt` instead of `ttl`:\n```typescript\nexport interface IndexedMessage {\n  id: string;\n  subject: string;\n  endpointHash: string;\n  status: MessageStatus;\n  createdAt: string;\n  expiresAt: string | null;  // was: ttl: number\n}\n```\n\n5. Remove `MessageRow` interface (Drizzle infers types from schema).\n\n6. Remove PRAGMA user_version migration chain.\n\n7. Remove all `this.db.prepare()` calls.\n\n8. Update `RelayCore` constructor in `packages/relay/src/relay-core.ts` to accept `db: Db` instead of creating SqliteIndex from a path. Change:\n```typescript\n// Old: this.index = new SqliteIndex({ dbPath: ... });\n// New: this.index = new SqliteIndex(db);\n```\n\n9. Update `RelayOptions` type to accept `db: Db` instead of or in addition to `dbPath`.\n\n## Acceptance Criteria\n- SqliteIndex constructor accepts `Db` instead of `SqliteIndexOptions`\n- No `better-sqlite3` import in sqlite-index.ts\n- No `PRAGMA user_version` migration chain\n- No prepared statements\n- Status values use 'pending'/'delivered'/'failed' instead of 'new'/'cur'/'failed'\n- `expiresAt` (TEXT ISO 8601) replaces `ttl` (INTEGER)\n- All 13 prepared statements replaced with Drizzle query builders\n- RelayCore passes `db` to SqliteIndex\n- `pnpm typecheck` passes",
      "activeForm": "Rewriting SqliteIndex to use Drizzle ORM",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Migrate Relay",
      "subject": "[db-drizzle-consolidation] [P3] Rewrite TraceStore to use Drizzle ORM",
      "description": "Replace TraceStore's hand-written SQLite statements with Drizzle query builders, converting timestamps from INTEGER Unix ms to ISO 8601 TEXT.\n\n## Steps\n\n1. Modify `apps/server/src/services/relay/trace-store.ts`:\n\n**Remove these imports:**\n```typescript\nimport Database from 'better-sqlite3';\n```\n\n**Add these imports:**\n```typescript\nimport { eq, sql, count, avg } from 'drizzle-orm';\nimport { relayTraces, type Db } from '@dorkos/db';\nimport { ulid } from 'ulidx';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(options: TraceStoreOptions) {\n  this.db = new Database(options.dbPath);\n  // CREATE TABLE IF NOT EXISTS migration\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n2. Replace prepared statements with Drizzle queries:\n\n**insertSpan:**\n```typescript\ninsertSpan(span: { messageId: string; traceId: string; subject: string; metadata?: Record<string, unknown> }): void {\n  this.db.insert(relayTraces).values({\n    id: ulid(),\n    messageId: span.messageId,\n    traceId: span.traceId,\n    subject: span.subject,\n    status: 'sent',\n    sentAt: new Date().toISOString(),  // ISO 8601 TEXT, not Date.now() integer\n    metadata: span.metadata ? JSON.stringify(span.metadata) : null,\n  }).run();\n}\n```\n\n**updateSpan:**\n```typescript\nupdateSpan(messageId: string, update: TraceSpanUpdate): void {\n  this.db.update(relayTraces)\n    .set({\n      status: update.status,\n      deliveredAt: update.deliveredAt ? new Date(update.deliveredAt).toISOString() : undefined,\n      processedAt: update.processedAt ? new Date(update.processedAt).toISOString() : undefined,\n      errorMessage: update.error ?? undefined,\n    })\n    .where(eq(relayTraces.messageId, messageId))\n    .run();\n}\n```\n\n**getTrace (getSpanByMessageId):**\n```typescript\ngetSpanByMessageId(messageId: string): TraceSpan | undefined {\n  const [row] = this.db.select()\n    .from(relayTraces)\n    .where(eq(relayTraces.messageId, messageId))\n    .all();\n  return row ? this.mapTraceRow(row) : undefined;\n}\n```\n\n**getMetrics:**\n```typescript\ngetMetrics(): DeliveryMetrics {\n  const [result] = this.db.select({\n    total: count(),\n    delivered: count(sql`CASE WHEN status = 'delivered' THEN 1 END`),\n    failed: count(sql`CASE WHEN status = 'failed' THEN 1 END`),\n    timeout: count(sql`CASE WHEN status = 'timeout' THEN 1 END`),\n  }).from(relayTraces).all();\n  return {\n    totalTraces: result.total,\n    deliveredCount: result.delivered,\n    failedCount: result.failed,\n    timeoutCount: result.timeout,\n  };\n}\n```\n\n3. Remove `TraceRow` interface (Drizzle infers types).\n\n4. Remove `MIGRATION` constant (CREATE TABLE IF NOT EXISTS SQL).\n\n5. Remove `TraceStoreOptions` interface — constructor now takes `Db` directly.\n\n6. Update `TraceSpanUpdate` interface to use ISO 8601 string timestamps:\n```typescript\nexport interface TraceSpanUpdate {\n  status?: 'sent' | 'delivered' | 'failed' | 'timeout';\n  deliveredAt?: string;  // ISO 8601 (was: number Unix ms)\n  processedAt?: string;  // ISO 8601 (was: number Unix ms)\n  error?: string;\n}\n```\n\n7. Update TraceStore instantiation in `apps/server/src/index.ts`:\n```typescript\n// Old: traceStore = new TraceStore({ dbPath: path.join(relayDataDir, 'index.db') });\n// New: traceStore = new TraceStore(db);\n```\n\n## Acceptance Criteria\n- TraceStore constructor accepts `Db` instead of `TraceStoreOptions`\n- No `better-sqlite3` import in trace-store.ts\n- No `CREATE TABLE IF NOT EXISTS` migration\n- No prepared statements\n- All timestamps stored as ISO 8601 TEXT strings (not INTEGER Unix ms)\n- `sentAt`, `deliveredAt`, `processedAt` are all ISO 8601 strings\n- Metrics use Drizzle aggregate queries\n- Server index.ts passes `db` to TraceStore\n- `pnpm typecheck` passes",
      "activeForm": "Rewriting TraceStore to use Drizzle ORM",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.1"],
      "parallelWith": ["3.1"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Migrate Relay",
      "subject": "[db-drizzle-consolidation] [P3] Update Relay tests and add anti-regression tests",
      "description": "Rewrite Relay tests to use in-memory Drizzle database and add anti-regression tests for timestamp standardization.\n\n## Steps\n\n1. Update `packages/relay/src/__tests__/sqlite-index.test.ts`:\n\n**Replace test setup with:**\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createTestDb } from '@dorkos/test-utils';\nimport type { Db } from '@dorkos/db';\nimport { SqliteIndex } from '../sqlite-index.js';\n\nlet db: Db;\nlet index: SqliteIndex;\n\nbeforeEach(() => {\n  db = createTestDb();\n  index = new SqliteIndex(db);\n});\n```\n\n2. Update all test assertions that reference old status values:\n- `'new'` → `'pending'`\n- `'cur'` → `'delivered'`\n\n3. Update all test assertions that reference `ttl` to use `expiresAt` instead.\n\n4. Add anti-regression tests for TraceStore:\n```typescript\n// In trace-store tests\nimport { createTestDb } from '@dorkos/test-utils';\nimport { TraceStore } from '../trace-store.js';\n\nlet db: Db;\nlet traceStore: TraceStore;\n\nbeforeEach(() => {\n  db = createTestDb();\n  traceStore = new TraceStore(db);\n});\n\nit('sentAt is ISO 8601 string, not number', () => {\n  traceStore.insertSpan({\n    messageId: 'msg1',\n    traceId: 'trace1',\n    subject: 'test.subject',\n  });\n  const trace = traceStore.getSpanByMessageId('msg1');\n  expect(typeof trace?.sentAt).toBe('string');\n  expect(trace?.sentAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T/); // ISO 8601\n});\n\nit('deliveredAt is ISO 8601 string when set', () => {\n  traceStore.insertSpan({\n    messageId: 'msg1',\n    traceId: 'trace1',\n    subject: 'test.subject',\n  });\n  const now = new Date().toISOString();\n  traceStore.updateSpan('msg1', { status: 'delivered', deliveredAt: now });\n  const trace = traceStore.getSpanByMessageId('msg1');\n  expect(typeof trace?.deliveredAt).toBe('string');\n  expect(trace?.deliveredAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T/);\n});\n```\n\n5. Add anti-regression test for relay_index status values:\n```typescript\nit('uses semantic status values, not Maildir terms', () => {\n  index.indexMessage({\n    id: 'msg1',\n    subject: 'test.subject',\n    endpointHash: 'hash1',\n  });\n  const messages = index.queryMessages('hash1');\n  expect(messages[0].status).toBe('pending');\n  // Verify 'new' is never used\n  expect(messages[0].status).not.toBe('new');\n\n  index.markDelivered('msg1');\n  // Query all statuses to verify delivered\n  const allMessages = index.queryMessages('hash1', { includeDelivered: true });\n  // The delivered message should have 'delivered' status, not 'cur'\n});\n```\n\n6. Run all relay tests: `pnpm vitest run packages/relay/src/__tests__/`\n\n7. Run trace-store tests if they exist at `apps/server/src/services/relay/__tests__/`.\n\n## Acceptance Criteria\n- All Relay tests use `createTestDb()` from `@dorkos/test-utils`\n- No tmpdir file creation or cleanup in Relay tests\n- No references to old status values ('new', 'cur') in test assertions\n- No references to `ttl` column in test assertions\n- Anti-regression test for ISO 8601 timestamps in relay_traces passes\n- Anti-regression test for semantic status values in relay_index passes\n- All existing Relay test scenarios continue to pass\n- `pnpm test -- --run` passes for relay tests",
      "activeForm": "Updating Relay tests and adding anti-regression tests",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1", "3.2", "1.4"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Migrate Mesh",
      "subject": "[db-drizzle-consolidation] [P4] Extract computeHealthStatus to portable TypeScript helper",
      "description": "Move the agent health computation from `julianday()` SQL to a portable TypeScript function, eliminating the SQLite-specific dependency.\n\n## Steps\n\n1. Create or update a health utility file. The function can live in `packages/mesh/src/health.ts` or be added to `agent-registry.ts`.\n\nCreate `packages/mesh/src/health.ts`:\n```typescript\n/**\n * Compute agent health status from last_seen_at timestamp.\n *\n * Replaces the SQLite julianday()-based computation that was\n * not portable to other SQL dialects. Uses TypeScript Date math.\n *\n * @param lastSeenAt - ISO 8601 timestamp of last agent heartbeat, or null\n * @returns Health status: 'active' (< 5min), 'inactive' (5-30min), 'stale' (> 30min or null)\n */\nexport function computeHealthStatus(\n  lastSeenAt: string | null,\n): 'active' | 'inactive' | 'stale' {\n  if (!lastSeenAt) return 'stale';\n  const diffMs = Date.now() - new Date(lastSeenAt).getTime();\n  const diffMinutes = diffMs / 60_000;\n  if (diffMinutes < 5) return 'active';\n  if (diffMinutes < 30) return 'inactive';\n  return 'stale';\n}\n```\n\n2. Export from `packages/mesh/src/index.ts`:\n```typescript\nexport { computeHealthStatus } from './health.js';\n```\n\n3. Write tests in `packages/mesh/src/__tests__/health.test.ts`:\n```typescript\nimport { describe, it, expect, vi, afterEach } from 'vitest';\nimport { computeHealthStatus } from '../health.js';\n\ndescribe('computeHealthStatus', () => {\n  afterEach(() => {\n    vi.useRealTimers();\n  });\n\n  it('returns \"stale\" when lastSeenAt is null', () => {\n    expect(computeHealthStatus(null)).toBe('stale');\n  });\n\n  it('returns \"active\" when last seen < 5 minutes ago', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T12:04:00Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('active');\n  });\n\n  it('returns \"inactive\" when last seen 5-30 minutes ago', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T12:15:00Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('inactive');\n  });\n\n  it('returns \"stale\" when last seen > 30 minutes ago', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T13:00:00Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('stale');\n  });\n\n  it('returns \"active\" at exactly the boundary (< 5 min)', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T12:04:59.999Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('active');\n  });\n\n  it('returns \"inactive\" at exactly 5 minutes', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T12:05:00Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('inactive');\n  });\n\n  it('returns \"stale\" at exactly 30 minutes', () => {\n    vi.useFakeTimers();\n    vi.setSystemTime(new Date('2026-01-01T12:30:00Z'));\n    expect(computeHealthStatus('2026-01-01T12:00:00Z')).toBe('stale');\n  });\n});\n```\n\n4. Run `pnpm vitest run packages/mesh/src/__tests__/health.test.ts` to verify all tests pass.\n\n## Acceptance Criteria\n- `computeHealthStatus()` is a pure TypeScript function with no SQL dependencies\n- No `julianday()` or SQLite-specific functions used anywhere\n- Function returns 'active' for < 5 min, 'inactive' for 5-30 min, 'stale' for > 30 min or null\n- All boundary conditions are tested\n- Function is exported from `packages/mesh/src/index.ts`\n- All tests pass",
      "activeForm": "Extracting computeHealthStatus to portable TypeScript helper",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["3.1", "3.2", "2.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Migrate Mesh",
      "subject": "[db-drizzle-consolidation] [P4] Rewrite AgentRegistry to use Drizzle ORM",
      "description": "Replace AgentRegistry's 11 prepared statements with Drizzle query builders, remove the 4-version PRAGMA user_version migration chain, drop `manifest_json`, and remove the `.database` getter.\n\n## Steps\n\n1. Add `@dorkos/db: workspace:*` to `packages/mesh/package.json` dependencies.\n\n2. Modify `packages/mesh/src/agent-registry.ts`:\n\n**Remove these imports:**\n```typescript\nimport Database from 'better-sqlite3';\n```\n\n**Add these imports:**\n```typescript\nimport { eq, and, like, sql } from 'drizzle-orm';\nimport { agents, type Db } from '@dorkos/db';\nimport { ulid } from 'ulidx';\nimport { computeHealthStatus } from './health.js';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(dbPath: string) {\n  this.db = new Database(dbPath);\n  // PRAGMA user_version 4-step migration chain\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n3. Remove the `get database()` getter that exposed the raw `better-sqlite3` Database instance. DenialList and BudgetMapper will receive `Db` directly from MeshCore (task 4.3).\n\n4. Remove `manifest_json` from all INSERT and SELECT statements — the individual structured columns contain all the same data.\n\n5. Replace key prepared statements:\n\n**register():**\n```typescript\nregister(manifest: AgentManifest, opts: { registrar?: string; namespace?: string; scanRoot?: string }): string {\n  const id = ulid();\n  const now = new Date().toISOString();\n  this.db.insert(agents).values({\n    id,\n    name: manifest.name,\n    runtime: manifest.runtime,\n    projectPath: manifest.projectPath,\n    namespace: opts.namespace ?? 'default',\n    capabilities: JSON.stringify(manifest.capabilities ?? []),\n    entrypoint: manifest.entrypoint ?? null,\n    version: manifest.version ?? null,\n    description: manifest.description ?? null,\n    approver: opts.registrar ?? null,\n    status: 'active',\n    registeredAt: now,\n    updatedAt: now,\n  }).run();\n  return id;\n}\n```\n\n**list() with health computed in TypeScript:**\n```typescript\nlist(filters?: AgentListFilters): Array<AgentRegistryEntry & { healthStatus: string }> {\n  let query = this.db.select().from(agents);\n  const conditions = [];\n  if (filters?.runtime) conditions.push(eq(agents.runtime, filters.runtime));\n  if (conditions.length > 0) query = query.where(and(...conditions));\n  const rows = query.all();\n  return rows\n    .filter(row => {\n      if (filters?.capability) {\n        const caps = JSON.parse(row.capabilities) as string[];\n        return caps.includes(filters.capability);\n      }\n      return true;\n    })\n    .map(row => ({\n      ...this.mapRow(row),\n      healthStatus: computeHealthStatus(row.lastSeenAt),\n    }));\n}\n```\n\n**getById():**\n```typescript\ngetById(id: string): AgentRegistryEntry | undefined {\n  const [row] = this.db.select().from(agents).where(eq(agents.id, id)).all();\n  return row ? this.mapRow(row) : undefined;\n}\n```\n\n**getByPath():**\n```typescript\ngetByPath(projectPath: string): AgentRegistryEntry | undefined {\n  const [row] = this.db.select().from(agents).where(eq(agents.projectPath, projectPath)).all();\n  return row ? this.mapRow(row) : undefined;\n}\n```\n\n**updateLastSeen():**\n```typescript\nupdateLastSeen(id: string, event?: string): void {\n  this.db.update(agents)\n    .set({\n      lastSeenAt: new Date().toISOString(),\n      lastSeenEvent: event ?? null,\n      updatedAt: new Date().toISOString(),\n    })\n    .where(eq(agents.id, id))\n    .run();\n}\n```\n\n**unregister():**\n```typescript\nunregister(id: string): boolean {\n  const result = this.db.delete(agents).where(eq(agents.id, id)).run();\n  return result.changes > 0;\n}\n```\n\n6. Remove `AgentRow` and `AgentHealthRow` interfaces (Drizzle infers types).\n\n7. Add private `mapRow()` helper that converts Drizzle result to `AgentRegistryEntry`:\n```typescript\nprivate mapRow(row: typeof agents.$inferSelect): AgentRegistryEntry {\n  return {\n    id: row.id,\n    name: row.name,\n    runtime: row.runtime as AgentRuntime,\n    projectPath: row.projectPath,\n    namespace: row.namespace,\n    capabilities: JSON.parse(row.capabilities) as string[],\n    entrypoint: row.entrypoint ?? undefined,\n    version: row.version ?? undefined,\n    description: row.description ?? undefined,\n    registeredAt: row.registeredAt,\n    updatedAt: row.updatedAt,\n    // scanRoot is not in the DB schema, derive from namespace or omit\n    scanRoot: '',\n  };\n}\n```\n\n8. Remove the entire 4-version PRAGMA user_version migration chain.\n\n## Acceptance Criteria\n- AgentRegistry constructor accepts `Db` instead of `dbPath: string`\n- No `better-sqlite3` import in agent-registry.ts\n- No `PRAGMA user_version` migration chain\n- No `manifest_json` column usage (dropped from schema)\n- No `.database` getter\n- No `julianday()` SQL — health uses `computeHealthStatus()` from TypeScript\n- All 11 prepared statements replaced with Drizzle query builders\n- `pnpm typecheck` passes",
      "activeForm": "Rewriting AgentRegistry to use Drizzle ORM",
      "size": "large",
      "priority": "high",
      "dependencies": ["4.1", "2.1"],
      "parallelWith": []
    },
    {
      "id": "4.3",
      "phase": 4,
      "phaseName": "Migrate Mesh",
      "subject": "[db-drizzle-consolidation] [P4] Rewrite DenialList and BudgetMapper to use Drizzle ORM",
      "description": "Replace DenialList and BudgetMapper's raw SQLite usage with Drizzle query builders. Both now receive `Db` directly from MeshCore instead of getting the raw database via AgentRegistry's `.database` getter.\n\n## Steps\n\n### DenialList\n\n1. Modify `packages/mesh/src/denial-list.ts`:\n\n**Remove imports:**\n```typescript\nimport Database from 'better-sqlite3';\n```\n\n**Add imports:**\n```typescript\nimport { eq } from 'drizzle-orm';\nimport { agentDenials, type Db } from '@dorkos/db';\nimport { ulid } from 'ulidx';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(private database: Database.Database) {\n  // CREATE TABLE IF NOT EXISTS migration\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n**Replace prepared statements:**\n```typescript\nadd(filePath: string, opts?: { reason?: string; denier?: string }): void {\n  const canonicalPath = realpathSync(filePath);\n  this.db.insert(agentDenials)\n    .values({\n      id: ulid(),\n      path: canonicalPath,\n      reason: opts?.reason ?? null,\n      denier: opts?.denier ?? null,\n      createdAt: new Date().toISOString(),\n    })\n    .onConflictDoNothing()\n    .run();\n}\n\nisDenied(filePath: string): boolean {\n  const canonicalPath = realpathSync(filePath);\n  const [row] = this.db.select()\n    .from(agentDenials)\n    .where(eq(agentDenials.path, canonicalPath))\n    .limit(1)\n    .all();\n  return row !== undefined;\n}\n\nlist(): DenialRecord[] {\n  return this.db.select().from(agentDenials).all().map(row => ({\n    path: row.path,\n    reason: row.reason ?? undefined,\n    denier: row.denier ?? undefined,\n    createdAt: row.createdAt,\n  }));\n}\n\nremove(filePath: string): boolean {\n  const canonicalPath = realpathSync(filePath);\n  const result = this.db.delete(agentDenials)\n    .where(eq(agentDenials.path, canonicalPath))\n    .run();\n  return result.changes > 0;\n}\n```\n\n2. Remove `DenialRow` interface and `DENIAL_MIGRATION` constant.\n\n### BudgetMapper\n\n3. Modify `packages/mesh/src/budget-mapper.ts`:\n\n**Remove imports:**\n```typescript\nimport type Database from 'better-sqlite3';\n```\n\n**Add imports:**\n```typescript\nimport { eq, and, gte, sql, sum } from 'drizzle-orm';\nimport { rateLimitBuckets, type Db } from '@dorkos/db';\n```\n\n**Change constructor from:**\n```typescript\nconstructor(private database: Database.Database) {\n  // CREATE TABLE IF NOT EXISTS migration\n}\n```\n\n**To:**\n```typescript\nconstructor(private db: Db) {}\n```\n\n**Replace prepared statements:**\n```typescript\nincrement(agentId: string): void {\n  const minute = Math.floor(Date.now() / 60_000);\n  this.db.insert(rateLimitBuckets)\n    .values({ agentId, bucketMinute: minute, count: 1 })\n    .onConflictDoUpdate({\n      target: [rateLimitBuckets.agentId, rateLimitBuckets.bucketMinute],\n      set: { count: sql`${rateLimitBuckets.count} + 1` },\n    })\n    .run();\n}\n\ngetWindowCount(agentId: string, windowMinutes: number = BUCKETS_PER_HOUR): number {\n  const cutoff = Math.floor(Date.now() / 60_000) - windowMinutes;\n  const [result] = this.db.select({ total: sum(rateLimitBuckets.count) })\n    .from(rateLimitBuckets)\n    .where(\n      and(\n        eq(rateLimitBuckets.agentId, agentId),\n        gte(rateLimitBuckets.bucketMinute, cutoff),\n      ),\n    )\n    .all();\n  return Number(result?.total ?? 0);\n}\n\nprune(): void {\n  const cutoff = Math.floor(Date.now() / 60_000) - PRUNE_AGE_MINUTES;\n  this.db.delete(rateLimitBuckets)\n    .where(sql`${rateLimitBuckets.bucketMinute} < ${cutoff}`)\n    .run();\n}\n```\n\n### MeshCore Wiring\n\n4. Update `packages/mesh/src/mesh-core.ts` to accept `db: Db` and pass it to AgentRegistry, DenialList, and BudgetMapper:\n\n**Update MeshOptions:**\n```typescript\nexport interface MeshOptions {\n  db: Db;  // was: dataDir?: string\n  // ... other options remain\n}\n```\n\n**Update constructor:**\n```typescript\nconstructor(options: MeshOptions) {\n  this.registry = new AgentRegistry(options.db);\n  this.denials = new DenialList(options.db);\n  this.budgetMapper = new BudgetMapper(options.db);\n  // ... rest of initialization\n}\n```\n\n5. Update server index.ts MeshCore instantiation:\n```typescript\n// Old: meshCore = new MeshCore({ dataDir: path.join(dorkHome, 'mesh'), ... });\n// New: meshCore = new MeshCore({ db, ... });\n```\n\n## Acceptance Criteria\n- DenialList constructor accepts `Db` instead of `Database.Database`\n- BudgetMapper constructor accepts `Db` instead of `Database.Database`\n- No `better-sqlite3` imports in denial-list.ts or budget-mapper.ts\n- No `CREATE TABLE IF NOT EXISTS` migrations in either file\n- No prepared statements in either file\n- BudgetMapper upsert uses `onConflictDoUpdate` with `sql` template\n- MeshCore accepts `db: Db` in options and passes it to all sub-components\n- DenialList uses `realpathSync` for path canonicalization (unchanged behavior)\n- `pnpm typecheck` passes",
      "activeForm": "Rewriting DenialList and BudgetMapper to use Drizzle ORM",
      "size": "medium",
      "priority": "high",
      "dependencies": ["4.2"],
      "parallelWith": []
    },
    {
      "id": "4.4",
      "phase": 4,
      "phaseName": "Migrate Mesh",
      "subject": "[db-drizzle-consolidation] [P4] Update Mesh tests and add anti-regression tests",
      "description": "Rewrite Mesh tests to use in-memory Drizzle database and add anti-regression tests for health computation and manifest_json removal.\n\n## Steps\n\n1. Update `packages/mesh/src/__tests__/agent-registry.test.ts`:\n\n**Replace test setup with:**\n```typescript\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { createTestDb } from '@dorkos/test-utils';\nimport type { Db } from '@dorkos/db';\nimport { AgentRegistry } from '../agent-registry.js';\n\nlet db: Db;\nlet registry: AgentRegistry;\n\nbeforeEach(() => {\n  db = createTestDb();\n  registry = new AgentRegistry(db);\n});\n```\n\n2. Remove all raw `better-sqlite3` Database assertions (e.g., checking `agent.manifest_json` directly on the row).\n\n3. Add anti-regression tests:\n\n```typescript\nit('agent health uses TypeScript computation, not julianday SQL', () => {\n  vi.useFakeTimers();\n  const baseTime = new Date('2026-01-01T12:00:00Z');\n  vi.setSystemTime(baseTime);\n\n  const id = registry.register(\n    { name: 'test-agent', runtime: 'claude-code', projectPath: '/tmp/test', capabilities: [] },\n    { namespace: 'default' },\n  );\n  registry.updateLastSeen(id);\n\n  // Advance time by 3 minutes — should be 'active'\n  vi.setSystemTime(new Date('2026-01-01T12:03:00Z'));\n  const agents = registry.list();\n  const agent = agents.find(a => a.id === id);\n  expect(agent?.healthStatus).toBe('active');\n\n  // Advance time by 15 minutes — should be 'inactive'\n  vi.setSystemTime(new Date('2026-01-01T12:15:00Z'));\n  const agents2 = registry.list();\n  const agent2 = agents2.find(a => a.id === id);\n  expect(agent2?.healthStatus).toBe('inactive');\n\n  // Advance time by 45 minutes — should be 'stale'\n  vi.setSystemTime(new Date('2026-01-01T12:45:00Z'));\n  const agents3 = registry.list();\n  const agent3 = agents3.find(a => a.id === id);\n  expect(agent3?.healthStatus).toBe('stale');\n\n  vi.useRealTimers();\n});\n\nit('does not store manifest_json column', () => {\n  const id = registry.register(\n    { name: 'test-agent', runtime: 'claude-code', projectPath: '/tmp/test', capabilities: ['code'] },\n    { namespace: 'default' },\n  );\n  // Verify the raw row does not have manifest_json\n  const rawRow = db.$client.prepare('SELECT * FROM agents WHERE id = ?').get(id) as Record<string, unknown>;\n  expect(rawRow).not.toHaveProperty('manifest_json');\n});\n```\n\n4. Update DenialList tests similarly:\n```typescript\nimport { createTestDb } from '@dorkos/test-utils';\nimport { DenialList } from '../denial-list.js';\n\nlet db: Db;\nlet denials: DenialList;\n\nbeforeEach(() => {\n  db = createTestDb();\n  denials = new DenialList(db);\n});\n```\n\n5. Update BudgetMapper tests:\n```typescript\nimport { createTestDb } from '@dorkos/test-utils';\nimport { BudgetMapper } from '../budget-mapper.js';\n\nlet db: Db;\nlet mapper: BudgetMapper;\n\nbeforeEach(() => {\n  db = createTestDb();\n  mapper = new BudgetMapper(db);\n});\n```\n\n6. Run all mesh tests: `pnpm vitest run packages/mesh/src/__tests__/`\n\n## Acceptance Criteria\n- All Mesh tests use `createTestDb()` from `@dorkos/test-utils`\n- No tmpdir file creation or raw Database assertions\n- Anti-regression test confirms health uses TypeScript computation (not julianday)\n- Anti-regression test confirms manifest_json column does not exist\n- DenialList and BudgetMapper tests use Drizzle DB\n- All existing Mesh test scenarios continue to pass\n- `pnpm test -- --run` passes for mesh tests",
      "activeForm": "Updating Mesh tests and adding anti-regression tests",
      "size": "medium",
      "priority": "high",
      "dependencies": ["4.3", "1.4"],
      "parallelWith": []
    },
    {
      "id": "5.1",
      "phase": 5,
      "phaseName": "CLI Bundle and Cleanup",
      "subject": "[db-drizzle-consolidation] [P5] Add Drizzle migration copy step to CLI build script",
      "description": "Modify the CLI build script to copy Drizzle migration SQL files alongside the bundled server, so `runMigrations()` can find them at runtime in the published CLI package.\n\n## Steps\n\n1. Edit `packages/cli/scripts/build.ts`.\n\n2. Add `cpSync` import at the top (if not already imported):\n```typescript\nimport { cpSync } from 'fs';\n```\n\n3. After Step 2 (server bundle) and before Step 3 (CLI entry), add:\n```typescript\n// Step 2.5: Copy Drizzle migration SQL files alongside bundled server\nconsole.log('[2.5/3] Copying Drizzle migrations...');\ncpSync(\n  path.join(ROOT, 'packages/db/drizzle'),\n  path.join(OUT, 'drizzle'),\n  { recursive: true }\n);\n```\n\n4. Update the esbuild externals list in Step 2 to include `@dorkos/db` if it's not being inlined. Since `@dorkos/db` uses JIT `.ts` exports (like `@dorkos/shared`), esbuild should inline it. Verify that the schema and factory functions are bundled into the server output.\n\n5. Verify the path resolution chain:\n- In `packages/db/src/index.ts`, `runMigrations()` uses `path.join(__dirname, '../../drizzle')`\n- In the CLI bundle, `__dirname` resolves to the directory containing the bundled file\n- If server is bundled to `dist/server/index.js`, then `../../drizzle` resolves to `dist/drizzle/` — matching the copy destination\n- If the path doesn't match, adjust the copy destination or the migration path resolution\n\n6. Build the CLI: `pnpm --filter=dorkos run build`\n\n7. Verify the output structure:\n```\npackages/cli/dist/\n├── bin/cli.js\n├── server/index.js\n├── client/\n└── drizzle/          # <-- migration SQL files\n    ├── meta/\n    │   └── _journal.json\n    └── 0000_initial.sql\n```\n\n8. Test the CLI locally:\n```bash\nnode packages/cli/dist/bin/cli.js\n```\nVerify `~/.dork/dork.db` is created and the log shows migration applied.\n\n## Acceptance Criteria\n- CLI build script copies `packages/db/drizzle/` to `dist/drizzle/`\n- `pnpm --filter=dorkos run build` succeeds\n- `dist/drizzle/0000_initial.sql` exists in the build output\n- `dist/drizzle/meta/_journal.json` exists in the build output\n- CLI starts and creates `~/.dork/dork.db` on first run\n- Migration log message appears in CLI output",
      "activeForm": "Adding Drizzle migration copy step to CLI build script",
      "size": "small",
      "priority": "high",
      "dependencies": ["2.2", "3.1", "3.2", "4.3"],
      "parallelWith": ["5.2"]
    },
    {
      "id": "5.2",
      "phase": 5,
      "phaseName": "CLI Bundle and Cleanup",
      "subject": "[db-drizzle-consolidation] [P5] Clean up dependency tree — remove old better-sqlite3 from relay and mesh",
      "description": "Remove the now-redundant `better-sqlite3` and `@types/better-sqlite3` dependencies from packages that previously had their own SQLite connections. Add `@dorkos/db` workspace dependency where not yet added.\n\n## Steps\n\n1. Edit `packages/relay/package.json`:\n- Remove `better-sqlite3` from dependencies\n- Remove `@types/better-sqlite3` from devDependencies\n- Add `@dorkos/db: workspace:*` to dependencies (if not already added in task 3.1)\n\n2. Edit `packages/mesh/package.json`:\n- Remove `better-sqlite3` from dependencies\n- Remove `@types/better-sqlite3` from devDependencies\n- Add `@dorkos/db: workspace:*` to dependencies (if not already added in task 4.2)\n\n3. Verify `@dorkos/db: workspace:*` is in:\n- `apps/server/package.json` (added in task 2.1)\n- `packages/relay/package.json` (this task)\n- `packages/mesh/package.json` (this task)\n- `packages/test-utils/package.json` (added in task 1.4)\n\n4. Verify `drizzle-orm: ^0.39.0` is in root `package.json` (added in task 1.1).\n\n5. Run `pnpm install` to update lockfile.\n\n6. Run `pnpm typecheck` to verify no import errors.\n\n7. Search for any remaining `import Database from 'better-sqlite3'` in relay and mesh packages:\n```bash\ngrep -r \"from 'better-sqlite3'\" packages/relay/src/ packages/mesh/src/\n```\nThis should return zero matches.\n\n8. Search for any remaining `PRAGMA user_version` in the codebase:\n```bash\ngrep -r \"user_version\" packages/relay/src/ packages/mesh/src/ apps/server/src/services/pulse/\n```\nThis should return zero matches.\n\n## Acceptance Criteria\n- `better-sqlite3` is NOT in `packages/relay/package.json` dependencies\n- `@types/better-sqlite3` is NOT in `packages/relay/package.json` devDependencies\n- `better-sqlite3` is NOT in `packages/mesh/package.json` dependencies\n- `@types/better-sqlite3` is NOT in `packages/mesh/package.json` devDependencies\n- `@dorkos/db` is in dependencies of: server, relay, mesh, test-utils\n- `drizzle-orm` is in root package.json dependencies\n- `pnpm install` succeeds\n- `pnpm typecheck` passes\n- No `import Database from 'better-sqlite3'` in relay or mesh source\n- No `PRAGMA user_version` in relay, mesh, or pulse source",
      "activeForm": "Cleaning up dependency tree",
      "size": "small",
      "priority": "high",
      "dependencies": ["3.1", "3.2", "4.3"],
      "parallelWith": ["5.1"]
    },
    {
      "id": "5.3",
      "phase": 5,
      "phaseName": "CLI Bundle and Cleanup",
      "subject": "[db-drizzle-consolidation] [P5] Run full test suite and verify end-to-end",
      "description": "Run the complete test suite and verify the entire system works end-to-end after the database consolidation.\n\n## Steps\n\n1. Run the full test suite:\n```bash\npnpm test -- --run\n```\nAll tests must pass. Fix any failures before proceeding.\n\n2. Run type checking:\n```bash\npnpm typecheck\n```\nMust pass with zero errors.\n\n3. Run linting:\n```bash\npnpm lint\n```\nMust pass (warnings are acceptable, errors are not).\n\n4. Build all apps:\n```bash\npnpm build\n```\nMust succeed for client, server, web, and obsidian-plugin.\n\n5. Build CLI package:\n```bash\npnpm --filter=dorkos run build\n```\nMust succeed and produce `dist/drizzle/` alongside the bundled server.\n\n6. Start the dev server and verify:\n```bash\ndotenv -- turbo dev --filter=@dorkos/server\n```\nCheck logs for:\n- `[db] Migrations applied to ~/.dork/dork.db`\n- `[db] Legacy databases preserved at previous paths`\n- No errors related to database access\n\n7. Verify Pulse works (if enabled):\n- Create a schedule via API: `POST /api/pulse/schedules`\n- List schedules: `GET /api/pulse/schedules`\n- Trigger a run: `POST /api/pulse/schedules/:id/trigger`\n- List runs: `GET /api/pulse/runs`\n\n8. Verify Relay works (if enabled):\n- List endpoints: `GET /api/relay/endpoints`\n- Send a message: `POST /api/relay/messages`\n- Check metrics: `GET /api/relay/metrics`\n\n9. Verify Mesh works (if enabled):\n- List agents: `GET /api/mesh/agents`\n- Check status: `GET /api/mesh/status`\n- Discover agents: `POST /api/mesh/discover`\n\n10. Verify `~/.dork/dork.db` is the only database being written to. The old files (`pulse.db`, `relay/index.db`, `mesh/mesh.db`) should exist but not be opened.\n\n11. Verify no references to old database paths in startup code:\n```bash\ngrep -r \"pulse\\.db\" apps/server/src/\ngrep -r \"index\\.db\" apps/server/src/services/relay/\ngrep -r \"mesh\\.db\" apps/server/src/ packages/mesh/src/\n```\nThese should return zero matches (except possibly comments about legacy files).\n\n## Acceptance Criteria\n- `pnpm test -- --run` passes all tests\n- `pnpm typecheck` passes with zero errors\n- `pnpm lint` passes (no errors)\n- `pnpm build` succeeds for all apps\n- `pnpm --filter=dorkos run build` succeeds with drizzle migrations in output\n- Dev server starts and creates `~/.dork/dork.db`\n- Pulse, Relay, and Mesh routes all function correctly\n- No references to old database file paths in production code\n- Old database files are preserved on disk but not accessed",
      "activeForm": "Running full test suite and verifying end-to-end",
      "size": "medium",
      "priority": "high",
      "dependencies": ["5.1", "5.2", "2.3", "3.3", "4.4"],
      "parallelWith": []
    }
  ]
}
