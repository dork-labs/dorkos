{
  "spec": "specs/mesh-network-topology/02-specification.md",
  "slug": "mesh-network-topology",
  "generatedAt": "2026-02-25T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Create namespace-resolver module with derivation and validation",
      "description": "Create a new module at `packages/mesh/src/namespace-resolver.ts` with three pure functions for namespace derivation, normalization, and validation. No side effects.\n\n**File: `packages/mesh/src/namespace-resolver.ts`**\n\n```typescript\nimport path from 'path';\n\n/** Maximum allowed namespace length. */\nconst MAX_NAMESPACE_LENGTH = 64;\n\n/**\n * Normalize a raw namespace string: lowercase, replace non-alphanumeric with hyphens, trim hyphens.\n *\n * @param raw - The raw namespace string to normalize\n * @returns Normalized namespace string\n */\nexport function normalizeNamespace(raw: string): string {\n  return raw\n    .toLowerCase()\n    .replace(/[^a-z0-9-]/g, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '');\n}\n\n/**\n * Validate a namespace string. Must be non-empty and max 64 chars.\n *\n * @param ns - The namespace to validate\n * @returns Validation result with reason on failure\n */\nexport function validateNamespace(ns: string): { valid: true } | { valid: false; reason: string } {\n  if (!ns || ns.length === 0) {\n    return { valid: false, reason: 'Namespace must not be empty' };\n  }\n  if (ns.length > MAX_NAMESPACE_LENGTH) {\n    return { valid: false, reason: `Namespace must be at most ${MAX_NAMESPACE_LENGTH} characters (got ${ns.length})` };\n  }\n  return { valid: true };\n}\n\n/**\n * Resolve a namespace for an agent from its project path and scan root.\n *\n * Algorithm:\n * 1. If `manifestNamespace` is provided and non-empty, use it\n * 2. Otherwise, compute `path.relative(scanRoot, projectPath)` and take the first path segment\n * 3. Normalize: lowercase, replace non-alphanumeric with hyphens, trim hyphens\n * 4. Validate: non-empty, max 64 chars\n *\n * @param projectPath - Absolute path to the agent's project directory\n * @param scanRoot - The root directory that was scanned\n * @param manifestNamespace - Optional namespace override from the agent manifest\n * @returns The resolved namespace string\n * @throws If the derived namespace is invalid (empty after normalization)\n */\nexport function resolveNamespace(\n  projectPath: string,\n  scanRoot: string,\n  manifestNamespace?: string,\n): string {\n  if (manifestNamespace && manifestNamespace.trim().length > 0) {\n    const normalized = normalizeNamespace(manifestNamespace);\n    const validation = validateNamespace(normalized);\n    if (!validation.valid) {\n      throw new Error(`Invalid manifest namespace: ${validation.reason}`);\n    }\n    return normalized;\n  }\n\n  const relative = path.relative(scanRoot, projectPath);\n  const firstSegment = relative.split(path.sep)[0];\n  if (!firstSegment) {\n    throw new Error(`Cannot derive namespace: projectPath '${projectPath}' is at or above scanRoot '${scanRoot}'`);\n  }\n\n  const normalized = normalizeNamespace(firstSegment);\n  const validation = validateNamespace(normalized);\n  if (!validation.valid) {\n    throw new Error(`Invalid derived namespace '${normalized}': ${validation.reason}`);\n  }\n  return normalized;\n}\n```\n\n**Export from `packages/mesh/src/index.ts`:**\nAdd these lines to the existing barrel exports:\n```typescript\nexport { resolveNamespace, normalizeNamespace, validateNamespace } from './namespace-resolver.js';\n```\n\n**Tests: `packages/mesh/src/__tests__/namespace-resolver.test.ts`**\n\nWrite unit tests covering:\n- `resolveNamespace('~/projects/dorkos/core', '~/projects')` returns `'dorkos'`\n- `resolveNamespace('~/projects/team-a/backend', '~/projects')` returns `'team-a'`\n- `resolveNamespace('~/work/my-agent', '~/work')` returns `'my-agent'`\n- `resolveNamespace(any, any, 'custom-ns')` returns `'custom-ns'` (manifest override)\n- `resolveNamespace(any, any, 'Custom NS!')` returns `'custom-ns'` (manifest override normalized)\n- `normalizeNamespace('Hello World!')` returns `'hello-world'`\n- `normalizeNamespace('---foo---')` returns `'foo'`\n- `normalizeNamespace('FOO_BAR.baz')` returns `'foo-bar-baz'`\n- `validateNamespace('')` returns `{ valid: false, reason: ... }`\n- `validateNamespace('a'.repeat(65))` returns `{ valid: false, reason: ... }`\n- `validateNamespace('valid-ns')` returns `{ valid: true }`\n- Throws when projectPath is at or above scanRoot\n- Handles trailing slashes on paths\n- Handles deeply nested paths (takes only first segment)\n\nAcceptance criteria:\n- All three functions exported from `namespace-resolver.ts`\n- All functions are pure (no side effects, no I/O)\n- All tests pass with `npx vitest run packages/mesh/src/__tests__/namespace-resolver.test.ts`\n- Exported from `packages/mesh/src/index.ts`",
      "activeForm": "Creating namespace resolver module",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Add namespace and scan_root columns to agent registry",
      "description": "Migrate the agent registry SQLite schema to add `namespace` and `scan_root` columns. Update all insert/query methods and types to support the new fields.\n\n**File: `packages/mesh/src/agent-registry.ts`**\n\n1. **Update `AgentRegistryEntry` interface:**\n```typescript\nexport interface AgentRegistryEntry extends AgentManifest {\n  projectPath: string;\n  namespace: string;\n  scanRoot: string;\n}\n```\n\n2. **Update `AgentRow` interface:**\n```typescript\ninterface AgentRow {\n  id: string;\n  name: string;\n  description: string;\n  project_path: string;\n  runtime: string;\n  capabilities_json: string;\n  manifest_json: string;\n  registered_at: string;\n  registered_by: string;\n  namespace: string;\n  scan_root: string;\n}\n```\n\n3. **Add migration version 2 to the `MIGRATIONS` array:**\n```typescript\nconst MIGRATIONS = [\n  // Version 1: initial schema\n  `CREATE TABLE IF NOT EXISTS agents (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    description TEXT NOT NULL DEFAULT '',\n    project_path TEXT NOT NULL UNIQUE,\n    runtime TEXT NOT NULL,\n    capabilities_json TEXT NOT NULL DEFAULT '[]',\n    manifest_json TEXT NOT NULL,\n    registered_at TEXT NOT NULL,\n    registered_by TEXT NOT NULL\n  );\n  CREATE INDEX IF NOT EXISTS idx_agents_project_path ON agents(project_path);\n  CREATE INDEX IF NOT EXISTS idx_agents_runtime ON agents(runtime);`,\n\n  // Version 2: namespace support\n  `ALTER TABLE agents ADD COLUMN namespace TEXT NOT NULL DEFAULT '';\n  ALTER TABLE agents ADD COLUMN scan_root TEXT NOT NULL DEFAULT '';\n  CREATE INDEX IF NOT EXISTS idx_agents_namespace ON agents(namespace);`,\n];\n```\n\n4. **Update `insert()` prepared statement and method:**\n```typescript\ninsert: this.db.prepare(\n  `INSERT INTO agents (id, name, description, project_path, runtime, capabilities_json, manifest_json, registered_at, registered_by, namespace, scan_root)\n   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n),\n```\nThe `insert()` method call:\n```typescript\ninsert(agent: AgentRegistryEntry): void {\n  this.stmts.insert.run(\n    agent.id,\n    agent.name,\n    agent.description,\n    agent.projectPath,\n    agent.runtime,\n    JSON.stringify(agent.capabilities),\n    JSON.stringify(agent),\n    agent.registeredAt,\n    agent.registeredBy,\n    agent.namespace,\n    agent.scanRoot,\n  );\n}\n```\n\n5. **Add `listByNamespace()` method:**\n```typescript\n/** List agents filtered by namespace. */\nlistByNamespace(namespace: string): AgentRegistryEntry[] {\n  const rows = this.stmts.listByNamespace.all(namespace) as AgentRow[];\n  return rows.map((row) => this.rowToEntry(row));\n}\n```\nAdd to prepared statements:\n```typescript\nlistByNamespace: this.db.prepare(`SELECT * FROM agents WHERE namespace = ? ORDER BY registered_at DESC`),\n```\n\n6. **Update `rowToEntry()`:**\n```typescript\nprivate rowToEntry(row: AgentRow): AgentRegistryEntry {\n  const manifest = JSON.parse(row.manifest_json) as AgentManifest;\n  return {\n    ...manifest,\n    projectPath: row.project_path,\n    namespace: row.namespace,\n    scanRoot: row.scan_root,\n  };\n}\n```\n\n**Tests: Update `packages/mesh/src/__tests__/agent-registry.test.ts`** (or create if not existing)\n\nAdd tests:\n- Insert with namespace and scanRoot, verify they are persisted\n- `listByNamespace('ns-a')` returns only agents in that namespace\n- `listByNamespace('nonexistent')` returns empty array\n- Migration from v1 to v2 adds columns with empty defaults (existing rows unaffected)\n- `rowToEntry` includes namespace and scanRoot fields\n\nAcceptance criteria:\n- Migration version 2 runs successfully on existing databases\n- `insert()` requires namespace and scanRoot\n- `listByNamespace()` works with the new index\n- All existing tests continue to pass (may need updates to provide namespace/scanRoot in test fixtures)\n- Run: `npx vitest run packages/mesh/src/__tests__/agent-registry.test.ts`",
      "activeForm": "Adding namespace columns to agent registry",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.3"]
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Expose access rule management on RelayCore",
      "description": "Add three public delegate methods on `RelayCore` that expose the private `accessControl` instance's methods for external callers. This is required so that `RelayBridge` in the mesh package can write access rules.\n\n**File: `packages/relay/src/relay-core.ts`**\n\nAdd three new public methods to the `RelayCore` class after the existing `listEndpoints()` method:\n\n```typescript\n// --- Access Control Facade ---\n\n/**\n * Add an access rule. Persists immediately and hot-reloads.\n *\n * @param rule - The access rule to add (from, to, action, priority)\n */\naddAccessRule(rule: RelayAccessRule): void {\n  this.assertOpen();\n  this.accessControl.addRule(rule);\n}\n\n/**\n * Remove the first rule matching the given from/to patterns.\n *\n * @param from - The `from` pattern of the rule to remove\n * @param to - The `to` pattern of the rule to remove\n */\nremoveAccessRule(from: string, to: string): void {\n  this.assertOpen();\n  this.accessControl.removeRule(from, to);\n}\n\n/**\n * List all current access rules.\n *\n * @returns Array of access rules sorted by priority (highest first)\n */\nlistAccessRules(): RelayAccessRule[] {\n  this.assertOpen();\n  return this.accessControl.listRules();\n}\n```\n\nAdd the import for `RelayAccessRule` at the top of the file if not already imported:\n```typescript\nimport type { RelayEnvelope, RelayBudget, Signal, RelayAccessRule } from '@dorkos/shared/relay-schemas';\n```\n\n**Tests: `packages/relay/src/__tests__/relay-core.test.ts`** (add to existing or create section)\n\nAdd tests:\n- `addAccessRule()` persists a rule that `listAccessRules()` returns\n- `addAccessRule()` with duplicate from/to/priority replaces the existing rule\n- `removeAccessRule()` removes a rule by from/to patterns\n- `removeAccessRule()` with non-existent patterns is a no-op\n- `listAccessRules()` returns rules sorted by priority (highest first)\n- All three methods throw after `close()` is called\n- Access rules affect `publish()` behavior (add deny rule, verify publish throws 'Access denied')\n\nAcceptance criteria:\n- Three new public methods on RelayCore\n- No change to existing RelayCore behavior\n- Methods delegate to AccessControl and call `assertOpen()` first\n- The `RelayAccessRule` type is imported from `@dorkos/shared/relay-schemas`\n- Run: `npx vitest run packages/relay/src/__tests__/relay-core.test.ts`",
      "activeForm": "Exposing access rule methods on RelayCore",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Add namespace field to mesh Zod schemas",
      "description": "Extend the shared mesh schemas with a namespace field on `AgentManifestSchema` and add new topology-related schemas.\n\n**File: `packages/shared/src/mesh-schemas.ts`**\n\n1. **Add `namespace` field to `AgentManifestSchema`:**\n\nAdd the `namespace` field as optional on the agent manifest:\n```typescript\nexport const AgentManifestSchema = z\n  .object({\n    id: z.string().min(1).describe('ULID assigned at registration'),\n    name: z.string().min(1),\n    description: z.string().default(''),\n    runtime: AgentRuntimeSchema,\n    capabilities: z.array(z.string()).default([]),\n    behavior: AgentBehaviorSchema.default({ responseMode: 'always' }),\n    budget: AgentBudgetSchema.default({ maxHopsPerMessage: 5, maxCallsPerHour: 100 }),\n    namespace: z.string().max(64).optional(),\n    registeredAt: z.string().datetime(),\n    registeredBy: z.string().min(1),\n  })\n  .openapi('AgentManifest');\n```\n\n2. **Add topology response schemas:**\n\n```typescript\n// === Topology ===\n\nexport const NamespaceInfoSchema = z\n  .object({\n    namespace: z.string(),\n    agentCount: z.number().int(),\n    agents: z.array(AgentManifestSchema),\n  })\n  .openapi('NamespaceInfo');\n\nexport type NamespaceInfo = z.infer<typeof NamespaceInfoSchema>;\n\nexport const CrossNamespaceRuleSchema = z\n  .object({\n    sourceNamespace: z.string(),\n    targetNamespace: z.string(),\n    action: z.enum(['allow', 'deny']),\n  })\n  .openapi('CrossNamespaceRule');\n\nexport type CrossNamespaceRule = z.infer<typeof CrossNamespaceRuleSchema>;\n\nexport const TopologyViewSchema = z\n  .object({\n    callerNamespace: z.string(),\n    namespaces: z.array(NamespaceInfoSchema),\n    accessRules: z.array(CrossNamespaceRuleSchema),\n  })\n  .openapi('TopologyView');\n\nexport type TopologyView = z.infer<typeof TopologyViewSchema>;\n```\n\n3. **Add HTTP request schema for access rule updates:**\n\n```typescript\n/** Request body for PUT /api/mesh/topology/access */\nexport const UpdateAccessRuleRequestSchema = z\n  .object({\n    sourceNamespace: z.string().min(1),\n    targetNamespace: z.string().min(1),\n    action: z.enum(['allow', 'deny']),\n  })\n  .openapi('UpdateAccessRuleRequest');\n\nexport type UpdateAccessRuleRequest = z.infer<typeof UpdateAccessRuleRequestSchema>;\n```\n\n4. **Extend `AgentListQuerySchema` with callerNamespace:**\n\n```typescript\nexport const AgentListQuerySchema = z\n  .object({\n    runtime: AgentRuntimeSchema.optional(),\n    capability: z.string().optional(),\n    callerNamespace: z.string().optional(),\n  })\n  .openapi('AgentListQuery');\n```\n\nAcceptance criteria:\n- `namespace` field added to `AgentManifestSchema` as optional string, max 64 chars\n- `NamespaceInfoSchema`, `CrossNamespaceRuleSchema`, `TopologyViewSchema` defined with `.openapi()` metadata\n- `UpdateAccessRuleRequestSchema` defined for HTTP request validation\n- `AgentListQuerySchema` extended with optional `callerNamespace`\n- All new types exported\n- Existing tests still pass (namespace is optional so no breaking change)\n- Run: `npm run typecheck` to verify no type errors",
      "activeForm": "Adding topology schemas to shared package",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2", "1.3"]
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Extend RelayBridge to write access rules on registration",
      "description": "Extend the `RelayBridge` class in `packages/mesh/src/relay-bridge.ts` to write default access rules when registering an agent and to clean up rules on unregistration.\n\n**File: `packages/mesh/src/relay-bridge.ts`**\n\nThe current `registerAgent()` only creates a Relay endpoint. It must be extended to:\n1. Accept namespace and scanRoot parameters\n2. Use namespace in the subject pattern (`relay.agent.{namespace}.{agentId}` instead of `relay.agent.{basename}.{agentId}`)\n3. Write same-namespace allow rule (priority 100)\n4. Write cross-namespace deny rule (priority 10)\n\nReplace the entire class:\n\n```typescript\nimport path from 'path';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\nimport type { RelayCore } from '@dorkos/relay';\n\nexport class RelayBridge {\n  constructor(private readonly relayCore?: RelayCore) {}\n\n  /**\n   * Register a Relay endpoint for an agent and write namespace access rules.\n   *\n   * Subject format: `relay.agent.{namespace}.{agent.id}`\n   * When namespace is empty, falls back to `path.basename(projectPath)` for backward compat.\n   *\n   * Access rules written:\n   * - Same-namespace allow (priority 100): `relay.agent.{ns}.*` -> `relay.agent.{ns}.*`\n   * - Cross-namespace deny (priority 10): `relay.agent.{ns}.*` -> `relay.agent.>`\n   *\n   * @param agent - The agent manifest\n   * @param projectPath - Absolute path to the agent's project directory\n   * @param namespace - The resolved namespace for the agent (optional for backward compat)\n   * @param scanRoot - The scan root used for namespace derivation (optional for backward compat)\n   * @returns The registered subject string, or null if RelayCore is not available\n   */\n  async registerAgent(\n    agent: AgentManifest,\n    projectPath: string,\n    namespace?: string,\n    scanRoot?: string,\n  ): Promise<string | null> {\n    if (!this.relayCore) return null;\n\n    const ns = namespace || path.basename(projectPath);\n    const subject = `relay.agent.${ns}.${agent.id}`;\n    await this.relayCore.registerEndpoint(subject);\n\n    // Write default same-namespace allow rule (idempotent — deduped by addRule)\n    this.relayCore.addAccessRule({\n      from: `relay.agent.${ns}.*`,\n      to: `relay.agent.${ns}.*`,\n      action: 'allow',\n      priority: 100,\n    });\n\n    // Write default cross-namespace deny rule (catch-all, lower priority)\n    this.relayCore.addAccessRule({\n      from: `relay.agent.${ns}.*`,\n      to: 'relay.agent.>',\n      action: 'deny',\n      priority: 10,\n    });\n\n    return subject;\n  }\n\n  /**\n   * Unregister a Relay endpoint for an agent.\n   *\n   * @param subject - The subject string returned from registerAgent\n   */\n  async unregisterAgent(subject: string): Promise<void> {\n    if (!this.relayCore) return;\n    await this.relayCore.unregisterEndpoint(subject);\n  }\n\n  /**\n   * Clean up namespace access rules when the last agent in a namespace is removed.\n   *\n   * @param namespace - The namespace to clean up rules for\n   */\n  cleanupNamespaceRules(namespace: string): void {\n    if (!this.relayCore) return;\n    // Remove the same-namespace allow rule\n    this.relayCore.removeAccessRule(\n      `relay.agent.${namespace}.*`,\n      `relay.agent.${namespace}.*`,\n    );\n    // Remove the cross-namespace deny rule\n    this.relayCore.removeAccessRule(\n      `relay.agent.${namespace}.*`,\n      'relay.agent.>',\n    );\n  }\n}\n```\n\n**Tests: `packages/mesh/src/__tests__/relay-bridge.test.ts`**\n\nTests to write:\n- `registerAgent()` with namespace creates endpoint at `relay.agent.{ns}.{id}`\n- `registerAgent()` without namespace falls back to `path.basename(projectPath)`\n- `registerAgent()` calls `relayCore.addAccessRule()` twice (same-ns allow + cross-ns deny)\n- Same-namespace allow rule has priority 100, cross-namespace deny has priority 10\n- `unregisterAgent()` calls `relayCore.unregisterEndpoint()`\n- `cleanupNamespaceRules()` calls `removeAccessRule()` twice\n- All methods are no-ops when relayCore is undefined\n- Mock relayCore to verify exact arguments passed to `addAccessRule` and `removeAccessRule`\n\nAcceptance criteria:\n- `registerAgent()` signature extended with optional `namespace` and `scanRoot` params\n- Backward compatible — existing callers without namespace still work (falls back to basename)\n- Access rules written on registration\n- `cleanupNamespaceRules()` method added\n- Tests pass: `npx vitest run packages/mesh/src/__tests__/relay-bridge.test.ts`",
      "activeForm": "Extending RelayBridge with access rule writing",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3", "1.4"],
      "parallelWith": []
    },
    {
      "id": "1.6",
      "phase": 1,
      "phaseName": "Core Policy Layer",
      "subject": "[mesh-network-topology] [P1] Wire namespace through MeshCore registration flow",
      "description": "Update `MeshCore` to accept scan roots, resolve namespaces, and pass namespace/scanRoot through the entire registration pipeline.\n\n**File: `packages/mesh/src/mesh-core.ts`**\n\n1. **Update `MeshOptions` interface:**\n```typescript\nexport interface MeshOptions {\n  dataDir?: string;\n  relayCore?: RelayCore;\n  strategies?: DiscoveryStrategy[];\n  /** Default scan root for namespace derivation. */\n  defaultScanRoot?: string;\n}\n```\n\n2. **Add import for `resolveNamespace`:**\n```typescript\nimport { resolveNamespace } from './namespace-resolver.js';\n```\n\n3. **Store defaultScanRoot in constructor:**\n```typescript\nprivate readonly defaultScanRoot: string;\n\nconstructor(options: MeshOptions = {}) {\n  // ... existing code ...\n  this.defaultScanRoot = options.defaultScanRoot ?? os.homedir();\n}\n```\n\n4. **Update `register()` method:**\n```typescript\nasync register(\n  candidate: DiscoveryCandidate,\n  overrides?: Partial<AgentManifest>,\n  approver = DEFAULT_REGISTRAR,\n  scanRoot?: string,\n): Promise<AgentManifest> {\n  const id = this.generateUlid();\n  const now = new Date().toISOString();\n  const effectiveScanRoot = scanRoot ?? this.defaultScanRoot;\n  const namespace = resolveNamespace(candidate.path, effectiveScanRoot, overrides?.namespace);\n\n  const manifest: AgentManifest = {\n    id,\n    name: overrides?.name ?? candidate.hints.suggestedName,\n    description: overrides?.description ?? candidate.hints.description ?? '',\n    runtime: overrides?.runtime ?? candidate.hints.detectedRuntime,\n    capabilities: overrides?.capabilities ?? candidate.hints.inferredCapabilities ?? [],\n    behavior: overrides?.behavior ?? { responseMode: 'always' },\n    budget: overrides?.budget ?? { maxHopsPerMessage: 5, maxCallsPerHour: 100 },\n    namespace,\n    registeredAt: overrides?.registeredAt ?? now,\n    registeredBy: overrides?.registeredBy ?? approver,\n  };\n\n  await writeManifest(candidate.path, manifest);\n\n  const entry: AgentRegistryEntry = { ...manifest, projectPath: candidate.path, namespace, scanRoot: effectiveScanRoot };\n  this.registry.insert(entry);\n\n  await this.relayBridge.registerAgent(manifest, candidate.path, namespace, effectiveScanRoot);\n\n  return manifest;\n}\n```\n\n5. **Update `registerByPath()` method similarly:**\n```typescript\nasync registerByPath(\n  projectPath: string,\n  partial: Partial<AgentManifest> & { name: string; runtime: AgentRuntime },\n  approver = DEFAULT_REGISTRAR,\n  scanRoot?: string,\n): Promise<AgentManifest> {\n  const id = this.generateUlid();\n  const now = new Date().toISOString();\n  const effectiveScanRoot = scanRoot ?? this.defaultScanRoot;\n  const namespace = resolveNamespace(projectPath, effectiveScanRoot, partial.namespace);\n\n  const manifest: AgentManifest = {\n    id,\n    name: partial.name,\n    description: partial.description ?? '',\n    runtime: partial.runtime,\n    capabilities: partial.capabilities ?? [],\n    behavior: partial.behavior ?? { responseMode: 'always' },\n    budget: partial.budget ?? { maxHopsPerMessage: 5, maxCallsPerHour: 100 },\n    namespace,\n    registeredAt: partial.registeredAt ?? now,\n    registeredBy: partial.registeredBy ?? approver,\n  };\n\n  await writeManifest(projectPath, manifest);\n\n  const entry: AgentRegistryEntry = { ...manifest, projectPath, namespace, scanRoot: effectiveScanRoot };\n  this.registry.insert(entry);\n\n  await this.relayBridge.registerAgent(manifest, projectPath, namespace, effectiveScanRoot);\n\n  return manifest;\n}\n```\n\n6. **Update `list()` to support callerNamespace filtering:**\n```typescript\nlist(filters?: { runtime?: AgentRuntime; capability?: string; callerNamespace?: string }): AgentManifest[] {\n  const entries = this.registry.list(filters);\n  let results = entries;\n\n  if (filters?.callerNamespace) {\n    const accessibleNamespaces = this.getAccessibleNamespaces(filters.callerNamespace);\n    results = results.filter((e) => accessibleNamespaces.has(e.namespace));\n  }\n\n  return results.map(({ projectPath: _p, namespace: _n, scanRoot: _s, ...manifest }) => manifest);\n}\n```\n\n7. **Add helper `getAccessibleNamespaces()`:**\n```typescript\nprivate getAccessibleNamespaces(callerNamespace: string): Set<string> {\n  if (callerNamespace === '*') {\n    // Admin view — all namespaces are accessible\n    const all = this.registry.list();\n    return new Set(all.map((e) => e.namespace));\n  }\n  // Always includes own namespace\n  const accessible = new Set<string>([callerNamespace]);\n  // Check relay access rules for cross-namespace allow rules\n  if (this.relayBridge) {\n    // This will be fully implemented in Task 2.1 with TopologyManager\n    // For now, just return own namespace\n  }\n  return accessible;\n}\n```\n\n8. **Update `unregister()` to clean up namespace rules when last agent removed:**\n```typescript\nasync unregister(agentId: string): Promise<void> {\n  const agent = this.registry.get(agentId);\n  if (!agent) return;\n\n  const namespace = agent.namespace;\n  const subject = `relay.agent.${namespace || path.basename(agent.projectPath)}.${agent.id}`;\n  await this.relayBridge.unregisterAgent(subject);\n\n  this.registry.remove(agentId);\n\n  // Clean up namespace rules if this was the last agent in the namespace\n  if (namespace) {\n    const remaining = this.registry.listByNamespace(namespace);\n    if (remaining.length === 0) {\n      this.relayBridge.cleanupNamespaceRules(namespace);\n    }\n  }\n}\n```\n\n9. **Update `upsertAutoImported()` to include namespace:**\n```typescript\nprivate async upsertAutoImported(manifest: AgentManifest, projectPath: string): Promise<void> {\n  if (this.registry.getByPath(projectPath)) return;\n  const namespace = manifest.namespace ?? '';\n  const entry: AgentRegistryEntry = { ...manifest, projectPath, namespace, scanRoot: this.defaultScanRoot };\n  this.registry.insert(entry);\n  await this.relayBridge.registerAgent(manifest, projectPath, namespace, this.defaultScanRoot);\n}\n```\n\n**Tests: Update `packages/mesh/src/__tests__/mesh-core.test.ts`**\n\nAdd/update tests:\n- `register()` stores namespace derived from scanRoot + projectPath\n- `register()` with manifest namespace override uses the override\n- `registerByPath()` stores namespace and scanRoot\n- `list({ callerNamespace: 'ns-a' })` returns only agents in ns-a\n- `list()` without callerNamespace returns all agents\n- `unregister()` cleans up namespace rules when last agent removed\n- `unregister()` does NOT clean up rules when other agents remain in namespace\n\nAcceptance criteria:\n- `MeshOptions.defaultScanRoot` accepted\n- `register()` and `registerByPath()` resolve and store namespaces\n- `list()` supports `callerNamespace` filtering\n- `unregister()` cleans up namespace rules when appropriate\n- All existing tests updated and passing\n- Run: `npx vitest run packages/mesh/src/__tests__/mesh-core.test.ts`",
      "activeForm": "Wiring namespace through MeshCore registration",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1", "1.2", "1.4", "1.5"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Topology & Budget",
      "subject": "[mesh-network-topology] [P2] Create TopologyManager with invisible boundary filtering",
      "description": "Create a new `TopologyManager` module at `packages/mesh/src/topology.ts` that composes the registry and relay bridge for topology queries with invisible boundary enforcement.\n\n**File: `packages/mesh/src/topology.ts`**\n\n```typescript\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\nimport type { RelayCore } from '@dorkos/relay';\nimport type { AgentRegistry, AgentRegistryEntry } from './agent-registry.js';\nimport type { RelayBridge } from './relay-bridge.js';\n\n/** Information about a single namespace in the topology. */\nexport interface NamespaceInfo {\n  namespace: string;\n  agentCount: number;\n  agents: AgentManifest[];\n}\n\n/** A cross-namespace access rule. */\nexport interface CrossNamespaceRule {\n  sourceNamespace: string;\n  targetNamespace: string;\n  action: 'allow' | 'deny';\n}\n\n/** The full topology view filtered by caller's namespace access. */\nexport interface TopologyView {\n  callerNamespace: string;\n  namespaces: NamespaceInfo[];\n  accessRules: CrossNamespaceRule[];\n}\n\n/**\n * Manages network topology queries with invisible boundary enforcement.\n *\n * Agents can only see namespaces they have access to. Namespaces without\n * access are omitted entirely (invisible boundaries).\n */\nexport class TopologyManager {\n  constructor(\n    private readonly registry: AgentRegistry,\n    private readonly relayBridge: RelayBridge,\n    private readonly relayCore?: RelayCore,\n  ) {}\n\n  /**\n   * Get the topology view filtered by caller's namespace access.\n   *\n   * When callerNamespace is '*', returns the full admin view with all namespaces.\n   * Otherwise, only returns namespaces the caller can reach.\n   *\n   * @param callerNamespace - The namespace of the requesting agent, or '*' for admin\n   */\n  getTopology(callerNamespace: string): TopologyView {\n    const allEntries = this.registry.list();\n    const accessibleNamespaces = this.getAccessibleNamespaces(callerNamespace);\n\n    // Group entries by namespace, filtering to only accessible ones\n    const namespaceMap = new Map<string, AgentRegistryEntry[]>();\n    for (const entry of allEntries) {\n      if (!accessibleNamespaces.has(entry.namespace)) continue;\n      const existing = namespaceMap.get(entry.namespace) ?? [];\n      existing.push(entry);\n      namespaceMap.set(entry.namespace, existing);\n    }\n\n    const namespaces: NamespaceInfo[] = Array.from(namespaceMap.entries()).map(\n      ([ns, entries]) => ({\n        namespace: ns,\n        agentCount: entries.length,\n        agents: entries.map(({ projectPath: _p, namespace: _n, scanRoot: _s, ...manifest }) => manifest),\n      }),\n    );\n\n    const accessRules = this.listCrossNamespaceRules();\n    // Filter access rules to only show rules involving accessible namespaces\n    const filteredRules = callerNamespace === '*'\n      ? accessRules\n      : accessRules.filter(\n          (r) => accessibleNamespaces.has(r.sourceNamespace) || accessibleNamespaces.has(r.targetNamespace),\n        );\n\n    return {\n      callerNamespace,\n      namespaces,\n      accessRules: filteredRules,\n    };\n  }\n\n  /**\n   * Get which agents a specific agent can reach.\n   *\n   * @param agentId - The ULID of the agent\n   * @returns Array of reachable agent manifests, or undefined if agent not found\n   */\n  getAgentAccess(agentId: string): AgentManifest[] | undefined {\n    const agent = this.registry.get(agentId);\n    if (!agent) return undefined;\n\n    const accessibleNamespaces = this.getAccessibleNamespaces(agent.namespace);\n    const allEntries = this.registry.list();\n\n    return allEntries\n      .filter((e) => accessibleNamespaces.has(e.namespace) && e.id !== agentId)\n      .map(({ projectPath: _p, namespace: _n, scanRoot: _s, ...manifest }) => manifest);\n  }\n\n  /**\n   * Add a cross-namespace allow rule.\n   *\n   * Creates a Relay access rule: `relay.agent.{source}.*` -> `relay.agent.{target}.*` allow (priority 50)\n   * Priority 50 is above the default deny (10) but below same-namespace allow (100).\n   *\n   * @param sourceNamespace - The namespace to allow messages from\n   * @param targetNamespace - The namespace to allow messages to\n   */\n  allowCrossNamespace(sourceNamespace: string, targetNamespace: string): void {\n    if (!this.relayCore) return;\n    this.relayCore.addAccessRule({\n      from: `relay.agent.${sourceNamespace}.*`,\n      to: `relay.agent.${targetNamespace}.*`,\n      action: 'allow',\n      priority: 50,\n    });\n  }\n\n  /**\n   * Remove a cross-namespace allow rule (reverts to default-deny).\n   *\n   * @param sourceNamespace - Source namespace\n   * @param targetNamespace - Target namespace\n   */\n  denyCrossNamespace(sourceNamespace: string, targetNamespace: string): void {\n    if (!this.relayCore) return;\n    this.relayCore.removeAccessRule(\n      `relay.agent.${sourceNamespace}.*`,\n      `relay.agent.${targetNamespace}.*`,\n    );\n  }\n\n  /**\n   * List all cross-namespace rules.\n   *\n   * Extracts cross-namespace rules from Relay access rules by parsing\n   * the subject patterns. Only includes rules in the `relay.agent.{ns}.*` format.\n   */\n  listCrossNamespaceRules(): CrossNamespaceRule[] {\n    if (!this.relayCore) return [];\n\n    const allRules = this.relayCore.listAccessRules();\n    const crossRules: CrossNamespaceRule[] = [];\n\n    for (const rule of allRules) {\n      const fromMatch = rule.from.match(/^relay\\.agent\\.(.*)\\.\\*$/);\n      const toMatch = rule.to.match(/^relay\\.agent\\.(.*)\\.\\*$/);\n      if (fromMatch && toMatch) {\n        const sourceNs = fromMatch[1];\n        const targetNs = toMatch[1];\n        // Only include cross-namespace rules (skip same-namespace allow)\n        if (sourceNs !== targetNs) {\n          crossRules.push({\n            sourceNamespace: sourceNs!,\n            targetNamespace: targetNs!,\n            action: rule.action,\n          });\n        }\n      }\n    }\n\n    return crossRules;\n  }\n\n  /**\n   * Get the set of namespaces accessible from a given caller namespace.\n   *\n   * Always includes the caller's own namespace. Checks Relay access rules\n   * for explicit cross-namespace allow rules.\n   */\n  private getAccessibleNamespaces(callerNamespace: string): Set<string> {\n    const allEntries = this.registry.list();\n    const allNamespaces = new Set(allEntries.map((e) => e.namespace));\n\n    if (callerNamespace === '*') return allNamespaces;\n\n    const accessible = new Set<string>([callerNamespace]);\n\n    if (!this.relayCore) return accessible;\n\n    // Check which other namespaces the caller has allow rules for\n    const rules = this.relayCore.listAccessRules();\n    for (const rule of rules) {\n      if (rule.action !== 'allow') continue;\n      const fromMatch = rule.from.match(/^relay\\.agent\\.(.*)\\.\\*$/);\n      const toMatch = rule.to.match(/^relay\\.agent\\.(.*)\\.\\*$/);\n      if (fromMatch && toMatch && fromMatch[1] === callerNamespace) {\n        accessible.add(toMatch[1]!);\n      }\n    }\n\n    return accessible;\n  }\n}\n```\n\n**Export from `packages/mesh/src/index.ts`:**\n```typescript\nexport { TopologyManager } from './topology.js';\nexport type { TopologyView, NamespaceInfo, CrossNamespaceRule } from './topology.js';\n```\n\n**Tests: `packages/mesh/src/__tests__/topology.test.ts`**\n\nTests to write:\n- `getTopology('ns-a')` returns only ns-a agents (invisible boundary)\n- `getTopology('*')` returns all namespaces (admin view)\n- `getTopology('ns-a')` after `allowCrossNamespace('ns-a', 'ns-b')` returns both ns-a and ns-b\n- `denyCrossNamespace('ns-a', 'ns-b')` hides ns-b from ns-a again\n- `getAgentAccess(agentId)` returns agents in accessible namespaces\n- `getAgentAccess('nonexistent')` returns undefined\n- `listCrossNamespaceRules()` returns only cross-namespace rules (not same-namespace)\n- No Relay scenario (relayCore undefined): returns own namespace only, rules are empty\n\nAcceptance criteria:\n- `TopologyManager` class created at `packages/mesh/src/topology.ts`\n- All five public methods implemented\n- Invisible boundary filtering works correctly\n- Exported from `packages/mesh/src/index.ts`\n- Tests pass: `npx vitest run packages/mesh/src/__tests__/topology.test.ts`",
      "activeForm": "Creating TopologyManager with invisible boundaries",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.2", "1.3", "1.5"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Topology & Budget",
      "subject": "[mesh-network-topology] [P2] Implement budget counter table with sliding window enforcement",
      "description": "Add a `budget_counters` table to mesh.db and implement sliding window rate limiting for agent `maxCallsPerHour` enforcement.\n\n**Schema migration (add to `packages/mesh/src/agent-registry.ts` MIGRATIONS array as version 3):**\n\n```sql\n-- Version 3: budget counters\nCREATE TABLE IF NOT EXISTS budget_counters (\n  agent_id TEXT NOT NULL,\n  bucket_minute INTEGER NOT NULL,\n  call_count INTEGER NOT NULL DEFAULT 0,\n  PRIMARY KEY (agent_id, bucket_minute)\n);\nCREATE INDEX IF NOT EXISTS idx_budget_counters_agent ON budget_counters(agent_id);\n```\n\n**New file: `packages/mesh/src/budget-mapper.ts`**\n\n```typescript\nimport type Database from 'better-sqlite3';\n\n/** Number of 1-minute buckets in one hour. */\nconst BUCKETS_PER_HOUR = 60;\n\n/** Prune buckets older than this many minutes. */\nconst PRUNE_AGE_MINUTES = 120;\n\n/**\n * Maps agent manifest budget constraints to enforceable rate limits.\n *\n * Uses a sliding window log algorithm (ADR 0014) with 1-minute time buckets\n * stored in SQLite. Each call to `checkBudget` sums calls in the last 60\n * minutes and compares against `maxCallsPerHour`.\n */\nexport class BudgetMapper {\n  private readonly stmts: {\n    increment: Database.Statement;\n    sumWindow: Database.Statement;\n    prune: Database.Statement;\n  };\n\n  constructor(private readonly db: Database.Database) {\n    this.stmts = {\n      increment: this.db.prepare(\n        `INSERT INTO budget_counters (agent_id, bucket_minute, call_count)\n         VALUES (?, ?, 1)\n         ON CONFLICT(agent_id, bucket_minute)\n         DO UPDATE SET call_count = call_count + 1`,\n      ),\n      sumWindow: this.db.prepare(\n        `SELECT COALESCE(SUM(call_count), 0) AS total\n         FROM budget_counters\n         WHERE agent_id = ? AND bucket_minute >= ?`,\n      ),\n      prune: this.db.prepare(\n        `DELETE FROM budget_counters WHERE bucket_minute < ?`,\n      ),\n    };\n  }\n\n  /**\n   * Check if an agent has remaining budget for this hour.\n   *\n   * @param agentId - The agent's ULID\n   * @param maxCallsPerHour - The agent's configured max calls per hour\n   * @returns `{ allowed: true, remaining }` or `{ allowed: false, used }`\n   */\n  checkBudget(\n    agentId: string,\n    maxCallsPerHour: number,\n  ): { allowed: true; remaining: number } | { allowed: false; used: number } {\n    const nowMinute = this.currentMinuteBucket();\n    const windowStart = nowMinute - BUCKETS_PER_HOUR;\n\n    // Lazily prune old buckets\n    this.stmts.prune.run(nowMinute - PRUNE_AGE_MINUTES);\n\n    const row = this.stmts.sumWindow.get(agentId, windowStart) as { total: number };\n    const used = row.total;\n\n    if (used >= maxCallsPerHour) {\n      return { allowed: false, used };\n    }\n\n    return { allowed: true, remaining: maxCallsPerHour - used };\n  }\n\n  /**\n   * Record a call for budget tracking.\n   *\n   * @param agentId - The agent's ULID\n   */\n  recordCall(agentId: string): void {\n    const nowMinute = this.currentMinuteBucket();\n    this.stmts.increment.run(agentId, nowMinute);\n  }\n\n  /**\n   * Get the current minute bucket (minutes since Unix epoch).\n   */\n  private currentMinuteBucket(): number {\n    return Math.floor(Date.now() / 60_000);\n  }\n}\n```\n\n**Export from `packages/mesh/src/index.ts`:**\n```typescript\nexport { BudgetMapper } from './budget-mapper.js';\n```\n\n**Integrate into RelayBridge (update `packages/mesh/src/relay-bridge.ts`):**\n\nAdd a `setBudgetMapper(mapper: BudgetMapper)` method and call `checkBudget` before publishing. The exact integration point is in `MeshCore` which creates the `BudgetMapper` and injects it.\n\nAdd to `MeshCore` constructor:\n```typescript\nprivate readonly budgetMapper: BudgetMapper;\n// In constructor:\nthis.budgetMapper = new BudgetMapper(this.registry.database);\n```\n\n**Tests: `packages/mesh/src/__tests__/budget-mapper.test.ts`**\n\nTests to write:\n- `checkBudget()` returns `{ allowed: true, remaining: 100 }` for a fresh agent with maxCallsPerHour=100\n- `recordCall()` increments the count, `checkBudget()` reflects it\n- After recording 100 calls, `checkBudget()` returns `{ allowed: false, used: 100 }`\n- Multiple calls within same minute bucket aggregate correctly\n- Calls older than 60 minutes are not counted in the window\n- `prune` removes buckets older than 120 minutes\n- Concurrent calls within the same minute use SQLite's UPSERT correctly\n\nAcceptance criteria:\n- Migration version 3 adds `budget_counters` table\n- `BudgetMapper` class with `checkBudget()` and `recordCall()`\n- Sliding window uses 1-minute buckets, sums last 60 minutes\n- Lazy pruning of buckets older than 120 minutes\n- Tests pass: `npx vitest run packages/mesh/src/__tests__/budget-mapper.test.ts`",
      "activeForm": "Implementing budget counter with sliding window",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Topology & Budget",
      "subject": "[mesh-network-topology] [P2] Integrate TopologyManager into MeshCore with topology query methods",
      "description": "Wire `TopologyManager` into `MeshCore` so topology queries and cross-namespace access management flow through the main MeshCore API.\n\n**File: `packages/mesh/src/mesh-core.ts`**\n\n1. **Import TopologyManager:**\n```typescript\nimport { TopologyManager } from './topology.js';\nimport type { TopologyView, CrossNamespaceRule } from './topology.js';\n```\n\n2. **Create TopologyManager in constructor:**\n```typescript\nprivate readonly topology: TopologyManager;\n\nconstructor(options: MeshOptions = {}) {\n  // ... existing code ...\n  this.topology = new TopologyManager(this.registry, this.relayBridge, options.relayCore);\n}\n```\n\n3. **Add topology delegate methods:**\n```typescript\n/**\n * Get topology view for a namespace.\n *\n * @param callerNamespace - Caller's namespace, or '*' for admin view\n */\ngetTopology(callerNamespace: string): TopologyView {\n  return this.topology.getTopology(callerNamespace);\n}\n\n/**\n * Get which agents a specific agent can reach.\n *\n * @param agentId - The agent's ULID\n * @returns Array of reachable agent manifests, or undefined if not found\n */\ngetAgentAccess(agentId: string): AgentManifest[] | undefined {\n  return this.topology.getAgentAccess(agentId);\n}\n\n/**\n * Add a cross-namespace allow rule.\n *\n * @param sourceNamespace - Namespace to allow messages from\n * @param targetNamespace - Namespace to allow messages to\n */\nallowCrossNamespace(sourceNamespace: string, targetNamespace: string): void {\n  this.topology.allowCrossNamespace(sourceNamespace, targetNamespace);\n}\n\n/**\n * Remove a cross-namespace allow rule (reverts to default-deny).\n *\n * @param sourceNamespace - Source namespace\n * @param targetNamespace - Target namespace\n */\ndenyCrossNamespace(sourceNamespace: string, targetNamespace: string): void {\n  this.topology.denyCrossNamespace(sourceNamespace, targetNamespace);\n}\n\n/**\n * List all cross-namespace rules.\n */\nlistCrossNamespaceRules(): CrossNamespaceRule[] {\n  return this.topology.listCrossNamespaceRules();\n}\n```\n\n4. **Update `list()` to use TopologyManager for namespace filtering** (replace the stub from task 1.6):\n```typescript\nlist(filters?: { runtime?: AgentRuntime; capability?: string; callerNamespace?: string }): AgentManifest[] {\n  if (filters?.callerNamespace) {\n    // Use topology for proper invisible boundary filtering\n    const view = this.topology.getTopology(filters.callerNamespace);\n    let agents = view.namespaces.flatMap((ns) => ns.agents);\n    if (filters.runtime) agents = agents.filter((a) => a.runtime === filters.runtime);\n    if (filters.capability) agents = agents.filter((a) => a.capabilities.includes(filters.capability!));\n    return agents;\n  }\n  return this.registry.list(filters).map(({ projectPath: _p, namespace: _n, scanRoot: _s, ...manifest }) => manifest);\n}\n```\n\n**Integration tests: `packages/mesh/src/__tests__/relay-integration.test.ts`**\n\nCreate a new integration test file that tests the full flow with real SQLite and mocked RelayCore:\n- Register two agents in same namespace → both visible to each other\n- Register two agents in different namespaces → only own namespace visible\n- `allowCrossNamespace('ns-a', 'ns-b')` → ns-b agents become visible to ns-a\n- `denyCrossNamespace('ns-a', 'ns-b')` → ns-b agents hidden again from ns-a\n- `getTopology('*')` returns all namespaces\n- `getAgentAccess(agentId)` returns only reachable agents\n- Budget check integration: register agent, record calls, verify budget enforcement\n\nAcceptance criteria:\n- `TopologyManager` composed in `MeshCore` constructor\n- All five topology methods delegated from `MeshCore`\n- `list()` uses `TopologyManager.getTopology()` for namespace filtering\n- Integration tests pass: `npx vitest run packages/mesh/src/__tests__/relay-integration.test.ts`",
      "activeForm": "Integrating TopologyManager into MeshCore",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.6", "2.1", "2.2"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "HTTP API & MCP",
      "subject": "[mesh-network-topology] [P3] Add topology HTTP routes to mesh router",
      "description": "Add three new HTTP endpoints to the existing mesh router for topology queries and cross-namespace access management.\n\n**File: `apps/server/src/routes/mesh.ts`**\n\n1. **Add import for the new schema:**\n```typescript\nimport {\n  DiscoverRequestSchema,\n  RegisterAgentRequestSchema,\n  DenyRequestSchema,\n  UpdateAgentRequestSchema,\n  AgentListQuerySchema,\n  UpdateAccessRuleRequestSchema,\n} from '@dorkos/shared/mesh-schemas';\n```\n\n2. **Add three new routes after the existing routes (before `return router;`):**\n\n```typescript\n// GET /topology — Network topology (filtered by caller namespace)\nrouter.get('/topology', (req, res) => {\n  const callerNamespace = req.query.namespace as string | undefined;\n  if (!callerNamespace) {\n    // Without namespace, return full topology (admin view)\n    return res.json(meshCore.getTopology('*'));\n  }\n  return res.json(meshCore.getTopology(callerNamespace));\n});\n\n// PUT /topology/access — Update cross-namespace access rule\nrouter.put('/topology/access', (req, res) => {\n  const result = UpdateAccessRuleRequestSchema.safeParse(req.body);\n  if (!result.success) {\n    return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n  }\n  const { sourceNamespace, targetNamespace, action } = result.data;\n  if (action === 'allow') {\n    meshCore.allowCrossNamespace(sourceNamespace, targetNamespace);\n  } else {\n    meshCore.denyCrossNamespace(sourceNamespace, targetNamespace);\n  }\n  return res.json({ success: true });\n});\n\n// GET /agents/:id/access — Which agents this agent can reach\nrouter.get('/agents/:id/access', (req, res) => {\n  const reachable = meshCore.getAgentAccess(req.params.id);\n  if (!reachable) {\n    return res.status(404).json({ error: 'Agent not found' });\n  }\n  return res.json({ agents: reachable });\n});\n```\n\nIMPORTANT: The `/agents/:id/access` route MUST be defined BEFORE the existing `/agents/:id` route, or Express will never match it (the `:id` param would capture 'access' as a value). Alternatively, since we need `/agents/:id/access`, this should be fine as Express matches by specificity. But verify that the route ordering is correct.\n\n3. **Update existing `GET /agents` to pass `callerNamespace`:**\n```typescript\nrouter.get('/agents', (req, res) => {\n  const result = AgentListQuerySchema.safeParse(req.query);\n  if (!result.success) {\n    return res.status(400).json({ error: 'Validation failed', details: result.error.flatten() });\n  }\n  const agents = meshCore.list(result.data);\n  return res.json({ agents });\n});\n```\nNote: This should work as-is since `AgentListQuerySchema` now includes `callerNamespace` (from task 1.4), and `meshCore.list()` accepts it (from task 2.3). The only change is ensuring the existing handler passes the full result.data which now may include callerNamespace.\n\n**Tests: `apps/server/src/routes/__tests__/mesh-topology.test.ts`**\n\nCreate tests that mock `MeshCore` and verify:\n- `GET /topology` without namespace calls `meshCore.getTopology('*')`\n- `GET /topology?namespace=ns-a` calls `meshCore.getTopology('ns-a')`\n- `PUT /topology/access` with `{ sourceNamespace: 'ns-a', targetNamespace: 'ns-b', action: 'allow' }` calls `meshCore.allowCrossNamespace('ns-a', 'ns-b')`\n- `PUT /topology/access` with `action: 'deny'` calls `meshCore.denyCrossNamespace()`\n- `PUT /topology/access` with invalid body returns 400\n- `GET /agents/:id/access` returns `{ agents: [...] }` for existing agent\n- `GET /agents/:id/access` returns 404 for unknown agent\n- `GET /agents?callerNamespace=ns-a` passes callerNamespace through to `meshCore.list()`\n\nAcceptance criteria:\n- Three new routes added to mesh router\n- All routes follow existing validation patterns (Zod safeParse, error format)\n- Existing routes unchanged\n- Tests pass: `npx vitest run apps/server/src/routes/__tests__/mesh-topology.test.ts`",
      "activeForm": "Adding topology HTTP routes",
      "size": "medium",
      "priority": "high",
      "dependencies": ["2.3"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "HTTP API & MCP",
      "subject": "[mesh-network-topology] [P3] Add mesh_query_topology MCP tool and update mesh_list filtering",
      "description": "Add a new `mesh_query_topology` MCP tool and update the existing `mesh_list` tool to support `callerNamespace` parameter for invisible boundary filtering.\n\n**File: `apps/server/src/services/core/mcp-tool-server.ts`**\n\n1. **Add `mesh_query_topology` tool to the mesh tools array:**\n\n```typescript\ntool(\n  'mesh_query_topology',\n  'Query the agent network topology visible to a given namespace. Returns namespace groups, agent lists, and cross-namespace access rules filtered by caller visibility.',\n  {\n    namespace: z.string().optional().describe('Caller namespace to filter by (omit for full admin view)'),\n  },\n  createMeshQueryTopologyHandler(deps),\n),\n```\n\n2. **Create the handler factory function:**\n\n```typescript\nfunction createMeshQueryTopologyHandler(deps: McpToolDeps) {\n  return async function handleMeshQueryTopology(args: { namespace?: string }) {\n    if (!deps.meshCore) {\n      return {\n        content: [{ type: 'text' as const, text: JSON.stringify({ error: 'Mesh is not enabled' }) }],\n      };\n    }\n    try {\n      const topology = deps.meshCore.getTopology(args.namespace ?? '*');\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify(topology, null, 2),\n          },\n        ],\n      };\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              error: err instanceof Error ? err.message : 'Failed to query topology',\n            }),\n          },\n        ],\n      };\n    }\n  };\n}\n```\n\n3. **Update `mesh_list` tool to accept `callerNamespace`:**\n\nUpdate the tool definition parameters:\n```typescript\ntool(\n  'mesh_list',\n  'List all registered agents with optional filters. Use callerNamespace to see only agents visible from a specific namespace.',\n  {\n    runtime: z.string().optional().describe('Filter by runtime'),\n    capability: z.string().optional().describe('Filter by capability'),\n    callerNamespace: z.string().optional().describe('Filter by caller namespace (invisible boundary filtering)'),\n  },\n  createMeshListHandler(deps),\n),\n```\n\nUpdate the handler to pass `callerNamespace`:\n```typescript\nfunction createMeshListHandler(deps: McpToolDeps) {\n  return async function handleMeshList(args: { runtime?: string; capability?: string; callerNamespace?: string }) {\n    if (!deps.meshCore) {\n      return {\n        content: [{ type: 'text' as const, text: JSON.stringify({ error: 'Mesh is not enabled' }) }],\n      };\n    }\n    try {\n      const agents = deps.meshCore.list({\n        runtime: args.runtime as AgentRuntime | undefined,\n        capability: args.capability,\n        callerNamespace: args.callerNamespace,\n      });\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({ agents, count: agents.length }, null, 2),\n          },\n        ],\n      };\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: JSON.stringify({\n              error: err instanceof Error ? err.message : 'Failed to list agents',\n            }),\n          },\n        ],\n      };\n    }\n  };\n}\n```\n\n**Tests: Update `apps/server/src/services/core/__tests__/mcp-mesh-tools.test.ts`** (or create if needed)\n\nTests:\n- `mesh_query_topology` without namespace returns full topology\n- `mesh_query_topology` with namespace returns filtered view\n- `mesh_query_topology` returns error when mesh is disabled\n- `mesh_list` with callerNamespace passes it through to `meshCore.list()`\n- `mesh_list` without callerNamespace returns all agents (backward compat)\n\nAcceptance criteria:\n- `mesh_query_topology` tool registered in MCP server\n- `mesh_list` updated with `callerNamespace` parameter\n- Handler follows existing pattern (error handling, JSON response format)\n- Tests pass: `npx vitest run apps/server/src/services/core/__tests__/mcp-mesh-tools.test.ts`",
      "activeForm": "Adding mesh topology MCP tool",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["2.3"],
      "parallelWith": ["3.1"]
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Client UI",
      "subject": "[mesh-network-topology] [P4] Create use-mesh-topology and use-mesh-access entity hooks",
      "description": "Create two new TanStack Query hooks for the mesh entity layer to fetch topology data and manage access rules.\n\n**File: `apps/client/src/layers/entities/mesh/model/use-mesh-topology.ts`**\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport type { TopologyView } from '@dorkos/shared/mesh-schemas';\n\n/**\n * Fetch the mesh network topology, optionally filtered by caller namespace.\n *\n * @param namespace - Caller namespace for filtered view, omit for admin view\n * @param enabled - Whether the query is enabled (default: true)\n */\nexport function useTopology(namespace?: string, enabled = true) {\n  const transport = useTransport();\n  return useQuery<TopologyView>({\n    queryKey: ['mesh', 'topology', namespace ?? '*'],\n    queryFn: async () => {\n      const params = namespace ? `?namespace=${encodeURIComponent(namespace)}` : '';\n      const response = await transport.get(`/api/mesh/topology${params}`);\n      return response as TopologyView;\n    },\n    enabled,\n  });\n}\n```\n\n**File: `apps/client/src/layers/entities/mesh/model/use-mesh-access.ts`**\n\n```typescript\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n/**\n * Mutation to update a cross-namespace access rule.\n */\nexport function useUpdateAccessRule() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (rule: { sourceNamespace: string; targetNamespace: string; action: 'allow' | 'deny' }) => {\n      return transport.put('/api/mesh/topology/access', rule);\n    },\n    onSuccess: () => {\n      // Invalidate topology queries to refresh the view\n      void queryClient.invalidateQueries({ queryKey: ['mesh', 'topology'] });\n    },\n  });\n}\n\n/**\n * Fetch which agents a specific agent can reach.\n *\n * @param agentId - The agent's ULID\n */\nexport function useAgentAccess(agentId: string) {\n  const transport = useTransport();\n  return useQuery<{ agents: AgentManifest[] }>({\n    queryKey: ['mesh', 'agents', agentId, 'access'],\n    queryFn: async () => {\n      const response = await transport.get(`/api/mesh/agents/${agentId}/access`);\n      return response as { agents: AgentManifest[] };\n    },\n    enabled: !!agentId,\n  });\n}\n```\n\n**Update barrel export: `apps/client/src/layers/entities/mesh/index.ts`**\n\nAdd these exports:\n```typescript\nexport { useTopology } from './model/use-mesh-topology';\nexport { useUpdateAccessRule, useAgentAccess } from './model/use-mesh-access';\n```\n\nAcceptance criteria:\n- `useTopology()` hook fetches from `/api/mesh/topology` with optional namespace param\n- `useUpdateAccessRule()` mutation calls `PUT /api/mesh/topology/access` and invalidates topology queries\n- `useAgentAccess()` hook fetches from `/api/mesh/agents/:id/access`\n- All hooks use `useTransport()` for the Transport interface\n- Exported from entities/mesh barrel\n- Follow existing hook patterns (see `use-mesh-agents.ts`, `use-mesh-discover.ts` for reference)",
      "activeForm": "Creating topology entity hooks",
      "size": "small",
      "priority": "medium",
      "dependencies": ["3.1"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Client UI",
      "subject": "[mesh-network-topology] [P4] Create TopologyPanel component and integrate as fourth MeshPanel tab",
      "description": "Create the `TopologyPanel` component and add it as the fourth tab in `MeshPanel`.\n\n**File: `apps/client/src/layers/features/mesh/ui/TopologyPanel.tsx`**\n\n```typescript\nimport { useState } from 'react';\nimport { ChevronDown, ChevronRight, Plus, Trash2, Loader2, Shield } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { useTopology, useUpdateAccessRule } from '@/layers/entities/mesh';\nimport type { NamespaceInfo, CrossNamespaceRule, AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n// -- Namespace Group --\n\ninterface NamespaceGroupProps {\n  info: NamespaceInfo;\n}\n\nfunction NamespaceGroup({ info }: NamespaceGroupProps) {\n  const [expanded, setExpanded] = useState(false);\n\n  return (\n    <div className=\"rounded-xl border\">\n      <button\n        type=\"button\"\n        onClick={() => setExpanded(!expanded)}\n        className=\"flex w-full items-center justify-between px-4 py-3 text-left hover:bg-muted/50\"\n      >\n        <div className=\"flex items-center gap-2\">\n          {expanded ? <ChevronDown className=\"size-4\" /> : <ChevronRight className=\"size-4\" />}\n          <span className=\"font-medium text-sm\">{info.namespace || '(default)'}</span>\n          <Badge variant=\"secondary\" className=\"text-xs\">\n            {info.agentCount} agent{info.agentCount !== 1 ? 's' : ''}\n          </Badge>\n        </div>\n      </button>\n      {expanded && (\n        <div className=\"border-t px-4 py-2 space-y-2\">\n          {info.agents.map((agent: AgentManifest) => (\n            <div key={agent.id} className=\"flex items-center justify-between py-1\">\n              <div className=\"flex items-center gap-2\">\n                <span className=\"text-sm\">{agent.name}</span>\n                <Badge variant=\"outline\" className=\"text-xs\">{agent.runtime}</Badge>\n              </div>\n              {agent.budget && (\n                <span className=\"text-xs text-muted-foreground\">\n                  {agent.budget.maxCallsPerHour} calls/hr, {agent.budget.maxHopsPerMessage} hops\n                </span>\n              )}\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// -- Access Rule Row --\n\ninterface AccessRuleRowProps {\n  rule: CrossNamespaceRule;\n  onRemove: () => void;\n}\n\nfunction AccessRuleRow({ rule, onRemove }: AccessRuleRowProps) {\n  return (\n    <div className=\"flex items-center justify-between rounded-lg border px-3 py-2\">\n      <div className=\"flex items-center gap-2 text-sm\">\n        <Badge variant=\"outline\">{rule.sourceNamespace}</Badge>\n        <span className=\"text-muted-foreground\">→</span>\n        <Badge variant=\"outline\">{rule.targetNamespace}</Badge>\n        <Badge variant={rule.action === 'allow' ? 'default' : 'destructive'} className=\"text-xs\">\n          {rule.action}\n        </Badge>\n      </div>\n      <button\n        type=\"button\"\n        onClick={onRemove}\n        className=\"rounded p-1 text-muted-foreground hover:bg-destructive/10 hover:text-destructive\"\n        aria-label={`Remove rule ${rule.sourceNamespace} → ${rule.targetNamespace}`}\n      >\n        <Trash2 className=\"size-3.5\" />\n      </button>\n    </div>\n  );\n}\n\n// -- Add Rule Form --\n\ninterface AddRuleFormProps {\n  namespaces: string[];\n  onAdd: (source: string, target: string) => void;\n  isPending: boolean;\n}\n\nfunction AddRuleForm({ namespaces, onAdd, isPending }: AddRuleFormProps) {\n  const [source, setSource] = useState('');\n  const [target, setTarget] = useState('');\n\n  function handleSubmit() {\n    if (source && target && source !== target) {\n      onAdd(source, target);\n      setSource('');\n      setTarget('');\n    }\n  }\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      <select\n        value={source}\n        onChange={(e) => setSource(e.target.value)}\n        className=\"flex-1 rounded-md border bg-transparent px-2 py-1.5 text-sm\"\n      >\n        <option value=\"\">Source namespace</option>\n        {namespaces.map((ns) => (\n          <option key={ns} value={ns}>{ns}</option>\n        ))}\n      </select>\n      <span className=\"text-muted-foreground\">→</span>\n      <select\n        value={target}\n        onChange={(e) => setTarget(e.target.value)}\n        className=\"flex-1 rounded-md border bg-transparent px-2 py-1.5 text-sm\"\n      >\n        <option value=\"\">Target namespace</option>\n        {namespaces.map((ns) => (\n          <option key={ns} value={ns}>{ns}</option>\n        ))}\n      </select>\n      <button\n        type=\"button\"\n        onClick={handleSubmit}\n        disabled={!source || !target || source === target || isPending}\n        className=\"inline-flex items-center gap-1 rounded-md bg-primary px-3 py-1.5 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-50\"\n      >\n        {isPending ? <Loader2 className=\"size-3.5 animate-spin\" /> : <Plus className=\"size-3.5\" />}\n        Allow\n      </button>\n    </div>\n  );\n}\n\n// -- Main Panel --\n\n/** Topology panel — namespace groups, cross-namespace rules, and per-agent budget display. */\nexport function TopologyPanel() {\n  const { data: topology, isLoading } = useTopology();\n  const { mutate: updateRule, isPending } = useUpdateAccessRule();\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center p-8\">\n        <Loader2 className=\"size-5 animate-spin text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  if (!topology || topology.namespaces.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-3 p-8 text-center\">\n        <Shield className=\"size-8 text-muted-foreground/50\" />\n        <div>\n          <p className=\"font-medium\">No namespaces</p>\n          <p className=\"mt-1 text-sm text-muted-foreground\">\n            Register agents to see their namespace topology.\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  const allNamespaces = topology.namespaces.map((ns) => ns.namespace);\n\n  return (\n    <div className=\"space-y-6 p-4\">\n      {/* Namespace Groups */}\n      <section>\n        <h3 className=\"mb-2 text-sm font-medium text-muted-foreground\">Namespaces</h3>\n        <div className=\"space-y-2\">\n          {topology.namespaces.map((ns) => (\n            <NamespaceGroup key={ns.namespace} info={ns} />\n          ))}\n        </div>\n      </section>\n\n      {/* Cross-Namespace Rules */}\n      <section>\n        <h3 className=\"mb-2 text-sm font-medium text-muted-foreground\">Cross-Project Access Rules</h3>\n        <div className=\"space-y-2\">\n          {topology.accessRules.length === 0 && (\n            <p className=\"text-sm text-muted-foreground\">\n              No cross-project rules. Namespaces are isolated by default.\n            </p>\n          )}\n          {topology.accessRules.map((rule) => (\n            <AccessRuleRow\n              key={`${rule.sourceNamespace}-${rule.targetNamespace}`}\n              rule={rule}\n              onRemove={() => updateRule({\n                sourceNamespace: rule.sourceNamespace,\n                targetNamespace: rule.targetNamespace,\n                action: 'deny',\n              })}\n            />\n          ))}\n          <AddRuleForm\n            namespaces={allNamespaces}\n            onAdd={(source, target) => updateRule({ sourceNamespace: source, targetNamespace: target, action: 'allow' })}\n            isPending={isPending}\n          />\n        </div>\n      </section>\n    </div>\n  );\n}\n```\n\n**Update MeshPanel to add fourth tab: `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx`**\n\nAdd import at top:\n```typescript\nimport { TopologyPanel } from './TopologyPanel';\n```\n\nAdd the fourth tab trigger and content in the existing Tabs component:\n```typescript\n// In TabsList, add after \"denied\" trigger:\n<TabsTrigger value=\"topology\">Topology</TabsTrigger>\n\n// After the \"denied\" TabsContent, add:\n<TabsContent value=\"topology\" className=\"min-h-0 flex-1 overflow-y-auto\">\n  <TopologyPanel />\n</TabsContent>\n```\n\n**Tests: `apps/client/src/layers/features/mesh/ui/__tests__/TopologyPanel.test.tsx`**\n\n```\n/**\n * @vitest-environment jsdom\n */\n```\n\nTests to write:\n- Renders loading state with spinner\n- Renders empty state when no namespaces\n- Renders namespace groups with agent counts\n- Expanding a namespace group shows agent details\n- Renders cross-namespace rule table\n- Add rule form submits correct payload via useUpdateAccessRule mutation\n- Remove rule button calls mutation with action: 'deny'\n- Budget display shows maxCallsPerHour and maxHopsPerMessage\n\nMock `useTopology` and `useUpdateAccessRule` hooks for testing. Use `@testing-library/react` patterns.\n\nAcceptance criteria:\n- `TopologyPanel` component renders namespace groups, access rules, and add rule form\n- MeshPanel has four tabs: Discovery, Agents, Denied, Topology\n- Cross-namespace rules can be added and removed from the UI\n- Per-agent budget displayed as read-only\n- Disabled/empty states handled\n- Tests pass: `npx vitest run apps/client/src/layers/features/mesh/ui/__tests__/TopologyPanel.test.tsx`\n- Follows FSD layer rules (only imports from entities and shared layers)\n- Follows Calm Tech design system (rounded-xl cards, consistent spacing)",
      "activeForm": "Creating TopologyPanel component and MeshPanel tab",
      "size": "large",
      "priority": "medium",
      "dependencies": ["4.1"],
      "parallelWith": []
    }
  ]
}
