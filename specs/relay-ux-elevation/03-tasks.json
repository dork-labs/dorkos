{
  "spec": "specs/relay-ux-elevation/02-specification.md",
  "slug": "relay-ux-elevation",
  "generatedAt": "2026-02-27T20:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Add listRelayDeadLetters to Transport interface and adapters",
      "description": "Add the `listRelayDeadLetters()` method to the Transport interface and both transport adapters (HttpTransport and DirectTransport). The server already has `GET /api/relay/dead-letters` endpoint in `apps/server/src/routes/relay.ts` that calls `relayCore.getDeadLetters()`, so no server changes are needed.\n\n## Files to modify\n\n### 1. `packages/shared/src/transport.ts`\n\nAdd to the `Transport` interface in the `// --- Relay Message Bus ---` section, after `getRelayMetrics()`:\n\n```typescript\n/** List dead-letter messages with optional filters. */\nlistRelayDeadLetters(filters?: { endpointHash?: string }): Promise<unknown[]>;\n```\n\n### 2. `apps/client/src/layers/shared/lib/http-transport.ts`\n\nAdd the implementation in the Relay Message Bus section. Follow the same pattern as `listRelayMessages()`:\n\n```typescript\nasync listRelayDeadLetters(filters?: { endpointHash?: string }): Promise<unknown[]> {\n  const params = new URLSearchParams();\n  if (filters?.endpointHash) params.set('endpointHash', filters.endpointHash);\n  const query = params.toString();\n  const res = await fetch(`${this.baseUrl}/api/relay/dead-letters${query ? `?${query}` : ''}`);\n  if (!res.ok) throw new Error(`Failed to fetch dead letters: ${res.status}`);\n  return res.json();\n}\n```\n\n### 3. `apps/client/src/layers/shared/lib/direct-transport.ts`\n\nAdd stub implementation in the Relay section (Relay is not supported in embedded/Obsidian mode):\n\n```typescript\nasync listRelayDeadLetters(): Promise<unknown[]> {\n  return [];\n}\n```\n\n## Acceptance criteria\n\n- `Transport` interface includes `listRelayDeadLetters` method\n- `HttpTransport` calls `GET /api/relay/dead-letters` with optional `endpointHash` query parameter\n- `DirectTransport` returns empty array (consistent with other relay stubs)\n- TypeScript compiles without errors: `pnpm typecheck`\n- Existing tests pass: `pnpm test -- --run`",
      "activeForm": "Adding listRelayDeadLetters to Transport interface",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Create useDeadLetters entity hook",
      "description": "Create a new TanStack Query hook in the relay entity layer for fetching dead-letter messages. This hook will be consumed by the `DeadLetterSection` component and the `RelayHealthBar` component.\n\n## New file: `apps/client/src/layers/entities/relay/model/use-dead-letters.ts`\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\nconst DEAD_LETTERS_KEY = ['relay', 'dead-letters'] as const;\n\n/**\n * Fetch relay dead-letter messages.\n *\n * @param enabled - When false, the query is skipped (Relay feature gate).\n */\nexport function useDeadLetters(enabled: boolean) {\n  const transport = useTransport();\n\n  return useQuery({\n    queryKey: [...DEAD_LETTERS_KEY],\n    queryFn: () => transport.listRelayDeadLetters(),\n    enabled,\n    refetchInterval: 30_000,\n  });\n}\n```\n\n## Modify: `apps/client/src/layers/entities/relay/index.ts`\n\nAdd the export to the barrel file:\n\n```typescript\nexport { useDeadLetters } from './model/use-dead-letters';\n```\n\n## Unit test: `apps/client/src/layers/entities/relay/__tests__/use-dead-letters.test.ts`\n\n```typescript\nimport { describe, it, expect, vi } from 'vitest';\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { useDeadLetters } from '../model/use-dead-letters';\n\nfunction createWrapper() {\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { retry: false } },\n  });\n  const transport = createMockTransport();\n  return {\n    transport,\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <QueryClientProvider client={queryClient}>\n        <TransportProvider transport={transport}>{children}</TransportProvider>\n      </QueryClientProvider>\n    ),\n  };\n}\n\ndescribe('useDeadLetters', () => {\n  it('returns dead letters when enabled', async () => {\n    const { transport, wrapper } = createWrapper();\n    const mockLetters = [{ id: 'dl-1', subject: 'test', reason: 'hop_limit' }];\n    vi.mocked(transport.listRelayDeadLetters).mockResolvedValue(mockLetters);\n\n    const { result } = renderHook(() => useDeadLetters(true), { wrapper });\n\n    await waitFor(() => {\n      expect(result.current.data).toEqual(mockLetters);\n    });\n    expect(transport.listRelayDeadLetters).toHaveBeenCalled();\n  });\n\n  it('does not fetch when disabled', () => {\n    const { transport, wrapper } = createWrapper();\n    renderHook(() => useDeadLetters(false), { wrapper });\n    expect(transport.listRelayDeadLetters).not.toHaveBeenCalled();\n  });\n});\n```\n\n## Acceptance criteria\n\n- Hook uses query key `['relay', 'dead-letters']`\n- Respects `enabled` flag (does not fetch when false)\n- Polls every 30 seconds (`refetchInterval: 30_000`)\n- Exported from relay entity barrel\n- Unit tests pass",
      "activeForm": "Creating useDeadLetters entity hook",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Create RelayHealthBar component",
      "description": "Create a compact, always-visible health summary bar that sits above the tab list in `RelayPanel`, following the `MeshStatsHeader` pattern from `apps/client/src/layers/features/mesh/ui/MeshStatsHeader.tsx`.\n\n## New file: `apps/client/src/layers/features/relay/ui/RelayHealthBar.tsx`\n\n```tsx\nimport { BarChart3 } from 'lucide-react';\nimport { useState } from 'react';\nimport { useAdapterCatalog, useDeliveryMetrics } from '@/layers/entities/relay';\nimport { Button } from '@/layers/shared/ui';\nimport { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from '@/layers/shared/ui';\nimport { DeliveryMetricsDashboard } from './DeliveryMetrics';\n\ninterface RelayHealthBarProps {\n  enabled?: boolean;\n  onFailedClick?: () => void;\n}\n\n/**\n * Compact aggregate Relay health bar showing adapter status, message throughput,\n * failure count, and average latency. Follows the MeshStatsHeader pattern.\n */\nexport function RelayHealthBar({ enabled = true, onFailedClick }: RelayHealthBarProps) {\n  const { data: catalog = [] } = useAdapterCatalog(enabled);\n  const { data: metrics, isLoading } = useDeliveryMetrics();\n  const [sheetOpen, setSheetOpen] = useState(false);\n\n  if (!enabled || isLoading || !metrics) return null;\n\n  // Calculate adapter connectivity\n  const allInstances = catalog.flatMap((entry) => entry.instances);\n  const connectedCount = allInstances.filter((inst) => inst.status.state === 'connected').length;\n  const totalAdapters = allInstances.length;\n  const allConnected = totalAdapters > 0 && connectedCount === totalAdapters;\n\n  const failedCount = metrics.failedCount ?? 0;\n  const hasFailed = failedCount > 0;\n  const avgLatency = metrics.avgDeliveryLatencyMs;\n\n  return (\n    <div className=\"flex items-center gap-3 border-b px-3 py-1.5 text-xs text-muted-foreground\">\n      {/* Adapter status */}\n      {totalAdapters > 0 && (\n        <span className=\"flex items-center gap-1\">\n          <span\n            className={`h-2 w-2 rounded-full ${allConnected ? 'bg-green-500' : 'bg-amber-500'}`}\n            aria-hidden=\"true\"\n          />\n          {connectedCount}/{totalAdapters} connected\n        </span>\n      )}\n\n      {/* Throughput */}\n      <span>{metrics.totalMessages} today</span>\n\n      {/* Failures */}\n      {hasFailed ? (\n        <button\n          type=\"button\"\n          onClick={onFailedClick}\n          className=\"flex items-center gap-1 text-red-500 hover:underline\"\n        >\n          <span className=\"h-2 w-2 rounded-full bg-red-500\" aria-hidden=\"true\" />\n          {failedCount} failed\n        </button>\n      ) : (\n        <span className=\"flex items-center gap-1\">\n          <span className=\"h-2 w-2 rounded-full bg-green-500\" aria-hidden=\"true\" />\n          0 failed\n        </span>\n      )}\n\n      {/* Avg latency (hidden if null) */}\n      {avgLatency != null && <span>{Math.round(avgLatency)}ms</span>}\n\n      {/* Spacer + Metrics button */}\n      <div className=\"ml-auto\">\n        <Sheet open={sheetOpen} onOpenChange={setSheetOpen}>\n          <SheetTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"size-6 p-0\"\n              aria-label=\"Open delivery metrics\"\n            >\n              <BarChart3 className=\"size-3.5\" />\n            </Button>\n          </SheetTrigger>\n          <SheetContent>\n            <SheetHeader>\n              <SheetTitle>Delivery Metrics</SheetTitle>\n            </SheetHeader>\n            <DeliveryMetricsDashboard />\n          </SheetContent>\n        </Sheet>\n      </div>\n    </div>\n  );\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/index.ts`\n\nAdd the export:\n\n```typescript\nexport { RelayHealthBar } from './ui/RelayHealthBar';\n```\n\n## Unit test: `apps/client/src/layers/features/relay/__tests__/RelayHealthBar.test.tsx`\n\nTest rendering with various data states:\n\n```tsx\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { RelayHealthBar } from '../ui/RelayHealthBar';\n\nvi.mock('motion/react', () => ({\n  motion: { div: 'div', span: 'span' },\n  AnimatePresence: ({ children }: { children: React.ReactNode }) => children,\n}));\n\nvi.mock('@/layers/entities/relay', () => ({\n  useAdapterCatalog: vi.fn().mockReturnValue({\n    data: [{\n      manifest: { type: 'claude-code' },\n      instances: [\n        { id: 'cc-1', status: { state: 'connected' }, enabled: true },\n        { id: 'wh-1', status: { state: 'connected' }, enabled: true },\n      ],\n    }],\n  }),\n  useDeliveryMetrics: vi.fn().mockReturnValue({\n    data: {\n      totalMessages: 142,\n      failedCount: 0,\n      avgDeliveryLatencyMs: 45,\n    },\n    isLoading: false,\n  }),\n}));\n\nfunction wrapper({ children }: { children: React.ReactNode }) {\n  const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });\n  return (\n    <QueryClientProvider client={qc}>\n      <TransportProvider transport={createMockTransport()}>\n        {children}\n      </TransportProvider>\n    </QueryClientProvider>\n  );\n}\n\ndescribe('RelayHealthBar', () => {\n  it('renders adapter status, throughput, and latency', () => {\n    render(<RelayHealthBar />, { wrapper });\n    expect(screen.getByText('2/2 connected')).toBeInTheDocument();\n    expect(screen.getByText('142 today')).toBeInTheDocument();\n    expect(screen.getByText('0 failed')).toBeInTheDocument();\n    expect(screen.getByText('45ms')).toBeInTheDocument();\n  });\n\n  it('renders null when not enabled', () => {\n    const { container } = render(<RelayHealthBar enabled={false} />, { wrapper });\n    expect(container.firstChild).toBeNull();\n  });\n\n  it('fires onFailedClick when failed count is clicked', async () => {\n    const { useDeliveryMetrics } = await import('@/layers/entities/relay');\n    vi.mocked(useDeliveryMetrics).mockReturnValue({\n      data: { totalMessages: 100, failedCount: 3, avgDeliveryLatencyMs: 50 },\n      isLoading: false,\n    } as ReturnType<typeof useDeliveryMetrics>);\n\n    const onClick = vi.fn();\n    render(<RelayHealthBar onFailedClick={onClick} />, { wrapper });\n    await userEvent.setup().click(screen.getByText('3 failed'));\n    expect(onClick).toHaveBeenCalled();\n  });\n});\n```\n\n## Acceptance criteria\n\n- Health bar renders adapter count (e.g., \"3/3 connected\") with green/amber dot\n- Shows total message count (e.g., \"142 today\")\n- Shows failure count with red styling and clickable behavior when > 0\n- Shows average latency (hidden when null)\n- BarChart3 icon button opens a Sheet containing `DeliveryMetricsDashboard`\n- Follows MeshStatsHeader styling: `flex items-center gap-3 border-b px-3 py-1.5 text-xs text-muted-foreground`\n- Returns null when `enabled` is false, loading, or no metrics data\n- Unit tests pass",
      "activeForm": "Creating RelayHealthBar component",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Create DeadLetterSection component",
      "description": "Create a collapsible section that appears at the top of `ActivityFeed` showing failed/dead-letter messages. The section is hidden when the dead letter count is 0.\n\n## New file: `apps/client/src/layers/features/relay/ui/DeadLetterSection.tsx`\n\n```tsx\nimport { useState } from 'react';\nimport { ChevronDown, ChevronRight, AlertTriangle } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui';\nimport { useDeadLetters } from '@/layers/entities/relay';\nimport { cn } from '@/layers/shared/lib';\n\ninterface DeadLetterSectionProps {\n  enabled: boolean;\n}\n\nconst REASON_COLORS: Record<string, string> = {\n  hop_limit: 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200',\n  ttl_expired: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200',\n  cycle_detected: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200',\n  budget_exhausted: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200',\n};\n\nfunction formatTimeAgo(dateStr: string): string {\n  const diff = Date.now() - new Date(dateStr).getTime();\n  const seconds = Math.floor(diff / 1000);\n  if (seconds < 60) return `${seconds}s ago`;\n  const minutes = Math.floor(seconds / 60);\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  return `${Math.floor(hours / 24)}d ago`;\n}\n\n/** Collapsible section displaying dead-letter messages with rejection reasons. */\nexport function DeadLetterSection({ enabled }: DeadLetterSectionProps) {\n  const { data: deadLetters = [] } = useDeadLetters(enabled);\n  const [expanded, setExpanded] = useState(true);\n\n  if (deadLetters.length === 0) return null;\n\n  return (\n    <div className=\"mb-3\">\n      <button\n        type=\"button\"\n        onClick={() => setExpanded(!expanded)}\n        className=\"flex w-full items-center gap-2 rounded-lg border border-red-200 bg-red-50/50 px-3 py-2 text-left dark:border-red-900 dark:bg-red-950/30\"\n      >\n        <AlertTriangle className=\"size-4 shrink-0 text-red-500\" />\n        {expanded ? (\n          <ChevronDown className=\"size-3.5 shrink-0 text-muted-foreground\" />\n        ) : (\n          <ChevronRight className=\"size-3.5 shrink-0 text-muted-foreground\" />\n        )}\n        <span className=\"text-sm font-medium\">Failed Messages</span>\n        <Badge variant=\"destructive\" className=\"ml-1\">\n          {deadLetters.length}\n        </Badge>\n      </button>\n\n      {expanded && (\n        <div className=\"mt-2 space-y-1\">\n          {deadLetters.map((dl) => {\n            const letter = dl as Record<string, unknown>;\n            const reason = (letter.reason as string) ?? 'unknown';\n            const reasonStyle = REASON_COLORS[reason] ?? 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200';\n\n            return (\n              <div\n                key={(letter.id as string) ?? (letter.messageId as string)}\n                className=\"rounded-lg border border-l-2 border-l-red-500 p-3\"\n              >\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"min-w-0 flex-1 truncate font-mono text-sm\">\n                    {letter.subject as string}\n                  </span>\n                  <Badge variant=\"outline\" className={cn('shrink-0 text-xs', reasonStyle)}>\n                    {reason.replace('_', ' ')}\n                  </Badge>\n                </div>\n                <div className=\"mt-1 flex gap-3 text-xs text-muted-foreground\">\n                  <span>From: {letter.from as string}</span>\n                  {letter.createdAt && <span>{formatTimeAgo(letter.createdAt as string)}</span>}\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Unit test: `apps/client/src/layers/features/relay/__tests__/DeadLetterSection.test.tsx`\n\n```tsx\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport { DeadLetterSection } from '../ui/DeadLetterSection';\n\nconst mockDeadLetters = [\n  { id: 'dl-1', subject: 'relay.agent.test', from: 'system', reason: 'hop_limit', createdAt: new Date().toISOString() },\n  { id: 'dl-2', subject: 'relay.webhook.ping', from: 'webhook', reason: 'ttl_expired', createdAt: new Date().toISOString() },\n];\n\nvi.mock('@/layers/entities/relay', () => ({\n  useDeadLetters: vi.fn().mockReturnValue({ data: [] }),\n}));\n\nfunction wrapper({ children }: { children: React.ReactNode }) {\n  return <>{children}</>;\n}\n\ndescribe('DeadLetterSection', () => {\n  it('renders nothing when no dead letters', () => {\n    const { container } = render(<DeadLetterSection enabled={true} />, { wrapper });\n    expect(container.firstChild).toBeNull();\n  });\n\n  it('renders header with count badge when dead letters exist', async () => {\n    const { useDeadLetters } = await import('@/layers/entities/relay');\n    vi.mocked(useDeadLetters).mockReturnValue({ data: mockDeadLetters } as any);\n\n    render(<DeadLetterSection enabled={true} />, { wrapper });\n    expect(screen.getByText('Failed Messages')).toBeInTheDocument();\n    expect(screen.getByText('2')).toBeInTheDocument();\n  });\n\n  it('displays rejection reason badges', async () => {\n    const { useDeadLetters } = await import('@/layers/entities/relay');\n    vi.mocked(useDeadLetters).mockReturnValue({ data: mockDeadLetters } as any);\n\n    render(<DeadLetterSection enabled={true} />, { wrapper });\n    expect(screen.getByText('hop limit')).toBeInTheDocument();\n    expect(screen.getByText('ttl expired')).toBeInTheDocument();\n  });\n\n  it('collapses on header click', async () => {\n    const { useDeadLetters } = await import('@/layers/entities/relay');\n    vi.mocked(useDeadLetters).mockReturnValue({ data: mockDeadLetters } as any);\n\n    render(<DeadLetterSection enabled={true} />, { wrapper });\n    expect(screen.getByText('relay.agent.test')).toBeInTheDocument();\n\n    await userEvent.setup().click(screen.getByText('Failed Messages'));\n    expect(screen.queryByText('relay.agent.test')).not.toBeInTheDocument();\n  });\n});\n```\n\n## Acceptance criteria\n\n- Hidden when dead letter count is 0 (returns null)\n- Shows header with \"Failed Messages\" text and red Badge count\n- Collapsible via header click (expanded by default)\n- Each dead letter row shows: subject (monospace), from, timestamp, rejection reason badge\n- Red 2px left border on each dead letter row (`border-l-2 border-l-red-500`)\n- Rejection reason badges use colored styling: `hop_limit` (amber), `ttl_expired` (orange), `cycle_detected` (red), `budget_exhausted` (purple)\n- Unit tests pass",
      "activeForm": "Creating DeadLetterSection component",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": []
    },
    {
      "id": "1.5",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Wire MessageTrace into MessageRow with expand/collapse",
      "description": "Connect the existing `MessageTrace` component (currently orphaned at `apps/client/src/layers/features/relay/ui/MessageTrace.tsx`) to `MessageRow` so users can view delivery traces inline. Add an Activity icon button in the message row that toggles the trace timeline below the message details.\n\n## Modify: `apps/client/src/layers/features/relay/ui/MessageRow.tsx`\n\nThe current `MessageRow` component is a simple button with expand/collapse for payload. Add a trace toggle that only fetches trace data when expanded.\n\n```tsx\nimport { useState } from 'react';\nimport { Clock, Check, AlertTriangle, MailX, Activity } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui';\nimport { cn } from '@/layers/shared/lib';\nimport { MessageTrace } from './MessageTrace';\n\ninterface MessageRowProps {\n  message: Record<string, unknown>;\n}\n\nconst STATUS_CONFIG: Record<string, { icon: React.ElementType; className: string; label: string }> = {\n  new: { icon: Clock, className: 'text-muted-foreground', label: 'New' },\n  cur: { icon: Check, className: 'text-muted-foreground', label: 'Delivered' },\n  failed: { icon: AlertTriangle, className: 'text-destructive', label: 'Failed' },\n  dead_letter: { icon: MailX, className: 'text-amber-500', label: 'Dead Letter' },\n};\n\nfunction formatTimeAgo(dateStr: string): string {\n  const diff = Date.now() - new Date(dateStr).getTime();\n  const seconds = Math.floor(diff / 1000);\n  if (seconds < 60) return `${seconds}s ago`;\n  const minutes = Math.floor(seconds / 60);\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  return `${Math.floor(hours / 24)}d ago`;\n}\n\n/** Compact/expanded message card with status indicators, payload view, and trace toggle. */\nexport function MessageRow({ message }: MessageRowProps) {\n  const [expanded, setExpanded] = useState(false);\n  const [showTrace, setShowTrace] = useState(false);\n  const status = (message.status as string) ?? 'new';\n  const config = STATUS_CONFIG[status] ?? STATUS_CONFIG.new;\n  const StatusIcon = config.icon;\n  const messageId = message.id as string;\n\n  return (\n    <div\n      className={cn(\n        'w-full rounded-lg border text-left transition-colors hover:bg-muted/50',\n        expanded && 'bg-muted/30',\n      )}\n    >\n      <button\n        type=\"button\"\n        onClick={() => setExpanded(!expanded)}\n        className=\"w-full p-3\"\n      >\n        <div className=\"flex items-center gap-2\">\n          <StatusIcon className={cn('size-4 shrink-0', config.className)} />\n          <span className=\"min-w-0 flex-1 truncate font-mono text-sm\">\n            {message.subject as string}\n          </span>\n          <span className=\"shrink-0 text-xs text-muted-foreground\">\n            {message.from as string}\n          </span>\n          <span className=\"shrink-0 text-xs text-muted-foreground\">\n            {message.createdAt ? formatTimeAgo(message.createdAt as string) : ''}\n          </span>\n          <Badge variant=\"outline\" className=\"shrink-0 text-xs\">\n            {config.label}\n          </Badge>\n        </div>\n      </button>\n\n      {expanded && (\n        <div className=\"space-y-2 border-t px-3 pb-3 pt-3\">\n          <div>\n            <span className=\"text-xs font-medium text-muted-foreground\">Payload</span>\n            <pre className=\"mt-1 max-h-40 overflow-auto rounded bg-muted p-2 font-mono text-xs\">\n              {String(JSON.stringify(message.payload, null, 2))}\n            </pre>\n          </div>\n          {message.budget != null && (\n            <div>\n              <span className=\"text-xs font-medium text-muted-foreground\">Budget</span>\n              <pre className=\"mt-1 rounded bg-muted p-2 font-mono text-xs\">\n                {String(JSON.stringify(message.budget, null, 2))}\n              </pre>\n            </div>\n          )}\n\n          {/* Trace toggle button */}\n          {messageId && (\n            <div className=\"border-t pt-2\">\n              <button\n                type=\"button\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  setShowTrace(!showTrace);\n                }}\n                className=\"flex items-center gap-1.5 text-xs text-muted-foreground hover:text-foreground\"\n              >\n                <Activity className=\"size-3.5\" />\n                {showTrace ? 'Hide trace' : 'Show trace'}\n              </button>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Trace section — only renders (and fetches) when toggled */}\n      {showTrace && messageId && (\n        <div className=\"border-t\">\n          <MessageTrace messageId={messageId} onClose={() => setShowTrace(false)} />\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\nKey changes from the original:\n- The outer element changes from `<button>` to `<div>` since we now have nested interactive elements (trace toggle).\n- The main click handler is on an inner `<button>` for the expand/collapse area.\n- New `showTrace` state controls whether `MessageTrace` is rendered.\n- The `Activity` icon button uses `e.stopPropagation()` to prevent toggling expand/collapse.\n- `MessageTrace` only mounts (and thus only fetches via `useMessageTrace`) when `showTrace` is true.\n\n## Acceptance criteria\n\n- Activity icon button appears in expanded message view\n- Clicking the Activity button toggles `MessageTrace` inline below the message\n- `MessageTrace` only fetches trace data when visible (lazy loading)\n- Clicking \"Hide trace\" or the `onClose` callback hides the trace section\n- Existing expand/collapse for payload still works\n- The trace toggle does not interfere with payload expand/collapse clicks",
      "activeForm": "Wiring MessageTrace into MessageRow",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "1.6",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[relay-ux-elevation] [P1] Update RelayPanel layout with health bar and dead letters",
      "description": "Update `RelayPanel.tsx` to mount the `RelayHealthBar` above tabs, and integrate `DeadLetterSection` into `ActivityFeed`. This is the integration task that brings the foundation components together.\n\n## Modify: `apps/client/src/layers/features/relay/ui/RelayPanel.tsx`\n\nAdd `RelayHealthBar` above the `<Tabs>` component. Add a `ref` for dead letter scroll target and a callback for the health bar's failed click.\n\n```tsx\nimport { useState, useRef, useCallback } from 'react';\nimport { RefreshCw, Route } from 'lucide-react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { Tabs, TabsList, TabsTrigger, TabsContent, FeatureDisabledState, Skeleton, Button } from '@/layers/shared/ui';\nimport {\n  useRelayEnabled,\n  useRelayEventStream,\n  useAdapterCatalog,\n  useToggleAdapter,\n  useRemoveAdapter,\n} from '@/layers/entities/relay';\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\nimport { ActivityFeed } from './ActivityFeed';\nimport { EndpointList } from './EndpointList';\nimport { InboxView } from './InboxView';\nimport { AdapterCard } from './AdapterCard';\nimport { CatalogCard } from './CatalogCard';\nimport { AdapterSetupWizard } from './AdapterSetupWizard';\nimport { RelayHealthBar } from './RelayHealthBar';\n\n// ... (AdaptersTab stays the same)\n\nexport function RelayPanel() {\n  const relayEnabled = useRelayEnabled();\n  const [selectedEndpoint, setSelectedEndpoint] = useState<string | null>(null);\n  const [activeTab, setActiveTab] = useState('activity');\n  const deadLetterRef = useRef<HTMLDivElement>(null);\n\n  useRelayEventStream(relayEnabled);\n\n  const handleFailedClick = useCallback(() => {\n    // Switch to activity tab and scroll to dead letters\n    setActiveTab('activity');\n    setTimeout(() => {\n      deadLetterRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });\n    }, 100);\n  }, []);\n\n  if (!relayEnabled) {\n    return (\n      <FeatureDisabledState\n        icon={Route}\n        name=\"Relay\"\n        description=\"Relay provides inter-agent messaging. Start DorkOS with relay enabled.\"\n        command=\"DORKOS_RELAY_ENABLED=true dorkos\"\n      />\n    );\n  }\n\n  return (\n    <div className=\"flex h-full flex-col\">\n      <RelayHealthBar enabled={relayEnabled} onFailedClick={handleFailedClick} />\n      <Tabs value={activeTab} onValueChange={setActiveTab} className=\"flex min-h-0 flex-1 flex-col\">\n        <TabsList className=\"mx-4 mt-3 shrink-0\">\n          <TabsTrigger value=\"activity\">Activity</TabsTrigger>\n          <TabsTrigger value=\"endpoints\">Endpoints</TabsTrigger>\n          <TabsTrigger value=\"adapters\">Adapters</TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"activity\" className=\"min-h-0 flex-1 overflow-y-auto\">\n          <ActivityFeed enabled={relayEnabled} deadLetterRef={deadLetterRef} />\n        </TabsContent>\n\n        <TabsContent value=\"endpoints\" className=\"min-h-0 flex-1 overflow-y-auto\">\n          {selectedEndpoint ? (\n            <InboxView subject={selectedEndpoint} onBack={() => setSelectedEndpoint(null)} />\n          ) : (\n            <EndpointList enabled={relayEnabled} onSelectEndpoint={setSelectedEndpoint} />\n          )}\n        </TabsContent>\n\n        <TabsContent value=\"adapters\" className=\"min-h-0 flex-1 overflow-y-auto\">\n          <AdaptersTab enabled={relayEnabled} />\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n```\n\nKey changes:\n- Import and render `RelayHealthBar` above `<Tabs>`.\n- Wrap everything in a flex column container so the health bar sits above.\n- Change `Tabs` from `defaultValue` to controlled `value={activeTab}` to support programmatic tab switching.\n- Pass `deadLetterRef` to `ActivityFeed` (requires `ActivityFeed` to accept and place it).\n- `handleFailedClick` switches to activity tab and scrolls to dead letters.\n\n## Modify: `apps/client/src/layers/features/relay/ui/ActivityFeed.tsx`\n\nAdd `DeadLetterSection` at the top of the feed and accept a `deadLetterRef` prop:\n\n```tsx\ninterface ActivityFeedProps {\n  enabled: boolean;\n  deadLetterRef?: React.RefObject<HTMLDivElement>;\n}\n\nexport function ActivityFeed({ enabled, deadLetterRef }: ActivityFeedProps) {\n  // ... existing filter/query logic ...\n\n  return (\n    <div className=\"flex flex-col gap-3 p-4\">\n      {/* Dead letter section */}\n      <div ref={deadLetterRef}>\n        <DeadLetterSection enabled={enabled} />\n      </div>\n\n      {/* Filter bar */}\n      <div className=\"flex items-center justify-between\">\n        {/* ... existing Select ... */}\n      </div>\n\n      {/* Message list */}\n      {/* ... existing message rendering ... */}\n    </div>\n  );\n}\n```\n\nAdd the import at the top:\n```tsx\nimport { DeadLetterSection } from './DeadLetterSection';\n```\n\n## Acceptance criteria\n\n- `RelayHealthBar` renders above the tab list, visible on all tabs\n- `DeadLetterSection` renders at the top of the Activity feed\n- Clicking \"N failed\" in the health bar switches to the Activity tab and scrolls to the dead letter section\n- Tabs are now controlled to support programmatic switching\n- Layout remains a flex column filling full height\n- No visual regression to existing tab content",
      "activeForm": "Updating RelayPanel layout with health bar and dead letters",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3", "1.4"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Motion + Visual Polish",
      "subject": "[relay-ux-elevation] [P2] Add motion animations to ActivityFeed message list",
      "description": "Add motion library animations to the ActivityFeed, consistent with Mesh and Pulse panels. New SSE-delivered messages animate in, while history messages on initial load do NOT animate (prevents animation storm). Filtered-out messages get exit animations.\n\n## Modify: `apps/client/src/layers/features/relay/ui/ActivityFeed.tsx`\n\nAdd motion imports and wrap message list items:\n\n```tsx\nimport { motion, AnimatePresence } from 'motion/react';\n```\n\n### Message entrance animation\n\nTrack which messages are new (arrived via SSE after initial load) vs history messages. Use a ref to track the initial message IDs:\n\n```tsx\nimport { useState, useRef, useEffect } from 'react';\n\nexport function ActivityFeed({ enabled, deadLetterRef }: ActivityFeedProps) {\n  const [filter, setFilter] = useState<FilterValue>('all');\n  const { data, isLoading } = useRelayMessages(undefined, enabled);\n  const messages = data?.messages ?? [];\n  const initialIdsRef = useRef<Set<string> | null>(null);\n\n  // Capture initial message IDs on first load to skip animation for history\n  useEffect(() => {\n    if (messages.length > 0 && initialIdsRef.current === null) {\n      initialIdsRef.current = new Set(\n        messages.map((m) => (m as Record<string, unknown>).id as string).filter(Boolean),\n      );\n    }\n  }, [messages]);\n\n  const isNewMessage = (id: string): boolean => {\n    if (!initialIdsRef.current) return false;\n    return !initialIdsRef.current.has(id);\n  };\n\n  // ... filtering logic ...\n\n  return (\n    <div className=\"flex flex-col gap-3 p-4\">\n      {/* Dead letters + filters ... */}\n\n      <AnimatePresence mode=\"popLayout\">\n        {filteredMessages.map((msg, i) => {\n          const raw = msg as Record<string, unknown>;\n          const id = (raw.id as string) ?? String(i);\n          const shouldAnimate = isNewMessage(id);\n\n          return (\n            <motion.div\n              key={id}\n              layout\n              initial={shouldAnimate ? { opacity: 0, y: 8 } : false}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, height: 0, marginBottom: 0 }}\n              transition={{ duration: 0.2, ease: 'easeOut' }}\n            >\n              {/* existing source badge + MessageRow rendering */}\n            </motion.div>\n          );\n        })}\n      </AnimatePresence>\n    </div>\n  );\n}\n```\n\n### Exit animations for filtered messages\n\nThe `<AnimatePresence>` with `mode=\"popLayout\"` handles exit animations when messages are filtered out. Each message is keyed by its ID, so when filtering removes a message, it gets the `exit` animation.\n\n## Testing considerations\n\nMock `motion/react` in tests to render plain elements (existing pattern in codebase):\n\n```typescript\nvi.mock('motion/react', () => ({\n  motion: {\n    div: (props: any) => {\n      const { initial, animate, exit, transition, layout, ...rest } = props;\n      return <div {...rest} />;\n    },\n  },\n  AnimatePresence: ({ children }: { children: React.ReactNode }) => <>{children}</>,\n}));\n```\n\n## Acceptance criteria\n\n- New SSE-delivered messages animate in with `opacity: 0, y: 8 -> opacity: 1, y: 0` over 200ms\n- History messages loaded on page open do NOT animate (use `initial={false}`)\n- Filtered-out messages exit with opacity and height animation\n- `AnimatePresence` uses `mode=\"popLayout\"` to avoid layout thrashing\n- Motion is mocked in unit tests\n- No animation storm on initial page load",
      "activeForm": "Adding motion animations to ActivityFeed",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.6"],
      "parallelWith": ["2.2", "2.3"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Motion + Visual Polish",
      "subject": "[relay-ux-elevation] [P2] Add motion to MessageRow expand/collapse and tab transitions",
      "description": "Add smooth expand/collapse animations to MessageRow and subtle fade transitions on RelayPanel tab content.\n\n## Modify: `apps/client/src/layers/features/relay/ui/MessageRow.tsx`\n\nWrap the expanded content and trace section in `motion.div` with `AnimatePresence`:\n\n```tsx\nimport { motion, AnimatePresence } from 'motion/react';\n\nexport function MessageRow({ message }: MessageRowProps) {\n  const [expanded, setExpanded] = useState(false);\n  const [showTrace, setShowTrace] = useState(false);\n  // ... status config ...\n\n  return (\n    <div className={cn('w-full rounded-lg border text-left transition-colors hover:bg-muted/50 hover:shadow-sm transition-shadow', expanded && 'bg-muted/30')}>\n      <button type=\"button\" onClick={() => setExpanded(!expanded)} className=\"w-full p-3\">\n        {/* ... header row ... */}\n      </button>\n\n      <AnimatePresence initial={false}>\n        {expanded && (\n          <motion.div\n            initial={{ height: 0, opacity: 0 }}\n            animate={{ height: 'auto', opacity: 1 }}\n            exit={{ height: 0, opacity: 0 }}\n            transition={{ duration: 0.2, ease: 'easeOut' }}\n            className=\"overflow-hidden\"\n          >\n            <div className=\"space-y-2 border-t px-3 pb-3 pt-3\">\n              {/* payload, budget, trace toggle */}\n            </div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      <AnimatePresence initial={false}>\n        {showTrace && messageId && (\n          <motion.div\n            initial={{ height: 0, opacity: 0 }}\n            animate={{ height: 'auto', opacity: 1 }}\n            exit={{ height: 0, opacity: 0 }}\n            transition={{ duration: 0.2, ease: 'easeOut' }}\n            className=\"overflow-hidden border-t\"\n          >\n            <MessageTrace messageId={messageId} onClose={() => setShowTrace(false)} />\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  );\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/RelayPanel.tsx`\n\nAdd subtle fade transitions on tab panels using `AnimatePresence`:\n\n```tsx\nimport { motion, AnimatePresence } from 'motion/react';\n\n// In the Tabs section:\n<AnimatePresence mode=\"wait\">\n  <motion.div\n    key={activeTab}\n    initial={{ opacity: 0 }}\n    animate={{ opacity: 1 }}\n    exit={{ opacity: 0 }}\n    transition={{ duration: 0.15 }}\n    className=\"min-h-0 flex-1\"\n  >\n    {/* Render active tab content based on activeTab state */}\n  </motion.div>\n</AnimatePresence>\n```\n\nNote: Since Tabs components render all content but only show the active one via CSS, the tab fade may need to be implemented by conditionally rendering content based on `activeTab` state instead of relying on `TabsContent` visibility. An alternative approach is to add CSS transition classes to `TabsContent`.\n\n## Modify: `apps/client/src/layers/features/relay/ui/AdapterSetupWizard.tsx`\n\nAdd cross-fade between wizard steps (Configure/Test/Confirm):\n\n```tsx\nimport { motion, AnimatePresence } from 'motion/react';\n\n// Wrap the step content in the wizard:\n<AnimatePresence mode=\"wait\">\n  <motion.div\n    key={currentStep}\n    initial={{ opacity: 0 }}\n    animate={{ opacity: 1 }}\n    exit={{ opacity: 0 }}\n    transition={{ duration: 0.2 }}\n  >\n    {/* step content */}\n  </motion.div>\n</AnimatePresence>\n```\n\n## Acceptance criteria\n\n- MessageRow expand/collapse uses smooth height + opacity animation (200ms, easeOut)\n- `AnimatePresence` with `initial={false}` prevents animation on initial render\n- Overflow is hidden during animation to prevent content flash\n- Tab transitions have subtle fade (150ms)\n- Wizard steps cross-fade (200ms)\n- Card hover adds `hover:shadow-sm transition-shadow` for depth feedback\n- All animations are mocked in tests",
      "activeForm": "Adding motion to MessageRow and tab transitions",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.5", "1.6"],
      "parallelWith": ["2.1", "2.3"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Motion + Visual Polish",
      "subject": "[relay-ux-elevation] [P2] Apply unified status color system and visual refinements",
      "description": "Apply a consistent status color system across all Relay components. Currently, status indicators vary between components (dots vs text vs badges, inconsistent colors). This task unifies them.\n\n## Unified status color system\n\nCreate a shared constant file for Relay status colors.\n\n### New file: `apps/client/src/layers/features/relay/lib/status-colors.ts`\n\n```typescript\n/** Unified Relay status color system — consistent across all components. */\nexport const RELAY_STATUS_COLORS = {\n  // Dot/background colors\n  dot: {\n    healthy: 'bg-green-500',\n    delivered: 'bg-green-500',\n    connected: 'bg-green-500',\n    pending: 'bg-blue-500',\n    starting: 'bg-blue-500',\n    new: 'bg-blue-500',\n    degraded: 'bg-amber-500',\n    warning: 'bg-amber-500',\n    'rate-limited': 'bg-amber-500',\n    failed: 'bg-red-500',\n    error: 'bg-red-500',\n    disconnected: 'bg-red-500',\n    inactive: 'bg-gray-400',\n    stopped: 'bg-gray-400',\n  },\n  // Text colors\n  text: {\n    healthy: 'text-green-500',\n    delivered: 'text-green-500',\n    connected: 'text-green-500',\n    pending: 'text-blue-500',\n    starting: 'text-blue-500',\n    new: 'text-blue-500',\n    degraded: 'text-amber-500',\n    warning: 'text-amber-500',\n    failed: 'text-red-500',\n    error: 'text-red-500',\n    disconnected: 'text-red-500',\n    inactive: 'text-gray-400',\n    stopped: 'text-gray-400',\n  },\n  // Left border colors for cards\n  border: {\n    healthy: 'border-l-green-500',\n    delivered: 'border-l-green-500',\n    connected: 'border-l-green-500',\n    pending: 'border-l-blue-500',\n    starting: 'border-l-blue-500',\n    new: 'border-l-blue-500',\n    degraded: 'border-l-amber-500',\n    warning: 'border-l-amber-500',\n    failed: 'border-l-red-500',\n    error: 'border-l-red-500',\n    disconnected: 'border-l-red-500',\n    inactive: 'border-l-gray-400',\n    stopped: 'border-l-gray-400',\n  },\n} as const;\n\nexport type RelayStatus = keyof typeof RELAY_STATUS_COLORS.dot;\n\n/** Get the dot color class for a given status string. Falls back to gray. */\nexport function getStatusDotColor(status: string): string {\n  return RELAY_STATUS_COLORS.dot[status as RelayStatus] ?? 'bg-gray-400';\n}\n\n/** Get the text color class for a given status string. Falls back to gray. */\nexport function getStatusTextColor(status: string): string {\n  return RELAY_STATUS_COLORS.text[status as RelayStatus] ?? 'text-gray-400';\n}\n\n/** Get the left border color class for a given status string. Falls back to gray. */\nexport function getStatusBorderColor(status: string): string {\n  return RELAY_STATUS_COLORS.border[status as RelayStatus] ?? 'border-l-gray-400';\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/AdapterCard.tsx`\n\nReplace the status dot with a colored left border and add \"System\" badge for built-in adapters:\n\n```tsx\nimport { getStatusBorderColor } from '../lib/status-colors';\n\n// Replace:\n// <div className=\"flex items-center justify-between rounded-lg border p-3\">\n//   <span className={`h-2 w-2 rounded-full ${dotColor}`} />\n\n// With:\n<div className={cn(\n  'flex items-center justify-between rounded-lg border border-l-2 p-3',\n  getStatusBorderColor(instance.status.state),\n)}>\n  {/* Remove the status dot span */}\n\n  {/* Add System badge for built-in adapters */}\n  {manifest.builtin && (\n    <Badge variant=\"secondary\" className=\"text-xs\">\n      System\n    </Badge>\n  )}\n```\n\nAlso update the remove confirmation dialog description:\n```tsx\n<AlertDialogDescription>\n  This will stop the adapter and remove its configuration.\n  Messages to its subjects will no longer be delivered.\n  This action cannot be undone.\n</AlertDialogDescription>\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/MessageRow.tsx`\n\nApply failed status left border and typography hierarchy:\n\n```tsx\nimport { getStatusBorderColor } from '../lib/status-colors';\n\n// Add conditional left border for failed messages:\n<div className={cn(\n  'w-full rounded-lg border text-left transition-colors hover:bg-muted/50 hover:shadow-sm transition-shadow',\n  expanded && 'bg-muted/30',\n  status === 'failed' && 'border-l-2 border-l-red-500',\n  status === 'dead_letter' && 'border-l-2 border-l-amber-500',\n)}>\n```\n\nApply typography hierarchy:\n- Subject: `text-sm font-medium` (already correct)\n- From / Time: `text-xs text-muted-foreground` (already correct)\n- Status badge: `text-xs` (already correct)\n\n## Acceptance criteria\n\n- Shared status color utility exists at `features/relay/lib/status-colors.ts`\n- AdapterCard uses 2px colored left border instead of status dot\n- AdapterCard shows \"System\" badge for built-in adapters\n- AdapterCard remove dialog has enhanced description explaining consequences\n- MessageRow shows red left border for failed messages, amber for dead letters\n- All cards have `hover:shadow-sm transition-shadow` for interactivity feedback\n- Color system is consistent: green for healthy/delivered/connected, blue for pending/new, amber for degraded/warning, red for failed/error, gray for inactive\n- No hardcoded color values in components — all reference the shared utility",
      "activeForm": "Applying unified status color system and visual refinements",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.5", "1.6"],
      "parallelWith": ["2.1", "2.2"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Create ConnectionStatusBanner and useRelayConnection hook",
      "description": "Add SSE connection health visibility. When the EventSource disconnects, show a banner. Currently the `useRelayEventStream` hook has no error handling and silently fails.\n\n## New file: `apps/client/src/layers/entities/relay/model/use-relay-connection.ts`\n\nExtract connection state tracking from the SSE event source.\n\n```typescript\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nexport type ConnectionState = 'connected' | 'reconnecting' | 'disconnected';\n\ninterface RelayConnectionState {\n  state: ConnectionState;\n  failedAttempts: number;\n}\n\n/**\n * Track Relay SSE connection health.\n *\n * @param enabled - Whether the relay SSE stream is active.\n */\nexport function useRelayConnection(enabled: boolean): RelayConnectionState {\n  const [state, setState] = useState<ConnectionState>(enabled ? 'connected' : 'disconnected');\n  const [failedAttempts, setFailedAttempts] = useState(0);\n  const sourceRef = useRef<EventSource | null>(null);\n\n  useEffect(() => {\n    if (!enabled) {\n      setState('disconnected');\n      setFailedAttempts(0);\n      return;\n    }\n\n    // We need to listen to the same EventSource that useRelayEventStream uses.\n    // Since we can't share the instance directly, we create a lightweight monitor.\n    const source = new EventSource('/api/relay/stream');\n    sourceRef.current = source;\n\n    source.onopen = () => {\n      setState('connected');\n      setFailedAttempts(0);\n    };\n\n    source.onerror = () => {\n      setState('reconnecting');\n      setFailedAttempts((prev) => {\n        const next = prev + 1;\n        if (next >= 3) {\n          setState('disconnected');\n        }\n        return next;\n      });\n    };\n\n    return () => {\n      source.close();\n      sourceRef.current = null;\n    };\n  }, [enabled]);\n\n  return { state, failedAttempts };\n}\n```\n\nNote: In a more refined implementation, the connection state could be shared with `useRelayEventStream` via a shared ref or context. For this iteration, we use a separate lightweight EventSource connection for monitoring. An alternative is to refactor `useRelayEventStream` to expose connection state, which would be cleaner but requires more changes.\n\nBetter alternative — refactor `useRelayEventStream` to expose state:\n\n### Modify: `apps/client/src/layers/entities/relay/model/use-relay-event-stream.ts`\n\n```typescript\nimport { useEffect, useState } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\n\nexport type RelayConnectionState = 'connected' | 'reconnecting' | 'disconnected';\n\ninterface RelayEventStreamResult {\n  connectionState: RelayConnectionState;\n  failedAttempts: number;\n}\n\n/**\n * Connect to the Relay SSE event stream and inject incoming messages into the query cache.\n * Also tracks connection health state.\n *\n * @param enabled - Whether to connect (typically tied to relay feature flag).\n * @param pattern - Optional subject pattern for server-side filtering.\n */\nexport function useRelayEventStream(enabled: boolean, pattern?: string): RelayEventStreamResult {\n  const queryClient = useQueryClient();\n  const [connectionState, setConnectionState] = useState<RelayConnectionState>(\n    enabled ? 'connected' : 'disconnected',\n  );\n  const [failedAttempts, setFailedAttempts] = useState(0);\n\n  useEffect(() => {\n    if (!enabled) {\n      setConnectionState('disconnected');\n      return;\n    }\n\n    const params = pattern ? `?subject=${encodeURIComponent(pattern)}` : '';\n    const source = new EventSource(`/api/relay/stream${params}`);\n\n    source.onopen = () => {\n      setConnectionState('connected');\n      setFailedAttempts(0);\n    };\n\n    source.onerror = () => {\n      setConnectionState((prev) => {\n        // Only transition to reconnecting if we were connected\n        return prev === 'connected' ? 'reconnecting' : prev;\n      });\n      setFailedAttempts((prev) => {\n        const next = prev + 1;\n        if (next >= 3) {\n          setConnectionState('disconnected');\n        }\n        return next;\n      });\n    };\n\n    source.addEventListener('relay_message', (e) => {\n      const envelope = JSON.parse(e.data);\n      queryClient.setQueryData(\n        ['relay', 'messages', undefined],\n        (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n          if (!old) return { messages: [envelope] };\n          return { ...old, messages: [envelope, ...old.messages] };\n        },\n      );\n    });\n\n    source.addEventListener('relay_delivery', (e) => {\n      const data = JSON.parse(e.data);\n      queryClient.setQueryData(\n        ['relay', 'messages', undefined],\n        (old: { messages: unknown[]; nextCursor?: string } | undefined) => {\n          if (!old) return old;\n          return {\n            ...old,\n            messages: old.messages.map((msg) => {\n              const m = msg as Record<string, unknown>;\n              return m.id === data.messageId ? { ...m, status: data.status } : msg;\n            }),\n          };\n        },\n      );\n    });\n\n    return () => source.close();\n  }, [enabled, pattern, queryClient]);\n\n  return { connectionState, failedAttempts };\n}\n```\n\n### Update barrel: `apps/client/src/layers/entities/relay/index.ts`\n\nThe export stays the same since the function name hasn't changed, but consumers now get the return value.\n\n## New file: `apps/client/src/layers/features/relay/ui/ConnectionStatusBanner.tsx`\n\n```tsx\nimport { Wifi, WifiOff } from 'lucide-react';\nimport { cn } from '@/layers/shared/lib';\nimport type { RelayConnectionState } from '@/layers/entities/relay';\n\ninterface ConnectionStatusBannerProps {\n  connectionState: RelayConnectionState;\n  failedAttempts: number;\n}\n\n/**\n * Banner showing SSE connection health. Hidden when connected.\n * Amber when reconnecting, red after 3+ failed attempts.\n */\nexport function ConnectionStatusBanner({ connectionState, failedAttempts }: ConnectionStatusBannerProps) {\n  if (connectionState === 'connected') return null;\n\n  const isDisconnected = connectionState === 'disconnected' || failedAttempts >= 3;\n\n  return (\n    <div\n      className={cn(\n        'flex items-center gap-2 px-3 py-1.5 text-xs font-medium',\n        isDisconnected\n          ? 'bg-red-50 text-red-700 dark:bg-red-950 dark:text-red-300'\n          : 'bg-amber-50 text-amber-700 dark:bg-amber-950 dark:text-amber-300',\n      )}\n    >\n      {isDisconnected ? (\n        <>\n          <WifiOff className=\"size-3.5\" />\n          Unable to connect. Messages may be delayed.\n        </>\n      ) : (\n        <>\n          <Wifi className=\"size-3.5 animate-pulse\" />\n          Connection lost. Reconnecting...\n        </>\n      )}\n    </div>\n  );\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/RelayPanel.tsx`\n\nCapture the connection state from `useRelayEventStream` and pass to banner:\n\n```tsx\nimport { ConnectionStatusBanner } from './ConnectionStatusBanner';\n\nexport function RelayPanel() {\n  const relayEnabled = useRelayEnabled();\n  const { connectionState, failedAttempts } = useRelayEventStream(relayEnabled);\n  // ...\n\n  return (\n    <div className=\"flex h-full flex-col\">\n      <RelayHealthBar enabled={relayEnabled} onFailedClick={handleFailedClick} />\n      <ConnectionStatusBanner connectionState={connectionState} failedAttempts={failedAttempts} />\n      <Tabs ...>\n        {/* tabs */}\n      </Tabs>\n    </div>\n  );\n}\n```\n\n## Unit test: `apps/client/src/layers/features/relay/__tests__/ConnectionStatusBanner.test.tsx`\n\n```tsx\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { ConnectionStatusBanner } from '../ui/ConnectionStatusBanner';\n\ndescribe('ConnectionStatusBanner', () => {\n  it('renders nothing when connected', () => {\n    const { container } = render(\n      <ConnectionStatusBanner connectionState=\"connected\" failedAttempts={0} />,\n    );\n    expect(container.firstChild).toBeNull();\n  });\n\n  it('shows amber banner when reconnecting', () => {\n    render(<ConnectionStatusBanner connectionState=\"reconnecting\" failedAttempts={1} />);\n    expect(screen.getByText(/Connection lost/)).toBeInTheDocument();\n  });\n\n  it('shows red banner after 3 failed attempts', () => {\n    render(<ConnectionStatusBanner connectionState=\"disconnected\" failedAttempts={3} />);\n    expect(screen.getByText(/Unable to connect/)).toBeInTheDocument();\n  });\n});\n```\n\n## Acceptance criteria\n\n- `useRelayEventStream` now returns `{ connectionState, failedAttempts }`\n- `connectionState` transitions: `connected` (onopen), `reconnecting` (first onerror), `disconnected` (3+ errors)\n- `ConnectionStatusBanner` is hidden when connected\n- Amber banner with pulse icon shown when reconnecting\n- Red banner shown after 3 failed reconnection attempts\n- Banner positioned between health bar and tabs\n- Unit tests pass\n- Existing SSE message injection behavior is unchanged",
      "activeForm": "Creating ConnectionStatusBanner and useRelayConnection hook",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.6"],
      "parallelWith": ["3.2", "3.3"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Enhance ActivityFeed filters with status, subject, and content preview",
      "description": "Replace the single source dropdown in ActivityFeed with a full filter bar: source + status + subject text input. Also add content preview in collapsed MessageRow.\n\n## Modify: `apps/client/src/layers/features/relay/ui/ActivityFeed.tsx`\n\nReplace the single `<Select>` with a horizontal filter bar:\n\n```tsx\nimport { useState, useRef, useEffect } from 'react';\nimport { Inbox } from 'lucide-react';\nimport { useRelayMessages, useRelayEndpoints } from '@/layers/entities/relay';\nimport {\n  Badge,\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n  Input,\n  Button,\n} from '@/layers/shared/ui';\nimport { motion, AnimatePresence } from 'motion/react';\nimport { MessageRow } from './MessageRow';\nimport { DeadLetterSection } from './DeadLetterSection';\n\ntype SourceFilter = 'all' | 'telegram' | 'webhook' | 'system';\ntype StatusFilter = 'all' | 'delivered' | 'failed' | 'pending';\n\ninterface ActivityFeedProps {\n  enabled: boolean;\n  deadLetterRef?: React.RefObject<HTMLDivElement>;\n}\n\nexport function ActivityFeed({ enabled, deadLetterRef }: ActivityFeedProps) {\n  const [sourceFilter, setSourceFilter] = useState<SourceFilter>('all');\n  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');\n  const [subjectFilter, setSubjectFilter] = useState('');\n  const { data, isLoading } = useRelayMessages(undefined, enabled);\n  const { data: endpoints = [] } = useRelayEndpoints(enabled);\n  const messages = data?.messages ?? [];\n  const initialIdsRef = useRef<Set<string> | null>(null);\n\n  // ... initial IDs tracking for animation ...\n\n  const hasActiveFilters = sourceFilter !== 'all' || statusFilter !== 'all' || subjectFilter !== '';\n\n  const filteredMessages = messages.filter((msg) => {\n    const raw = msg as Record<string, unknown>;\n    const subject = (raw.subject as string) ?? '';\n    const status = (raw.status as string) ?? 'new';\n\n    // Source filter\n    if (sourceFilter !== 'all') {\n      const source = getSourceType(subject);\n      if (source !== sourceFilter) return false;\n    }\n\n    // Status filter\n    if (statusFilter !== 'all') {\n      const statusMap: Record<StatusFilter, string[]> = {\n        all: [],\n        delivered: ['cur'],\n        failed: ['failed', 'dead_letter'],\n        pending: ['new'],\n      };\n      if (!statusMap[statusFilter].includes(status)) return false;\n    }\n\n    // Subject filter (case-insensitive substring match)\n    if (subjectFilter && !subject.toLowerCase().includes(subjectFilter.toLowerCase())) {\n      return false;\n    }\n\n    return true;\n  });\n\n  const clearFilters = () => {\n    setSourceFilter('all');\n    setStatusFilter('all');\n    setSubjectFilter('');\n  };\n\n  // ... loading state ...\n\n  return (\n    <div className=\"flex flex-col gap-3 p-4\">\n      <div ref={deadLetterRef}>\n        <DeadLetterSection enabled={enabled} />\n      </div>\n\n      {/* Filter bar */}\n      <div className=\"flex flex-wrap items-center gap-2\">\n        <Select value={sourceFilter} onValueChange={(v) => setSourceFilter(v as SourceFilter)}>\n          <SelectTrigger className=\"w-28\">\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"all\">All Sources</SelectItem>\n            <SelectItem value=\"telegram\">Telegram</SelectItem>\n            <SelectItem value=\"webhook\">Webhook</SelectItem>\n            <SelectItem value=\"system\">System</SelectItem>\n          </SelectContent>\n        </Select>\n\n        <Select value={statusFilter} onValueChange={(v) => setStatusFilter(v as StatusFilter)}>\n          <SelectTrigger className=\"w-28\">\n            <SelectValue />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"all\">All Status</SelectItem>\n            <SelectItem value=\"delivered\">Delivered</SelectItem>\n            <SelectItem value=\"failed\">Failed</SelectItem>\n            <SelectItem value=\"pending\">Pending</SelectItem>\n          </SelectContent>\n        </Select>\n\n        <Input\n          placeholder=\"Filter by subject...\"\n          value={subjectFilter}\n          onChange={(e) => setSubjectFilter(e.target.value)}\n          className=\"w-40\"\n        />\n\n        {hasActiveFilters && (\n          <Button variant=\"ghost\" size=\"sm\" onClick={clearFilters} className=\"text-xs\">\n            Clear filters\n          </Button>\n        )}\n      </div>\n\n      {/* Message list */}\n      {filteredMessages.length === 0 ? (\n        /* ... empty state (see task 3.4) ... */\n      ) : (\n        <AnimatePresence mode=\"popLayout\">\n          {/* ... message list with animation ... */}\n        </AnimatePresence>\n      )}\n    </div>\n  );\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/MessageRow.tsx`\n\nAdd content preview to the collapsed (non-expanded) view:\n\n```tsx\n// In the collapsed header area, after the status badge:\n{!expanded && message.payload != null && (\n  <span className=\"min-w-0 max-w-[200px] truncate text-sm text-muted-foreground\">\n    {extractPreview(message.payload)}\n  </span>\n)}\n```\n\nAdd the preview extraction helper:\n\n```typescript\n/** Extract a short text preview from a message payload. */\nfunction extractPreview(payload: unknown): string {\n  if (typeof payload === 'string') return payload.slice(0, 80);\n  if (payload && typeof payload === 'object') {\n    const obj = payload as Record<string, unknown>;\n    // Try common content fields\n    const content = obj.content ?? obj.text ?? obj.message ?? obj.body;\n    if (typeof content === 'string') return content.slice(0, 80);\n    // Fallback to JSON preview\n    const json = JSON.stringify(payload);\n    return json.slice(0, 80);\n  }\n  return String(payload).slice(0, 80);\n}\n```\n\n## Acceptance criteria\n\n- Three filter controls: Source (dropdown), Status (dropdown), Subject (text input)\n- Filter bar uses horizontal flex with `gap-2`, wraps on narrow viewports (`flex-wrap`)\n- Status filter maps: \"Delivered\" -> `cur`, \"Failed\" -> `failed`/`dead_letter`, \"Pending\" -> `new`\n- Subject filter is case-insensitive substring match\n- \"Clear filters\" button appears when any filter is active\n- Content preview shows first ~80 chars of payload content in collapsed MessageRow\n- Content preview uses `text-sm text-muted-foreground` and truncates with ellipsis\n- Preview tries `payload.content`, `payload.text`, `payload.message`, `payload.body` before falling back to JSON\n- Filtering is client-side (no server round-trips)",
      "activeForm": "Enhancing ActivityFeed filters",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": ["3.1", "3.3"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Create ComposeMessageDialog for test messaging",
      "description": "Create a dialog for composing and sending test messages through the Relay bus. This surfaces the existing `useSendRelayMessage` mutation hook that currently has no UI.\n\n## New file: `apps/client/src/layers/features/relay/ui/ComposeMessageDialog.tsx`\n\n```tsx\nimport { useState } from 'react';\nimport { PenLine, Send, Loader2 } from 'lucide-react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n  DialogFooter,\n  DialogTrigger,\n  Button,\n  Input,\n  Label,\n  Textarea,\n} from '@/layers/shared/ui';\nimport { useSendRelayMessage } from '@/layers/entities/relay';\nimport { useToast } from '@/layers/shared/model';\n\ninterface ComposeMessageDialogProps {\n  trigger?: React.ReactNode;\n}\n\n/**\n * Dialog for composing and sending a test message through the Relay bus.\n * Uses the existing useSendRelayMessage mutation.\n */\nexport function ComposeMessageDialog({ trigger }: ComposeMessageDialogProps) {\n  const [open, setOpen] = useState(false);\n  const [subject, setSubject] = useState('');\n  const [from, setFrom] = useState('relay.human.console');\n  const [payload, setPayload] = useState('');\n  const [error, setError] = useState<string | null>(null);\n  const { mutate: sendMessage, isPending } = useSendRelayMessage();\n  const { toast } = useToast();\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n\n    if (!subject.trim()) {\n      setError('Subject is required');\n      return;\n    }\n    if (!from.trim()) {\n      setError('From is required');\n      return;\n    }\n\n    // Try to parse payload as JSON, fall back to plain text\n    let parsedPayload: unknown;\n    try {\n      parsedPayload = payload.trim() ? JSON.parse(payload) : { content: '' };\n    } catch {\n      parsedPayload = { content: payload };\n    }\n\n    sendMessage(\n      { subject: subject.trim(), from: from.trim(), payload: parsedPayload },\n      {\n        onSuccess: () => {\n          toast({ description: 'Message sent successfully' });\n          setOpen(false);\n          // Reset form\n          setSubject('');\n          setFrom('relay.human.console');\n          setPayload('');\n          setError(null);\n        },\n        onError: (err) => {\n          setError(err instanceof Error ? err.message : 'Failed to send message');\n        },\n      },\n    );\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        {trigger ?? (\n          <Button variant=\"outline\" size=\"sm\" className=\"gap-1.5\">\n            <PenLine className=\"size-3.5\" />\n            Compose\n          </Button>\n        )}\n      </DialogTrigger>\n      <DialogContent className=\"sm:max-w-md\">\n        <form onSubmit={handleSubmit}>\n          <DialogHeader>\n            <DialogTitle>Send Test Message</DialogTitle>\n            <DialogDescription>\n              Send a message through the Relay bus for testing and debugging.\n            </DialogDescription>\n          </DialogHeader>\n\n          <div className=\"mt-4 space-y-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"compose-subject\">Subject</Label>\n              <Input\n                id=\"compose-subject\"\n                placeholder=\"relay.test.ping\"\n                value={subject}\n                onChange={(e) => setSubject(e.target.value)}\n                className=\"font-mono text-sm\"\n                required\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"compose-from\">From</Label>\n              <Input\n                id=\"compose-from\"\n                value={from}\n                onChange={(e) => setFrom(e.target.value)}\n                className=\"font-mono text-sm\"\n                required\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"compose-payload\">Payload</Label>\n              <Textarea\n                id=\"compose-payload\"\n                placeholder='{\"content\": \"Hello from DorkOS\"}'\n                value={payload}\n                onChange={(e) => setPayload(e.target.value)}\n                className=\"min-h-[100px] font-mono text-sm\"\n              />\n              <p className=\"text-xs text-muted-foreground\">\n                JSON or plain text. Plain text is wrapped as {'{\"content\": \"...\"}'}.\n              </p>\n            </div>\n\n            {error && (\n              <div className=\"rounded bg-destructive/10 px-3 py-2 text-sm text-destructive\">\n                {error}\n              </div>\n            )}\n          </div>\n\n          <DialogFooter className=\"mt-6\">\n            <Button type=\"button\" variant=\"outline\" onClick={() => setOpen(false)}>\n              Cancel\n            </Button>\n            <Button type=\"submit\" disabled={isPending} className=\"gap-1.5\">\n              {isPending ? (\n                <>\n                  <Loader2 className=\"size-3.5 animate-spin\" />\n                  Sending...\n                </>\n              ) : (\n                <>\n                  <Send className=\"size-3.5\" />\n                  Send\n                </>\n              )}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/ActivityFeed.tsx`\n\nAdd the Compose button in the filter bar area:\n\n```tsx\nimport { ComposeMessageDialog } from './ComposeMessageDialog';\n\n// In the filter bar, add at the right side:\n<div className=\"flex flex-wrap items-center gap-2\">\n  {/* ... source, status, subject filters ... */}\n  <div className=\"ml-auto\">\n    <ComposeMessageDialog />\n  </div>\n</div>\n```\n\n## Modify: `apps/client/src/layers/features/relay/index.ts`\n\nAdd the export:\n\n```typescript\nexport { ComposeMessageDialog } from './ui/ComposeMessageDialog';\n```\n\n## Unit test: `apps/client/src/layers/features/relay/__tests__/ComposeMessageDialog.test.tsx`\n\n```tsx\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TransportProvider } from '@/layers/shared/model';\nimport { createMockTransport } from '@dorkos/test-utils';\nimport { ComposeMessageDialog } from '../ui/ComposeMessageDialog';\n\nvi.mock('@/layers/shared/model', async () => {\n  const actual = await vi.importActual('@/layers/shared/model');\n  return {\n    ...actual,\n    useToast: () => ({ toast: vi.fn() }),\n  };\n});\n\nfunction createWrapper() {\n  const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });\n  const transport = createMockTransport();\n  return {\n    transport,\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <QueryClientProvider client={qc}>\n        <TransportProvider transport={transport}>{children}</TransportProvider>\n      </QueryClientProvider>\n    ),\n  };\n}\n\ndescribe('ComposeMessageDialog', () => {\n  it('renders compose button', () => {\n    const { wrapper } = createWrapper();\n    render(<ComposeMessageDialog />, { wrapper });\n    expect(screen.getByText('Compose')).toBeInTheDocument();\n  });\n\n  it('shows validation error for empty subject', async () => {\n    const { wrapper } = createWrapper();\n    render(<ComposeMessageDialog />, { wrapper });\n    const user = userEvent.setup();\n\n    await user.click(screen.getByText('Compose'));\n    // Clear the default \"from\" field is pre-filled, try to submit with empty subject\n    await user.click(screen.getByText('Send'));\n\n    // HTML5 validation should prevent submission, or our manual check fires\n    // The subject field has required attribute\n  });\n\n  it('calls sendRelayMessage on submit', async () => {\n    const { wrapper, transport } = createWrapper();\n    vi.mocked(transport.sendRelayMessage).mockResolvedValue({ messageId: 'msg-1', deliveredTo: 1 });\n\n    render(<ComposeMessageDialog />, { wrapper });\n    const user = userEvent.setup();\n\n    await user.click(screen.getByText('Compose'));\n    await user.type(screen.getByLabelText('Subject'), 'relay.test.ping');\n    await user.type(screen.getByLabelText('Payload'), 'Hello');\n    await user.click(screen.getByText('Send'));\n\n    await waitFor(() => {\n      expect(transport.sendRelayMessage).toHaveBeenCalledWith({\n        subject: 'relay.test.ping',\n        from: 'relay.human.console',\n        payload: { content: 'Hello' },\n      });\n    });\n  });\n});\n```\n\n## Acceptance criteria\n\n- Compose button (PenLine icon) appears in the Activity tab filter bar\n- Dialog has three fields: Subject (required), From (required, defaults to `relay.human.console`), Payload (textarea)\n- Payload accepts JSON or plain text; plain text is wrapped as `{ content: \"...\" }`\n- Submit calls `useSendRelayMessage()` mutation\n- On success: shows toast, closes dialog, resets form\n- On error: shows inline error message, button returns to enabled state\n- Send button shows loading spinner during submission\n- Unit tests pass",
      "activeForm": "Creating ComposeMessageDialog",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.6"],
      "parallelWith": ["3.1", "3.2"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Implement onboarding empty states with contextual CTAs",
      "description": "Replace generic empty states with context-aware guided CTAs across all Relay tabs. Each empty state should guide users to their next action.\n\n## Modify: `apps/client/src/layers/features/relay/ui/ActivityFeed.tsx`\n\nReplace the current empty state (which says \"No messages yet\" with generic text) with context-aware states:\n\n```tsx\n// When no messages and no filters active:\n{filteredMessages.length === 0 && !hasActiveFilters && (\n  <div className=\"flex flex-col items-center justify-center gap-3 py-8 text-center\">\n    <Inbox className=\"size-8 text-muted-foreground/30\" />\n    <div>\n      <p className=\"font-medium\">No messages yet</p>\n      <p className=\"mt-1 text-sm text-muted-foreground\">\n        Messages will appear here once your adapters are connected and agents start communicating.\n      </p>\n    </div>\n    <Button\n      variant=\"outline\"\n      size=\"sm\"\n      onClick={onSwitchToAdapters}\n      className=\"mt-2\"\n    >\n      Set up an adapter\n    </Button>\n  </div>\n)}\n\n// When no messages match active filters:\n{filteredMessages.length === 0 && hasActiveFilters && (\n  <div className=\"flex flex-col items-center justify-center gap-3 py-8 text-center\">\n    <Inbox className=\"size-8 text-muted-foreground/30\" />\n    <div>\n      <p className=\"font-medium\">No messages match your filters</p>\n      <p className=\"mt-1 text-sm text-muted-foreground\">\n        Try adjusting your filters or clearing them to see all messages.\n      </p>\n    </div>\n    <Button variant=\"outline\" size=\"sm\" onClick={clearFilters} className=\"mt-2\">\n      Clear filters\n    </Button>\n  </div>\n)}\n```\n\nThis requires adding an `onSwitchToAdapters` callback prop to `ActivityFeed`:\n\n```typescript\ninterface ActivityFeedProps {\n  enabled: boolean;\n  deadLetterRef?: React.RefObject<HTMLDivElement>;\n  onSwitchToAdapters?: () => void;\n}\n```\n\nIn `RelayPanel.tsx`, pass the callback:\n\n```tsx\n<ActivityFeed\n  enabled={relayEnabled}\n  deadLetterRef={deadLetterRef}\n  onSwitchToAdapters={() => setActiveTab('adapters')}\n/>\n```\n\n## Modify: `apps/client/src/layers/features/relay/ui/EndpointList.tsx`\n\nReplace the current empty state:\n\n```tsx\n// Current:\n<p className=\"font-medium\">No endpoints registered</p>\n<p className=\"mt-1 text-sm text-muted-foreground\">\n  Endpoints are registered by the server or via MCP tools.\n</p>\n\n// Replace with:\nimport { Inbox } from 'lucide-react';\n\n<div className=\"flex flex-col items-center justify-center gap-3 p-8 text-center\">\n  <Inbox className=\"size-8 text-muted-foreground/30\" />\n  <div>\n    <p className=\"font-medium\">No endpoints registered</p>\n    <p className=\"mt-1 text-sm text-muted-foreground\">\n      Endpoints are created automatically when adapters subscribe to message subjects.\n    </p>\n  </div>\n</div>\n```\n\nNote: The icon also changes from `Radio` to `Inbox` for better semantic meaning (as specified in the visual design section).\n\n## Modify: `apps/client/src/layers/features/relay/ui/RelayPanel.tsx` (AdaptersTab)\n\nUpdate the \"No adapters configured yet.\" empty state in the configured adapters section:\n\n```tsx\n{configuredCards.length === 0 ? (\n  <p className=\"text-sm text-muted-foreground\">\n    No adapters configured yet. Choose an available adapter below to get started.\n  </p>\n) : (\n  // ... existing adapter card list ...\n)}\n```\n\n## Acceptance criteria\n\n- Activity empty state (no filters): Shows \"No messages yet\" with explanation and \"Set up an adapter\" CTA button\n- Clicking \"Set up an adapter\" switches to the Adapters tab\n- Activity empty state (with filters): Shows \"No messages match your filters\" with \"Clear filters\" button\n- Clicking \"Clear filters\" resets all three filter controls\n- Endpoints empty state: Updated text explaining endpoints are created automatically by adapters\n- EndpointList icon changed from `Radio` to `Inbox`\n- Adapters empty state: Directs users to available adapters below\n- All empty states use centered layout with icon, heading, description, and optional CTA",
      "activeForm": "Implementing onboarding empty states",
      "size": "small",
      "priority": "medium",
      "dependencies": ["3.2"],
      "parallelWith": ["3.5"]
    },
    {
      "id": "3.5",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Enhance EndpointList with health indicators and card layout",
      "description": "Upgrade the EndpointList from bare subject strings to informative cards with health dots, message counts, last activity timestamps, and description text.\n\n## Modify: `apps/client/src/layers/features/relay/ui/EndpointList.tsx`\n\nThe current component renders each endpoint as a simple button with a Radio icon and the subject string. Enhance it to show more information with graceful degradation when data is not available.\n\n```tsx\nimport { Inbox } from 'lucide-react';\nimport { useRelayEndpoints } from '@/layers/entities/relay';\nimport { cn } from '@/layers/shared/lib';\nimport { getStatusDotColor } from '../lib/status-colors';\n\ninterface EndpointListProps {\n  enabled: boolean;\n  onSelectEndpoint?: (subject: string) => void;\n}\n\n/** Format a date string to relative time (e.g., \"2h ago\"). */\nfunction formatTimeAgo(dateStr: string): string {\n  const diff = Date.now() - new Date(dateStr).getTime();\n  const seconds = Math.floor(diff / 1000);\n  if (seconds < 60) return `${seconds}s ago`;\n  const minutes = Math.floor(seconds / 60);\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  return `${Math.floor(hours / 24)}d ago`;\n}\n\n/** Determine health status from endpoint data. */\nfunction getEndpointHealth(endpoint: Record<string, unknown>): string {\n  // If the server provides a health field, use it\n  if (endpoint.health) return endpoint.health as string;\n  // Graceful degradation: default to healthy if no data\n  return 'healthy';\n}\n\n/** List of registered relay endpoints with health indicators and metadata. */\nexport function EndpointList({ enabled, onSelectEndpoint }: EndpointListProps) {\n  const { data: endpoints = [], isLoading } = useRelayEndpoints(enabled);\n\n  if (isLoading) {\n    return (\n      <div className=\"space-y-2 p-4\">\n        {[1, 2].map((i) => (\n          <div key={i} className=\"rounded-lg border p-3\">\n            <div className=\"h-4 w-48 animate-pulse rounded bg-muted\" />\n            <div className=\"mt-1.5 h-3 w-32 animate-pulse rounded bg-muted\" />\n          </div>\n        ))}\n      </div>\n    );\n  }\n\n  if (endpoints.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center gap-3 p-8 text-center\">\n        <Inbox className=\"size-8 text-muted-foreground/30\" />\n        <div>\n          <p className=\"font-medium\">No endpoints registered</p>\n          <p className=\"mt-1 text-sm text-muted-foreground\">\n            Endpoints are created automatically when adapters subscribe to message subjects.\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-2 p-4\">\n      {endpoints.map((ep) => {\n        const endpoint = ep as Record<string, unknown>;\n        const subject = endpoint.subject as string;\n        const health = getEndpointHealth(endpoint);\n        const lastActivity = endpoint.lastActivity as string | undefined;\n        const messageCount = endpoint.messageCount as { inbound?: number; outbound?: number } | undefined;\n\n        return (\n          <button\n            key={subject}\n            type=\"button\"\n            onClick={() => onSelectEndpoint?.(subject)}\n            className=\"w-full rounded-lg border p-3 text-left transition-colors hover:bg-muted/50 hover:shadow-sm transition-shadow\"\n          >\n            <div className=\"flex items-center gap-2\">\n              <span\n                className={cn('h-2 w-2 shrink-0 rounded-full', getStatusDotColor(health))}\n                aria-hidden=\"true\"\n              />\n              <span className=\"min-w-0 flex-1 truncate font-mono text-sm font-medium\">\n                {subject}\n              </span>\n              {lastActivity && (\n                <span className=\"shrink-0 text-xs text-muted-foreground\">\n                  {formatTimeAgo(lastActivity)}\n                </span>\n              )}\n            </div>\n\n            {/* Message counts (if available) */}\n            {messageCount && (\n              <div className=\"mt-1 pl-4 text-xs text-muted-foreground\">\n                In: {messageCount.inbound ?? 0} | Out: {messageCount.outbound ?? 0}\n              </div>\n            )}\n\n            {/* Description */}\n            {endpoint.description != null && (\n              <p className=\"mt-1 pl-4 text-xs text-muted-foreground\">\n                {String(endpoint.description)}\n              </p>\n            )}\n          </button>\n        );\n      })}\n    </div>\n  );\n}\n```\n\nKey changes:\n- Icon changed from `Radio` to `Inbox` (better semantic meaning)\n- Health dot using shared `getStatusDotColor()` utility\n- Subject in monospace font with `font-medium`\n- Last activity timestamp shown with relative time\n- Message count indicators (in/out) if available from server data\n- Description text if available\n- `hover:shadow-sm transition-shadow` for card interactivity feedback\n- Graceful degradation: If the server doesn't provide `health`, `lastActivity`, or `messageCount`, those elements are simply not rendered\n\n## Acceptance criteria\n\n- Endpoints displayed as informative cards (not just subject strings)\n- Each card shows: health dot (green/amber/red), subject (monospace, font-medium), last activity timestamp\n- Message count (in/out) shown when available from endpoint data\n- Description shown when available\n- Icon changed from `Radio` to `Inbox`\n- Cards have `hover:shadow-sm transition-shadow` for interactivity feedback\n- Graceful degradation when health/activity data is not available from server\n- Uses shared `getStatusDotColor()` from `status-colors.ts`",
      "activeForm": "Enhancing EndpointList with health indicators",
      "size": "small",
      "priority": "low",
      "dependencies": ["2.3"],
      "parallelWith": ["3.4"]
    },
    {
      "id": "3.6",
      "phase": 3,
      "phaseName": "Interactivity + UX",
      "subject": "[relay-ux-elevation] [P3] Update barrel exports and CLAUDE.md documentation",
      "description": "Update the relay feature barrel exports and the CLAUDE.md client architecture table to reflect all new components and hooks added in this feature.\n\n## Modify: `apps/client/src/layers/features/relay/index.ts`\n\nEnsure all new components are exported:\n\n```typescript\n/**\n * Relay feature — inter-agent messaging UI with activity feed, endpoint management,\n * health monitoring, and delivery diagnostics.\n *\n * @module features/relay\n */\nexport { RelayPanel } from './ui/RelayPanel';\nexport { AdapterCard } from './ui/AdapterCard';\nexport { CatalogCard } from './ui/CatalogCard';\nexport { MessageTrace } from './ui/MessageTrace';\nexport { DeliveryMetricsDashboard } from './ui/DeliveryMetrics';\nexport { ConfigFieldInput, ConfigFieldGroup } from './ui/ConfigFieldInput';\nexport { AdapterSetupWizard } from './ui/AdapterSetupWizard';\nexport { RelayHealthBar } from './ui/RelayHealthBar';\nexport { DeadLetterSection } from './ui/DeadLetterSection';\nexport { ConnectionStatusBanner } from './ui/ConnectionStatusBanner';\nexport { ComposeMessageDialog } from './ui/ComposeMessageDialog';\n```\n\n## Modify: `apps/client/src/layers/entities/relay/index.ts`\n\nAdd the new entity hook export:\n\n```typescript\n/**\n * Relay entity — domain hooks for relay message bus data fetching.\n *\n * @module entities/relay\n */\nexport { useRelayEnabled } from './model/use-relay-config';\nexport { useRelayMessages, useSendRelayMessage } from './model/use-relay-messages';\nexport { useRelayEndpoints } from './model/use-relay-endpoints';\nexport { useRelayMetrics } from './model/use-relay-metrics';\nexport { useRelayEventStream } from './model/use-relay-event-stream';\nexport type { RelayConnectionState } from './model/use-relay-event-stream';\nexport { useRelayAdapters, useToggleAdapter } from './model/use-relay-adapters';\nexport {\n  useAdapterCatalog,\n  useAddAdapter,\n  useRemoveAdapter,\n  useUpdateAdapterConfig,\n  useTestAdapterConnection,\n} from './model/use-adapter-catalog';\nexport { useMessageTrace } from './model/use-message-trace';\nexport { useDeliveryMetrics } from './model/use-delivery-metrics';\nexport { useDeadLetters } from './model/use-dead-letters';\n```\n\n## Modify: `CLAUDE.md`\n\nUpdate the FSD Layers table in the Client section. Find the `features/relay/` row and update it:\n\nOld:\n```\n| `features/relay/`        | RelayPanel, ActivityFeed, MessageRow, EndpointList, InboxView, MessageTrace, DeliveryMetricsDashboard | Relay messaging UI          |\n```\n\nNew:\n```\n| `features/relay/`        | RelayPanel, ActivityFeed, MessageRow, EndpointList, InboxView, MessageTrace, DeliveryMetricsDashboard, RelayHealthBar, DeadLetterSection, ConnectionStatusBanner, ComposeMessageDialog | Relay messaging UI          |\n```\n\nUpdate the `entities/relay/` row:\n\nOld:\n```\n| `entities/relay/`        | useRelayEnabled, useRelayMessages, useRelayEndpoints, useRelayMetrics, useSendRelayMessage, useRelayEventStream, useMessageTrace, useDeliveryMetrics | Relay messaging domain hooks|\n```\n\nNew:\n```\n| `entities/relay/`        | useRelayEnabled, useRelayMessages, useRelayEndpoints, useRelayMetrics, useSendRelayMessage, useRelayEventStream, useMessageTrace, useDeliveryMetrics, useDeadLetters | Relay messaging domain hooks|\n```\n\n## Acceptance criteria\n\n- All new components exported from `features/relay/index.ts` barrel\n- New hooks exported from `entities/relay/index.ts` barrel\n- `RelayConnectionState` type exported from entity barrel\n- CLAUDE.md client architecture table updated with new component and hook names\n- TypeScript compiles: `pnpm typecheck`\n- No broken imports across the codebase",
      "activeForm": "Updating barrel exports and documentation",
      "size": "small",
      "priority": "low",
      "dependencies": ["3.1", "3.3", "3.4", "3.5"],
      "parallelWith": []
    }
  ]
}
