{
  "spec": "specs/mesh-observability-lifecycle/02-specification.md",
  "slug": "mesh-observability-lifecycle",
  "generatedAt": "2026-02-25T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation — Shared Schemas",
      "subject": "[mesh-observability-lifecycle] [P1] Add health, status, inspect, and lifecycle schemas to mesh-schemas.ts",
      "description": "Add the following Zod schemas and TypeScript types to `packages/shared/src/mesh-schemas.ts`. These schemas are required by all downstream tasks (registry, core, routes, transport, client hooks).\n\n**Implementation Steps:**\n\n1. Open `packages/shared/src/mesh-schemas.ts` and add the following schemas after the existing `AgentListQuerySchema`:\n\n```typescript\n// === Health & Observability Schemas ===\n\n/** Health status enum — computed from last_seen_at timestamp. */\nexport const AgentHealthStatusSchema = z.enum(['active', 'inactive', 'stale']).openapi('AgentHealthStatus');\nexport type AgentHealthStatus = z.infer<typeof AgentHealthStatusSchema>;\n\n/** Agent health detail — extends manifest with health tracking fields. */\nexport const AgentHealthSchema = z.object({\n  agentId: z.string(),\n  name: z.string(),\n  status: AgentHealthStatusSchema,\n  lastSeenAt: z.string().nullable(),\n  lastSeenEvent: z.string().nullable(),\n  registeredAt: z.string(),\n  runtime: AgentRuntimeSchema,\n  capabilities: z.array(z.string()),\n}).openapi('AgentHealth');\nexport type AgentHealth = z.infer<typeof AgentHealthSchema>;\n\n/** Aggregate mesh status — counts by health status plus groupings. */\nexport const MeshStatusSchema = z.object({\n  totalAgents: z.number(),\n  activeCount: z.number(),\n  inactiveCount: z.number(),\n  staleCount: z.number(),\n  byRuntime: z.record(z.string(), z.number()),\n  byProject: z.record(z.string(), z.number()),\n}).openapi('MeshStatus');\nexport type MeshStatus = z.infer<typeof MeshStatusSchema>;\n\n/** Detailed agent inspection — full manifest + health + relay info. */\nexport const MeshInspectSchema = z.object({\n  agent: AgentManifestSchema,\n  health: AgentHealthSchema,\n  relaySubject: z.string().nullable(),\n}).openapi('MeshInspect');\nexport type MeshInspect = z.infer<typeof MeshInspectSchema>;\n\n/** Lifecycle event — emitted as Relay signals on registration, unregistration, health change. */\nexport const MeshLifecycleEventSchema = z.object({\n  agentId: z.string(),\n  agentName: z.string(),\n  event: z.enum(['registered', 'unregistered', 'health_changed']),\n  previousStatus: AgentHealthStatusSchema.optional(),\n  currentStatus: AgentHealthStatusSchema.optional(),\n  timestamp: z.string(),\n}).openapi('MeshLifecycleEvent');\nexport type MeshLifecycleEvent = z.infer<typeof MeshLifecycleEventSchema>;\n\n/** Request body for POST /api/mesh/agents/:id/heartbeat */\nexport const HeartbeatRequestSchema = z.object({\n  event: z.string().optional().default('heartbeat'),\n}).openapi('HeartbeatRequest');\nexport type HeartbeatRequest = z.infer<typeof HeartbeatRequestSchema>;\n```\n\n2. Verify all schemas reference `AgentRuntimeSchema` and `AgentManifestSchema` which are already defined in the same file.\n\n3. Run `npm run typecheck` to verify the schemas compile.\n\n**Acceptance Criteria:**\n- [ ] `AgentHealthStatusSchema`, `AgentHealthSchema`, `MeshStatusSchema`, `MeshInspectSchema`, `MeshLifecycleEventSchema`, and `HeartbeatRequestSchema` are exported from `packages/shared/src/mesh-schemas.ts`\n- [ ] All corresponding TypeScript types are exported\n- [ ] All schemas have `.openapi()` metadata\n- [ ] `npm run typecheck` passes with no errors\n- [ ] Existing mesh schema exports are unchanged",
      "activeForm": "Adding health and observability schemas to shared mesh-schemas",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation — Schema Migration",
      "subject": "[mesh-observability-lifecycle] [P1] Add v2 migration and health-tracking methods to AgentRegistry",
      "description": "Extend `packages/mesh/src/agent-registry.ts` with a v2 schema migration adding `last_seen_at` and `last_seen_event` columns, plus new prepared statements and methods for health tracking.\n\n**Implementation Steps:**\n\n1. Add the v2 migration SQL to the `MIGRATIONS` array in `agent-registry.ts`:\n\n```typescript\nconst MIGRATIONS = [\n  // Version 1: initial schema\n  `CREATE TABLE IF NOT EXISTS agents (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    description TEXT NOT NULL DEFAULT '',\n    project_path TEXT NOT NULL UNIQUE,\n    runtime TEXT NOT NULL,\n    capabilities_json TEXT NOT NULL DEFAULT '[]',\n    manifest_json TEXT NOT NULL,\n    registered_at TEXT NOT NULL,\n    registered_by TEXT NOT NULL\n  );\n  CREATE INDEX IF NOT EXISTS idx_agents_project_path ON agents(project_path);\n  CREATE INDEX IF NOT EXISTS idx_agents_runtime ON agents(runtime);`,\n  // Version 2: health tracking columns\n  `ALTER TABLE agents ADD COLUMN last_seen_at TEXT;\n   ALTER TABLE agents ADD COLUMN last_seen_event TEXT;`,\n];\n```\n\n2. Add the `AgentHealthRow` interface and `AgentHealthEntry` / `AggregateStats` types:\n\n```typescript\n/** Raw SQLite row for an agent with health columns (snake_case). */\ninterface AgentHealthRow extends AgentRow {\n  last_seen_at: string | null;\n  last_seen_event: string | null;\n  health_status: 'active' | 'inactive' | 'stale';\n}\n\n/** An agent entry with computed health status. */\nexport interface AgentHealthEntry extends AgentRegistryEntry {\n  lastSeenAt: string | null;\n  lastSeenEvent: string | null;\n  healthStatus: 'active' | 'inactive' | 'stale';\n}\n\n/** Aggregate counts by health status. */\nexport interface AggregateStats {\n  totalAgents: number;\n  activeCount: number;\n  inactiveCount: number;\n  staleCount: number;\n}\n```\n\n3. Add new prepared statements to the `stmts` object in the constructor:\n\n```typescript\nupdateHealth: this.db.prepare(\n  `UPDATE agents SET last_seen_at = ?, last_seen_event = ? WHERE id = ?`\n),\ngetWithHealth: this.db.prepare(`\n  SELECT *, CASE\n    WHEN last_seen_at IS NULL THEN 'stale'\n    WHEN (julianday('now') - julianday(last_seen_at)) * 86400 < 300 THEN 'active'\n    WHEN (julianday('now') - julianday(last_seen_at)) * 86400 < 1800 THEN 'inactive'\n    ELSE 'stale'\n  END AS health_status\n  FROM agents WHERE id = ?\n`),\nlistWithHealth: this.db.prepare(`\n  SELECT *, CASE\n    WHEN last_seen_at IS NULL THEN 'stale'\n    WHEN (julianday('now') - julianday(last_seen_at)) * 86400 < 300 THEN 'active'\n    WHEN (julianday('now') - julianday(last_seen_at)) * 86400 < 1800 THEN 'inactive'\n    ELSE 'stale'\n  END AS health_status\n  FROM agents ORDER BY registered_at DESC\n`),\ngetAggregateStats: this.db.prepare(`\n  SELECT\n    COUNT(*) AS total_agents,\n    SUM(CASE WHEN last_seen_at IS NOT NULL AND (julianday('now') - julianday(last_seen_at)) * 86400 < 300 THEN 1 ELSE 0 END) AS active_count,\n    SUM(CASE WHEN last_seen_at IS NOT NULL AND (julianday('now') - julianday(last_seen_at)) * 86400 BETWEEN 300 AND 1800 THEN 1 ELSE 0 END) AS inactive_count,\n    SUM(CASE WHEN last_seen_at IS NULL OR (julianday('now') - julianday(last_seen_at)) * 86400 > 1800 THEN 1 ELSE 0 END) AS stale_count\n  FROM agents\n`),\n```\n\n4. Add four new public methods:\n\n```typescript\n/**\n * Update health tracking fields for an agent.\n *\n * @param id - Agent ULID\n * @param lastSeenAt - ISO timestamp of last activity\n * @param lastSeenEvent - Description of the event (e.g., 'heartbeat', 'message_sent')\n * @returns true if agent was found and updated\n */\nupdateHealth(id: string, lastSeenAt: string, lastSeenEvent: string): boolean {\n  const result = this.stmts.updateHealth.run(lastSeenAt, lastSeenEvent, id);\n  return result.changes > 0;\n}\n\n/**\n * Get a single agent with computed health status.\n *\n * @param id - Agent ULID\n * @returns The agent entry with health fields, or undefined if not found\n */\ngetWithHealth(id: string): AgentHealthEntry | undefined {\n  const row = this.stmts.getWithHealth.get(id) as AgentHealthRow | undefined;\n  return row ? this.healthRowToEntry(row) : undefined;\n}\n\n/**\n * List all agents with computed health status.\n *\n * @param filters - Optional runtime/capability filters\n * @returns Array of agents with health status ordered by registration date (newest first)\n */\nlistWithHealth(filters?: AgentListFilters): AgentHealthEntry[] {\n  const rows = this.stmts.listWithHealth.all() as AgentHealthRow[];\n  const entries = rows.map((row) => this.healthRowToEntry(row));\n  if (!filters) return entries;\n  return entries.filter((entry) => {\n    if (filters.runtime && entry.runtime !== filters.runtime) return false;\n    if (filters.capability && !entry.capabilities.includes(filters.capability)) return false;\n    return true;\n  });\n}\n\n/**\n * Get aggregate health statistics across all agents.\n *\n * @returns Counts of total, active, inactive, and stale agents\n */\ngetAggregateStats(): AggregateStats {\n  const row = this.stmts.getAggregateStats.get() as {\n    total_agents: number;\n    active_count: number;\n    inactive_count: number;\n    stale_count: number;\n  };\n  return {\n    totalAgents: row.total_agents,\n    activeCount: row.active_count,\n    inactiveCount: row.inactive_count,\n    staleCount: row.stale_count,\n  };\n}\n```\n\n5. Add the `healthRowToEntry` private helper:\n\n```typescript\nprivate healthRowToEntry(row: AgentHealthRow): AgentHealthEntry {\n  const manifest = JSON.parse(row.manifest_json) as AgentManifest;\n  return {\n    ...manifest,\n    projectPath: row.project_path,\n    lastSeenAt: row.last_seen_at,\n    lastSeenEvent: row.last_seen_event,\n    healthStatus: row.health_status,\n  };\n}\n```\n\n6. Update the type signature of `stmts` to include the new statements.\n\n**Testing — add to `packages/mesh/src/__tests__/agent-registry.test.ts`:**\n\n```typescript\nit('migrates from v1 to v2 adding health columns', () => {\n  // Create a v1 database, close it, reopen with AgentRegistry (which runs migrations)\n  // Verify last_seen_at and last_seen_event columns exist\n  const testRegistry = new AgentRegistry(path.join(tmpDir, 'migrate-test.db'));\n  // Insert an agent and verify health columns are null by default\n  testRegistry.insert(makeAgent());\n  const entry = testRegistry.getWithHealth(agentId);\n  expect(entry).toBeDefined();\n  expect(entry!.lastSeenAt).toBeNull();\n  expect(entry!.healthStatus).toBe('stale');\n  testRegistry.close();\n});\n\nit('updateHealth() sets last_seen_at and last_seen_event', () => {\n  registry.insert(makeAgent());\n  const now = new Date().toISOString();\n  const updated = registry.updateHealth(agentId, now, 'heartbeat');\n  expect(updated).toBe(true);\n  const entry = registry.getWithHealth(agentId);\n  expect(entry!.lastSeenAt).toBe(now);\n  expect(entry!.lastSeenEvent).toBe('heartbeat');\n});\n\nit('getWithHealth() computes active status for recent timestamp', () => {\n  registry.insert(makeAgent());\n  const recentTime = new Date(Date.now() - 60 * 1000).toISOString(); // 1 min ago\n  registry.updateHealth(agentId, recentTime, 'message');\n  const entry = registry.getWithHealth(agentId);\n  expect(entry!.healthStatus).toBe('active');\n});\n\nit('getWithHealth() computes inactive status for 10-minute-old timestamp', () => {\n  registry.insert(makeAgent());\n  const tenMinAgo = new Date(Date.now() - 10 * 60 * 1000).toISOString();\n  registry.updateHealth(agentId, tenMinAgo, 'message');\n  const entry = registry.getWithHealth(agentId);\n  expect(entry!.healthStatus).toBe('inactive');\n});\n\nit('getWithHealth() computes stale status for 60-minute-old timestamp', () => {\n  registry.insert(makeAgent());\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();\n  registry.updateHealth(agentId, oneHourAgo, 'old_event');\n  const entry = registry.getWithHealth(agentId);\n  expect(entry!.healthStatus).toBe('stale');\n});\n\nit('getWithHealth() computes stale for null last_seen_at', () => {\n  registry.insert(makeAgent());\n  const entry = registry.getWithHealth(agentId);\n  expect(entry!.lastSeenAt).toBeNull();\n  expect(entry!.healthStatus).toBe('stale');\n});\n\nit('getAggregateStats() returns correct counts', () => {\n  // Insert 3 agents with different last_seen_at values\n  const agent1 = makeAgent({ id: 'agent1' });\n  const agent2 = makeAgent({ id: 'agent2', projectPath: '/p2' });\n  const agent3 = makeAgent({ id: 'agent3', projectPath: '/p3' });\n  registry.insert(agent1);\n  registry.insert(agent2);\n  registry.insert(agent3);\n  registry.updateHealth('agent1', new Date().toISOString(), 'recent'); // active\n  registry.updateHealth('agent2', new Date(Date.now() - 10 * 60 * 1000).toISOString(), 'old'); // inactive\n  // agent3 has no last_seen_at -> stale\n  const stats = registry.getAggregateStats();\n  expect(stats.totalAgents).toBe(3);\n  expect(stats.activeCount).toBe(1);\n  expect(stats.inactiveCount).toBe(1);\n  expect(stats.staleCount).toBe(1);\n});\n\nit('listWithHealth() includes health_status for all agents', () => {\n  registry.insert(makeAgent());\n  registry.updateHealth(agentId, new Date().toISOString(), 'test');\n  const entries = registry.listWithHealth();\n  expect(entries.length).toBe(1);\n  expect(entries[0]!.healthStatus).toBe('active');\n});\n```\n\n**Acceptance Criteria:**\n- [ ] v2 migration adds `last_seen_at` and `last_seen_event` columns to `agents` table\n- [ ] Migration is idempotent — running on an already-v2 database does not error\n- [ ] `updateHealth()` correctly sets timestamp and event\n- [ ] `getWithHealth()` computes correct health status based on time thresholds (active < 5 min, inactive 5-30 min, stale > 30 min)\n- [ ] `getWithHealth()` returns stale for null `last_seen_at`\n- [ ] `listWithHealth()` returns all agents with computed health\n- [ ] `getAggregateStats()` returns correct counts\n- [ ] All 8 new tests pass\n- [ ] Existing agent-registry tests still pass",
      "activeForm": "Adding v2 migration and health-tracking methods to AgentRegistry",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation — MeshCore Health Methods",
      "subject": "[mesh-observability-lifecycle] [P1] Add health and diagnostic methods to MeshCore",
      "description": "Extend `packages/mesh/src/mesh-core.ts` with four new public methods: `updateLastSeen()`, `getAgentHealth()`, `getStatus()`, and `inspect()`. These compose the AgentRegistry health methods with additional business logic (relay subject lookup, aggregate groupings, health change signal emission).\n\n**Implementation Steps:**\n\n1. Import the new types at the top of `mesh-core.ts`:\n\n```typescript\nimport type { AgentHealthEntry, AggregateStats } from './agent-registry.js';\nimport type { AgentHealth, MeshStatus, MeshInspect } from '@dorkos/shared/mesh-schemas';\n```\n\n2. Add `signalEmitter` support to `MeshOptions` and the constructor:\n\n```typescript\n// In MeshOptions interface, add:\nimport type { SignalEmitter } from '@dorkos/relay';\n\nexport interface MeshOptions {\n  dataDir?: string;\n  relayCore?: RelayCore;\n  signalEmitter?: SignalEmitter;  // NEW — for lifecycle event emission\n  strategies?: DiscoveryStrategy[];\n}\n\n// Store as private field:\nprivate readonly signalEmitter?: SignalEmitter;\n\n// In constructor, after this.relayBridge assignment:\nthis.signalEmitter = options.signalEmitter;\n```\n\n3. Add the four public methods:\n\n```typescript\n/**\n * Update the last-seen timestamp for an agent.\n *\n * If the health status transitions (e.g., stale -> active), emits a\n * `mesh.agent.lifecycle.health_changed` signal via the SignalEmitter.\n *\n * @param agentId - The agent's ULID\n * @param event - Description of the triggering event (e.g., 'heartbeat', 'message_sent')\n */\nupdateLastSeen(agentId: string, event: string): void {\n  const before = this.registry.getWithHealth(agentId);\n  this.registry.updateHealth(agentId, new Date().toISOString(), event);\n  const after = this.registry.getWithHealth(agentId);\n\n  if (before && after && before.healthStatus !== after.healthStatus) {\n    this.signalEmitter?.emit('mesh.agent.lifecycle.health_changed', {\n      agentId,\n      agentName: after.name,\n      event: 'health_changed',\n      previousStatus: before.healthStatus,\n      currentStatus: after.healthStatus,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Get health details for a single agent.\n *\n * @param agentId - The agent's ULID\n * @returns Agent health object or undefined if not found\n */\ngetAgentHealth(agentId: string): AgentHealth | undefined {\n  const entry = this.registry.getWithHealth(agentId);\n  if (!entry) return undefined;\n  return {\n    agentId: entry.id,\n    name: entry.name,\n    status: entry.healthStatus,\n    lastSeenAt: entry.lastSeenAt,\n    lastSeenEvent: entry.lastSeenEvent,\n    registeredAt: entry.registeredAt,\n    runtime: entry.runtime,\n    capabilities: entry.capabilities,\n  };\n}\n\n/**\n * Get aggregate mesh status — total counts, by runtime, and by project.\n *\n * @returns MeshStatus with aggregate statistics\n */\ngetStatus(): MeshStatus {\n  const stats = this.registry.getAggregateStats();\n  const entries = this.registry.listWithHealth();\n\n  const byRuntime: Record<string, number> = {};\n  const byProject: Record<string, number> = {};\n\n  for (const entry of entries) {\n    byRuntime[entry.runtime] = (byRuntime[entry.runtime] ?? 0) + 1;\n    const projectName = path.basename(entry.projectPath);\n    byProject[projectName] = (byProject[projectName] ?? 0) + 1;\n  }\n\n  return {\n    totalAgents: stats.totalAgents,\n    activeCount: stats.activeCount,\n    inactiveCount: stats.inactiveCount,\n    staleCount: stats.staleCount,\n    byRuntime,\n    byProject,\n  };\n}\n\n/**\n * Detailed inspection of a single agent — manifest, health, and relay subject.\n *\n * @param agentId - The agent's ULID\n * @returns Full inspection data or undefined if not found\n */\ninspect(agentId: string): MeshInspect | undefined {\n  const entry = this.registry.getWithHealth(agentId);\n  if (!entry) return undefined;\n\n  const { projectPath, lastSeenAt, lastSeenEvent, healthStatus, ...manifest } = entry;\n  const relaySubject = entry.projectPath\n    ? `relay.agent.${path.basename(entry.projectPath)}.${entry.id}`\n    : null;\n\n  return {\n    agent: manifest,\n    health: {\n      agentId: entry.id,\n      name: entry.name,\n      status: healthStatus,\n      lastSeenAt,\n      lastSeenEvent,\n      registeredAt: entry.registeredAt,\n      runtime: entry.runtime,\n      capabilities: entry.capabilities,\n    },\n    relaySubject,\n  };\n}\n```\n\n4. Export the `AgentHealthEntry` and `AggregateStats` types from `packages/mesh/src/index.ts`.\n\n**Testing — add to `packages/mesh/src/__tests__/mesh-core.test.ts`:**\n\n```typescript\nimport type { SignalEmitter } from '@dorkos/relay';\n\n// Create a mock SignalEmitter for tests\nfunction createMockSignalEmitter(): SignalEmitter & { calls: Array<{ subject: string; data: unknown }> } {\n  const calls: Array<{ subject: string; data: unknown }> = [];\n  return {\n    emit(subject: string, data: unknown) { calls.push({ subject, data }); },\n    subscribe() { return () => {}; },\n    removeAllSubscriptions() {},\n    calls,\n  } as any;\n}\n\nit('updateLastSeen() updates registry and emits health_changed signal on transition', () => {\n  const emitter = createMockSignalEmitter();\n  const mesh = new MeshCore({ dataDir: tmpDir, signalEmitter: emitter });\n  // Register an agent (will be stale initially)\n  // ... register agent ...\n  mesh.updateLastSeen(agentId, 'heartbeat');\n  // stale -> active transition should emit\n  expect(emitter.calls.length).toBe(1);\n  expect(emitter.calls[0].subject).toBe('mesh.agent.lifecycle.health_changed');\n  expect(emitter.calls[0].data).toMatchObject({\n    previousStatus: 'stale',\n    currentStatus: 'active',\n  });\n  mesh.close();\n});\n\nit('updateLastSeen() does not emit signal when status unchanged', () => {\n  const emitter = createMockSignalEmitter();\n  const mesh = new MeshCore({ dataDir: tmpDir, signalEmitter: emitter });\n  // Register and set active\n  // ... register agent, updateLastSeen once ...\n  emitter.calls.length = 0; // reset\n  mesh.updateLastSeen(agentId, 'second_heartbeat'); // still active\n  expect(emitter.calls.length).toBe(0);\n  mesh.close();\n});\n\nit('getStatus() returns aggregate health stats', () => {\n  const mesh = new MeshCore({ dataDir: tmpDir });\n  // Register 2 agents\n  const status = mesh.getStatus();\n  expect(status).toMatchObject({\n    totalAgents: expect.any(Number),\n    activeCount: expect.any(Number),\n    inactiveCount: expect.any(Number),\n    staleCount: expect.any(Number),\n    byRuntime: expect.any(Object),\n    byProject: expect.any(Object),\n  });\n  mesh.close();\n});\n\nit('inspect() returns agent + health + relay subject', () => {\n  const mesh = new MeshCore({ dataDir: tmpDir });\n  // Register an agent\n  const result = mesh.inspect(agentId);\n  expect(result).toBeDefined();\n  expect(result!.agent).toBeDefined();\n  expect(result!.health).toBeDefined();\n  expect(result!.relaySubject).toMatch(/^relay\\.agent\\./);\n  mesh.close();\n});\n\nit('inspect() returns undefined for unknown agent', () => {\n  const mesh = new MeshCore({ dataDir: tmpDir });\n  expect(mesh.inspect('nonexistent')).toBeUndefined();\n  mesh.close();\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `updateLastSeen()` updates the registry and emits `health_changed` signal only on status transitions\n- [ ] `getAgentHealth()` returns correct `AgentHealth` shape\n- [ ] `getStatus()` returns `MeshStatus` with `byRuntime` and `byProject` groupings\n- [ ] `inspect()` returns `MeshInspect` with agent manifest, health, and relay subject\n- [ ] `inspect()` returns undefined for non-existent agent\n- [ ] All 5 new tests pass\n- [ ] Existing mesh-core tests still pass\n- [ ] `npm run typecheck` passes",
      "activeForm": "Adding health and diagnostic methods to MeshCore",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Lifecycle Signals & Server",
      "subject": "[mesh-observability-lifecycle] [P2] Extend RelayBridge with SignalEmitter for lifecycle signal emission",
      "description": "Modify `packages/mesh/src/relay-bridge.ts` to accept an optional `SignalEmitter` and emit lifecycle signals on agent registration and unregistration.\n\n**Implementation Steps:**\n\n1. Update the `RelayBridge` constructor and imports:\n\n```typescript\nimport type { SignalEmitter } from '@dorkos/relay';\n\nexport class RelayBridge {\n  constructor(\n    private readonly relayCore?: RelayCore,\n    private readonly signalEmitter?: SignalEmitter,\n  ) {}\n```\n\n2. Emit `mesh.agent.lifecycle.registered` signal in `registerAgent()`:\n\n```typescript\nasync registerAgent(agent: AgentManifest, projectPath: string): Promise<string | null> {\n  if (!this.relayCore) return null;\n  const projectName = path.basename(projectPath);\n  const subject = `relay.agent.${projectName}.${agent.id}`;\n  await this.relayCore.registerEndpoint(subject);\n\n  // Emit lifecycle signal\n  this.signalEmitter?.emit('mesh.agent.lifecycle.registered', {\n    agentId: agent.id,\n    agentName: agent.name,\n    event: 'registered',\n    timestamp: new Date().toISOString(),\n  });\n\n  return subject;\n}\n```\n\n3. Emit `mesh.agent.lifecycle.unregistered` signal in `unregisterAgent()`. Update the method signature to accept an optional agent manifest:\n\n```typescript\nasync unregisterAgent(subject: string, agent?: AgentManifest): Promise<void> {\n  if (!this.relayCore) return;\n  await this.relayCore.unregisterEndpoint(subject);\n\n  if (agent) {\n    this.signalEmitter?.emit('mesh.agent.lifecycle.unregistered', {\n      agentId: agent.id,\n      agentName: agent.name,\n      event: 'unregistered',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n```\n\n4. Add a public helper for health change signals (called by MeshCore):\n\n```typescript\n/**\n * Emit a health_changed lifecycle signal.\n *\n * @param agentId - Agent ULID\n * @param agentName - Agent display name\n * @param previousStatus - The health status before the change\n * @param currentStatus - The health status after the change\n */\nemitHealthChanged(\n  agentId: string,\n  agentName: string,\n  previousStatus: string,\n  currentStatus: string,\n): void {\n  this.signalEmitter?.emit('mesh.agent.lifecycle.health_changed', {\n    agentId,\n    agentName,\n    event: 'health_changed',\n    previousStatus,\n    currentStatus,\n    timestamp: new Date().toISOString(),\n  });\n}\n```\n\n5. Update `MeshCore.unregister()` to pass the agent manifest to `unregisterAgent()`:\n\nIn `packages/mesh/src/mesh-core.ts`, update the `unregister()` method:\n\n```typescript\nasync unregister(agentId: string): Promise<void> {\n  const agent = this.registry.get(agentId);\n  if (!agent) return;\n  const subject = `relay.agent.${path.basename(agent.projectPath)}.${agent.id}`;\n  await this.relayBridge.unregisterAgent(subject, agent); // Pass agent for signal\n  this.registry.remove(agentId);\n}\n```\n\n6. Update `MeshCore` constructor to pass `signalEmitter` to `RelayBridge`:\n\n```typescript\nthis.relayBridge = new RelayBridge(options.relayCore, options.signalEmitter);\n```\n\n**Testing — add to `packages/mesh/src/__tests__/relay-bridge.test.ts`:**\n\n```typescript\nit('registerAgent() emits lifecycle.registered signal', async () => {\n  const mockEmitter = { emit: vi.fn(), subscribe: vi.fn(), removeAllSubscriptions: vi.fn() };\n  const bridge = new RelayBridge(mockRelayCore, mockEmitter as any);\n  await bridge.registerAgent(mockManifest, '/projects/test');\n  expect(mockEmitter.emit).toHaveBeenCalledWith(\n    'mesh.agent.lifecycle.registered',\n    expect.objectContaining({\n      agentId: mockManifest.id,\n      agentName: mockManifest.name,\n      event: 'registered',\n    }),\n  );\n});\n\nit('unregisterAgent() emits lifecycle.unregistered signal', async () => {\n  const mockEmitter = { emit: vi.fn(), subscribe: vi.fn(), removeAllSubscriptions: vi.fn() };\n  const bridge = new RelayBridge(mockRelayCore, mockEmitter as any);\n  await bridge.unregisterAgent('relay.agent.test.01ABC', mockManifest);\n  expect(mockEmitter.emit).toHaveBeenCalledWith(\n    'mesh.agent.lifecycle.unregistered',\n    expect.objectContaining({\n      agentId: mockManifest.id,\n      event: 'unregistered',\n    }),\n  );\n});\n\nit('no signal emitted when SignalEmitter is undefined', async () => {\n  const bridge = new RelayBridge(mockRelayCore); // No emitter\n  // Should not throw\n  await bridge.registerAgent(mockManifest, '/projects/test');\n  await bridge.unregisterAgent('relay.agent.test.01ABC', mockManifest);\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `RelayBridge` accepts optional `SignalEmitter` in constructor\n- [ ] `registerAgent()` emits `mesh.agent.lifecycle.registered` signal with correct payload\n- [ ] `unregisterAgent()` emits `mesh.agent.lifecycle.unregistered` signal when agent manifest provided\n- [ ] `emitHealthChanged()` emits `mesh.agent.lifecycle.health_changed` signal\n- [ ] No signals emitted when `SignalEmitter` is undefined (no-op behavior)\n- [ ] All 3 new tests pass\n- [ ] Existing relay-bridge tests still pass",
      "activeForm": "Extending RelayBridge with lifecycle signal emission",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Lifecycle Signals & Server",
      "subject": "[mesh-observability-lifecycle] [P2] Add mesh observability HTTP routes (status, health, heartbeat)",
      "description": "Add three new HTTP endpoints to `apps/server/src/routes/mesh.ts`: `GET /status`, `GET /agents/:id/health`, and `POST /agents/:id/heartbeat`.\n\n**Implementation Steps:**\n\n1. Import the new schema at the top of `mesh.ts`:\n\n```typescript\nimport { HeartbeatRequestSchema } from '@dorkos/shared/mesh-schemas';\n```\n\n2. Add the three new routes inside `createMeshRouter()`, before the existing `POST /discover` route:\n\n```typescript\n// GET /status — Aggregate mesh health stats\nrouter.get('/status', (_req, res) => {\n  try {\n    const status = meshCore.getStatus();\n    res.json(status);\n  } catch (err) {\n    res.status(500).json({ error: (err as Error).message });\n  }\n});\n\n// GET /agents/:id/health — Single agent health detail\nrouter.get('/agents/:id/health', (req, res) => {\n  const health = meshCore.getAgentHealth(req.params.id);\n  if (!health) return res.status(404).json({ error: 'Agent not found' });\n  res.json(health);\n});\n\n// POST /agents/:id/heartbeat — Update agent last-seen timestamp\nrouter.post('/agents/:id/heartbeat', (req, res) => {\n  const agent = meshCore.get(req.params.id);\n  if (!agent) return res.status(404).json({ error: 'Agent not found' });\n\n  const parse = HeartbeatRequestSchema.safeParse(req.body);\n  const event = parse.success ? parse.data.event : 'heartbeat';\n\n  meshCore.updateLastSeen(req.params.id, event);\n  res.json({ success: true, agentId: req.params.id });\n});\n```\n\nNote: The `GET /agents/:id/health` route must be placed BEFORE the existing `GET /agents/:id` route to avoid the `:id` param capturing 'health' as a literal ID. Alternatively, ensure the health route comes first in definition order since Express matches routes in order.\n\n**Testing — add to `apps/server/src/routes/__tests__/mesh.test.ts`:**\n\n```typescript\nit('GET /status returns aggregate health stats', async () => {\n  mockMeshCore.getStatus.mockReturnValue({\n    totalAgents: 5,\n    activeCount: 3,\n    inactiveCount: 1,\n    staleCount: 1,\n    byRuntime: { 'claude-code': 3, cursor: 2 },\n    byProject: { 'project-a': 3, 'project-b': 2 },\n  });\n  const res = await request(app).get('/api/mesh/status');\n  expect(res.status).toBe(200);\n  expect(res.body.totalAgents).toBe(5);\n  expect(res.body.activeCount).toBe(3);\n  expect(res.body.byRuntime['claude-code']).toBe(3);\n});\n\nit('GET /agents/:id/health returns agent health', async () => {\n  mockMeshCore.getAgentHealth.mockReturnValue({\n    agentId: 'test-id',\n    name: 'Test Agent',\n    status: 'active',\n    lastSeenAt: '2026-02-25T10:00:00.000Z',\n    lastSeenEvent: 'heartbeat',\n    registeredAt: '2026-02-25T09:00:00.000Z',\n    runtime: 'claude-code',\n    capabilities: ['code-review'],\n  });\n  const res = await request(app).get('/api/mesh/agents/test-id/health');\n  expect(res.status).toBe(200);\n  expect(res.body.status).toBe('active');\n  expect(res.body.agentId).toBe('test-id');\n});\n\nit('GET /agents/:id/health returns 404 for unknown agent', async () => {\n  mockMeshCore.getAgentHealth.mockReturnValue(undefined);\n  const res = await request(app).get('/api/mesh/agents/unknown/health');\n  expect(res.status).toBe(404);\n});\n\nit('POST /agents/:id/heartbeat updates last seen', async () => {\n  mockMeshCore.get.mockReturnValue({ id: 'test-id', name: 'Test' });\n  mockMeshCore.updateLastSeen.mockReturnValue(undefined);\n  const res = await request(app)\n    .post('/api/mesh/agents/test-id/heartbeat')\n    .send({ event: 'ping' });\n  expect(res.status).toBe(200);\n  expect(res.body.success).toBe(true);\n  expect(mockMeshCore.updateLastSeen).toHaveBeenCalledWith('test-id', 'ping');\n});\n\nit('POST /agents/:id/heartbeat returns 404 for unknown agent', async () => {\n  mockMeshCore.get.mockReturnValue(undefined);\n  const res = await request(app)\n    .post('/api/mesh/agents/unknown/heartbeat')\n    .send({});\n  expect(res.status).toBe(404);\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `GET /api/mesh/status` returns `MeshStatus` JSON shape\n- [ ] `GET /api/mesh/agents/:id/health` returns `AgentHealth` JSON shape\n- [ ] `GET /api/mesh/agents/:id/health` returns 404 for unknown agent\n- [ ] `POST /api/mesh/agents/:id/heartbeat` calls `meshCore.updateLastSeen()` with correct event\n- [ ] `POST /api/mesh/agents/:id/heartbeat` returns 404 for unknown agent\n- [ ] `POST /agents/:id/heartbeat` defaults to 'heartbeat' event when body is empty\n- [ ] All 5 new route tests pass\n- [ ] Existing mesh route tests still pass",
      "activeForm": "Adding mesh observability HTTP routes",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Lifecycle Signals & Server",
      "subject": "[mesh-observability-lifecycle] [P2] Add mesh_status and mesh_inspect MCP diagnostic tools",
      "description": "Add two new MCP tools (`mesh_status` and `mesh_inspect`) to `apps/server/src/services/core/mcp-tool-server.ts` for agent-driven mesh inspection.\n\n**Implementation Steps:**\n\n1. In the `registerMeshTools()` section of `mcp-tool-server.ts`, add two new tools after the existing mesh tools:\n\n```typescript\ntool('mesh_status', {\n  description: 'Get aggregate mesh health stats (total agents, by runtime, by status)',\n  parameters: z.object({}),\n  execute: async () => {\n    const guard = requireMesh(deps);\n    if (guard) return guard;\n    const status = deps.meshCore!.getStatus();\n    return jsonContent(status);\n  },\n});\n\ntool('mesh_inspect', {\n  description: 'Get detailed view of a specific agent (manifest, health, relay endpoint)',\n  parameters: z.object({\n    agentId: z.string().describe('ULID of the agent to inspect'),\n  }),\n  execute: async ({ agentId }) => {\n    const guard = requireMesh(deps);\n    if (guard) return guard;\n    const detail = deps.meshCore!.inspect(agentId);\n    if (!detail) return jsonContent({ error: 'Agent not found' }, true);\n    return jsonContent(detail);\n  },\n});\n```\n\n2. Add the new tools to the tool list constant used for tool name validation/listing (if one exists).\n\n**Testing — add to `apps/server/src/services/core/__tests__/mcp-mesh-tools.test.ts`:**\n\n```typescript\nit('mesh_status tool returns aggregate stats', async () => {\n  mockMeshCore.getStatus.mockReturnValue({\n    totalAgents: 3,\n    activeCount: 2,\n    inactiveCount: 1,\n    staleCount: 0,\n    byRuntime: { 'claude-code': 3 },\n    byProject: { 'my-project': 3 },\n  });\n  const result = await executeTool('mesh_status', {});\n  const parsed = JSON.parse(result.content[0].text);\n  expect(parsed.totalAgents).toBe(3);\n  expect(parsed.activeCount).toBe(2);\n});\n\nit('mesh_inspect tool returns agent detail', async () => {\n  mockMeshCore.inspect.mockReturnValue({\n    agent: { id: '01ABC', name: 'Test Agent', runtime: 'claude-code' },\n    health: { agentId: '01ABC', status: 'active', lastSeenAt: '2026-02-25T10:00:00Z' },\n    relaySubject: 'relay.agent.test.01ABC',\n  });\n  const result = await executeTool('mesh_inspect', { agentId: '01ABC' });\n  const parsed = JSON.parse(result.content[0].text);\n  expect(parsed.agent.id).toBe('01ABC');\n  expect(parsed.relaySubject).toBe('relay.agent.test.01ABC');\n});\n\nit('mesh_inspect tool returns error for unknown agent', async () => {\n  mockMeshCore.inspect.mockReturnValue(undefined);\n  const result = await executeTool('mesh_inspect', { agentId: 'nonexistent' });\n  expect(result.isError).toBe(true);\n});\n\nit('mesh_status returns error when mesh disabled', async () => {\n  // Test with meshCore undefined\n  const result = await executeToolWithNullMesh('mesh_status', {});\n  const parsed = JSON.parse(result.content[0].text);\n  expect(parsed.error).toContain('MESH_DISABLED');\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `mesh_status` tool returns aggregate stats from `meshCore.getStatus()`\n- [ ] `mesh_inspect` tool returns detailed agent info from `meshCore.inspect()`\n- [ ] `mesh_inspect` returns error with `isError: true` for unknown agent ID\n- [ ] Both tools return MESH_DISABLED error when mesh is not enabled\n- [ ] Both tools use the existing `requireMesh()` guard function\n- [ ] All 4 new tests pass\n- [ ] Existing MCP tool tests still pass",
      "activeForm": "Adding mesh_status and mesh_inspect MCP diagnostic tools",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.1", "2.2"]
    },
    {
      "id": "2.4",
      "phase": 2,
      "phaseName": "Lifecycle Signals & Server",
      "subject": "[mesh-observability-lifecycle] [P2] Wire SignalEmitter through server index.ts and subscribe to lifecycle events",
      "description": "Update `apps/server/src/index.ts` to pass `signalEmitter` to `MeshCore` and set up SSE broadcasting of lifecycle events.\n\n**Implementation Steps:**\n\n1. In `apps/server/src/index.ts`, where `meshCore` is initialized, extract the `SignalEmitter` from `relayCore` and pass it through:\n\n```typescript\n// After relayCore is created (if mesh + relay are both enabled):\nif (meshEnabled) {\n  meshCore = new MeshCore({\n    dataDir: path.join(dorkHome, 'mesh'),\n    relayCore,\n    signalEmitter: relayCore ? /* need to access relayCore's signalEmitter */ undefined : undefined,\n  });\n}\n```\n\nSince `RelayCore.signalEmitter` is private, the preferred approach is to use RelayCore's public `signal()` and `onSignal()` methods. Create a thin adapter:\n\n```typescript\n// Create a SignalEmitter-compatible adapter using RelayCore's public API\nfunction createRelaySignalAdapter(relayCore: RelayCore) {\n  return {\n    emit: (subject: string, data: unknown) => {\n      relayCore.signal(subject, data as any);\n    },\n    subscribe: (pattern: string, handler: (subject: string, data: unknown) => void) => {\n      return relayCore.onSignal(pattern, handler as any);\n    },\n    removeAllSubscriptions: () => { /* no-op — RelayCore manages its own cleanup */ },\n  };\n}\n```\n\nPass this adapter as the `signalEmitter` option:\n\n```typescript\nmeshCore = new MeshCore({\n  dataDir: path.join(dorkHome, 'mesh'),\n  relayCore,\n  signalEmitter: relayCore ? createRelaySignalAdapter(relayCore) : undefined,\n});\n```\n\n2. Subscribe to mesh lifecycle signals for potential future SSE broadcasting:\n\n```typescript\n// After mesh + relay initialization:\nif (meshCore && relayCore) {\n  relayCore.onSignal('mesh.agent.lifecycle.>', (subject, signal) => {\n    // Log lifecycle events for diagnostics\n    console.log(`[mesh] lifecycle event: ${subject}`, signal);\n    // Future: broadcast to SSE clients via meshLifecycleBroadcaster\n  });\n}\n```\n\n**Acceptance Criteria:**\n- [ ] `MeshCore` receives a SignalEmitter adapter when both Mesh and Relay are enabled\n- [ ] Lifecycle signals are emitted through RelayCore's public `signal()` API\n- [ ] Server starts successfully with both mesh and relay enabled\n- [ ] Server starts successfully with mesh enabled but relay disabled (signalEmitter is undefined)\n- [ ] Lifecycle events are logged to console for diagnostics",
      "activeForm": "Wiring SignalEmitter through server initialization",
      "size": "small",
      "priority": "medium",
      "dependencies": ["2.1"],
      "parallelWith": []
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Install React Flow dependencies and add CSS import",
      "description": "Install the required npm packages for topology visualization and add the React Flow CSS import.\n\n**Implementation Steps:**\n\n1. Install dependencies in `apps/client`:\n\n```bash\nnpm install @xyflow/react@^12 dagre@^0.8 -w apps/client\nnpm install -D @types/dagre@^0.7 -w apps/client\n```\n\n2. Add the React Flow CSS import to `apps/client/src/index.css`. This must be a top-level import, NOT inside a component:\n\n```css\n@import '@xyflow/react/dist/style.css';\n```\n\nPlace this import near the top of the file, alongside other third-party CSS imports.\n\n3. Verify the imports work by running `npm run build -- --filter=@dorkos/client` (or the dev server).\n\n**Acceptance Criteria:**\n- [ ] `@xyflow/react` (v12+), `dagre`, and `@types/dagre` are in `apps/client/package.json`\n- [ ] `@xyflow/react/dist/style.css` is imported in `index.css`\n- [ ] Client build succeeds without errors\n- [ ] No other packages affected by the install",
      "activeForm": "Installing React Flow dependencies and adding CSS import",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": ["1.1", "1.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Add Transport interface methods and HttpTransport implementation for mesh observability",
      "description": "Extend the `Transport` interface in `packages/shared/src/transport.ts` with three new methods for mesh observability, and implement them in `HttpTransport`.\n\n**Implementation Steps:**\n\n1. Add imports for the new types at the top of `transport.ts`:\n\n```typescript\nimport type { AgentHealth, MeshStatus } from './mesh-schemas';\n```\n\n(These types may already be importable from the mesh-schemas module after Task 1.1 completes.)\n\n2. Add three new methods to the `Transport` interface:\n\n```typescript\n/** Get aggregate mesh health status. */\ngetMeshStatus(): Promise<MeshStatus>;\n\n/** Get health details for a single agent. */\ngetMeshAgentHealth(id: string): Promise<AgentHealth>;\n\n/** Send a heartbeat for an agent to update its last-seen timestamp. */\nsendMeshHeartbeat(id: string, event?: string): Promise<{ success: boolean }>;\n```\n\n3. Implement in `HttpTransport` class:\n\n```typescript\ngetMeshStatus(): Promise<MeshStatus> {\n  return fetchJSON(this.baseUrl, '/mesh/status');\n}\n\ngetMeshAgentHealth(id: string): Promise<AgentHealth> {\n  return fetchJSON(this.baseUrl, `/mesh/agents/${id}/health`);\n}\n\nsendMeshHeartbeat(id: string, event?: string): Promise<{ success: boolean }> {\n  return fetchJSON(this.baseUrl, `/mesh/agents/${id}/heartbeat`, {\n    method: 'POST',\n    body: JSON.stringify({ ...(event && { event }) }),\n  });\n}\n```\n\n4. Add stub implementations to `DirectTransport` (Obsidian plugin) if it exists, or ensure the interface is satisfied. Stubs can throw `new Error('Not implemented')` for now.\n\n5. Update `packages/test-utils/` mock transport factory (`createMockTransport`) to include the new methods:\n\n```typescript\ngetMeshStatus: vi.fn().mockResolvedValue({\n  totalAgents: 0,\n  activeCount: 0,\n  inactiveCount: 0,\n  staleCount: 0,\n  byRuntime: {},\n  byProject: {},\n}),\ngetMeshAgentHealth: vi.fn().mockResolvedValue(undefined),\nsendMeshHeartbeat: vi.fn().mockResolvedValue({ success: true }),\n```\n\n**Acceptance Criteria:**\n- [ ] `Transport` interface has `getMeshStatus()`, `getMeshAgentHealth()`, and `sendMeshHeartbeat()` methods\n- [ ] `HttpTransport` implements all three methods with correct HTTP calls\n- [ ] `DirectTransport` (if exists) has stub implementations\n- [ ] Mock transport factory in `test-utils` includes the new methods\n- [ ] `npm run typecheck` passes across the entire monorepo",
      "activeForm": "Adding Transport interface methods for mesh observability",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["3.1"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Create mesh observability entity hooks (useMeshStatus, useMeshAgentHealth, useMeshHeartbeat)",
      "description": "Create three new TanStack Query hooks in `apps/client/src/layers/entities/mesh/model/` and update the barrel exports.\n\n**Implementation Steps:**\n\n1. Create `apps/client/src/layers/entities/mesh/model/use-mesh-status.ts`:\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\nconst MESH_STATUS_KEY = ['mesh', 'status'] as const;\n\n/**\n * Fetch aggregate mesh health status with 30-second polling.\n *\n * @param enabled - Whether to enable the query (default: true)\n */\nexport function useMeshStatus(enabled = true) {\n  const transport = useTransport();\n  return useQuery({\n    queryKey: [...MESH_STATUS_KEY],\n    queryFn: () => transport.getMeshStatus(),\n    enabled,\n    staleTime: 30_000,\n    refetchInterval: 30_000,\n  });\n}\n```\n\n2. Create `apps/client/src/layers/entities/mesh/model/use-mesh-agent-health.ts`:\n\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\nconst MESH_HEALTH_KEY = ['mesh', 'health'] as const;\n\n/**\n * Fetch health details for a single agent.\n *\n * @param agentId - Agent ULID, or null to disable the query\n */\nexport function useMeshAgentHealth(agentId: string | null) {\n  const transport = useTransport();\n  return useQuery({\n    queryKey: [...MESH_HEALTH_KEY, agentId],\n    queryFn: () => transport.getMeshAgentHealth(agentId!),\n    enabled: !!agentId,\n    staleTime: 15_000,\n  });\n}\n```\n\n3. Create `apps/client/src/layers/entities/mesh/model/use-mesh-heartbeat.ts`:\n\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\n\n/**\n * Mutation hook to send a heartbeat for an agent.\n * Invalidates mesh status and health queries on success.\n */\nexport function useMeshHeartbeat() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ id, event }: { id: string; event?: string }) =>\n      transport.sendMeshHeartbeat(id, event),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'status'] });\n      queryClient.invalidateQueries({ queryKey: ['mesh', 'health'] });\n    },\n  });\n}\n```\n\n4. Update the barrel export at `apps/client/src/layers/entities/mesh/index.ts`:\n\n```typescript\nexport { useMeshStatus } from './model/use-mesh-status';\nexport { useMeshAgentHealth } from './model/use-mesh-agent-health';\nexport { useMeshHeartbeat } from './model/use-mesh-heartbeat';\n```\n\n**Testing — create `apps/client/src/layers/entities/mesh/__tests__/use-mesh-status.test.ts`:**\n\n```typescript\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { useMeshStatus } from '../model/use-mesh-status';\nimport { createMockTransport } from '@dorkos/test-utils';\n// Set up QueryClient wrapper with TransportProvider\n\nit('fetches from transport.getMeshStatus()', async () => {\n  const mockTransport = createMockTransport();\n  mockTransport.getMeshStatus.mockResolvedValue({\n    totalAgents: 5, activeCount: 3, inactiveCount: 1, staleCount: 1,\n    byRuntime: {}, byProject: {},\n  });\n  const { result } = renderHook(() => useMeshStatus(), { wrapper: createWrapper(mockTransport) });\n  await waitFor(() => expect(result.current.data).toBeDefined());\n  expect(result.current.data!.totalAgents).toBe(5);\n  expect(mockTransport.getMeshStatus).toHaveBeenCalled();\n});\n\nit('polls every 30 seconds', () => {\n  // Verify refetchInterval is set by checking the query config\n  // This is a config test — render the hook and verify it doesn't error\n});\n\nit('disabled when enabled=false', async () => {\n  const mockTransport = createMockTransport();\n  renderHook(() => useMeshStatus(false), { wrapper: createWrapper(mockTransport) });\n  // Wait a tick and verify no fetch was made\n  await new Promise((r) => setTimeout(r, 50));\n  expect(mockTransport.getMeshStatus).not.toHaveBeenCalled();\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `useMeshStatus` hook fetches mesh status with 30s polling\n- [ ] `useMeshAgentHealth` hook fetches agent health by ID, disabled when ID is null\n- [ ] `useMeshHeartbeat` mutation invalidates status and health queries on success\n- [ ] All three hooks are exported from the mesh entity barrel\n- [ ] 3 tests pass for `useMeshStatus`\n- [ ] `npm run typecheck` passes",
      "activeForm": "Creating mesh observability entity hooks",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.2"],
      "parallelWith": []
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Create TopologyGraph, AgentNode, and dagre layout components",
      "description": "Create the topology visualization components using React Flow v12 and dagre layout in `apps/client/src/layers/features/mesh/ui/`.\n\n**Implementation Steps:**\n\n1. Create `apps/client/src/layers/features/mesh/ui/AgentNode.tsx`:\n\n```typescript\nimport { memo } from 'react';\nimport { Handle, Position } from '@xyflow/react';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport type { AgentHealthStatus } from '@dorkos/shared/mesh-schemas';\n\nconst STATUS_COLORS: Record<AgentHealthStatus, string> = {\n  active: 'bg-green-500',\n  inactive: 'bg-amber-500',\n  stale: 'bg-neutral-400',\n} as const;\n\ninterface AgentNodeData {\n  id: string;\n  name: string;\n  runtime: string;\n  capabilities: string[];\n  healthStatus: AgentHealthStatus;\n}\n\n/** Custom React Flow node rendering an agent card with health indicator. */\nexport const AgentNode = memo(function AgentNode({ data }: { data: AgentNodeData }) {\n  return (\n    <div className=\"rounded-xl border bg-card p-3 shadow-sm\">\n      <Handle type=\"target\" position={Position.Left} className=\"invisible\" />\n      <div className=\"flex items-center gap-2\">\n        <span className={`size-2.5 rounded-full ${STATUS_COLORS[data.healthStatus]}`} />\n        <span className=\"text-sm font-medium\">{data.name}</span>\n      </div>\n      <div className=\"mt-1 flex items-center gap-1.5\">\n        <Badge variant=\"secondary\" className=\"text-xs\">\n          {data.runtime}\n        </Badge>\n        {data.capabilities.slice(0, 2).map((cap) => (\n          <Badge key={cap} variant=\"outline\" className=\"text-xs\">\n            {cap}\n          </Badge>\n        ))}\n      </div>\n      <Handle type=\"source\" position={Position.Right} className=\"invisible\" />\n    </div>\n  );\n});\n```\n\n2. Create `apps/client/src/layers/features/mesh/ui/TopologyGraph.tsx`:\n\n```typescript\nimport { useState, useEffect, useMemo } from 'react';\nimport { ReactFlow, Controls, Background, useNodesState, useEdgesState } from '@xyflow/react';\nimport dagre from 'dagre';\nimport { AgentNode } from './AgentNode';\nimport { AgentHealthDetail } from './AgentHealthDetail';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\n// IMPORTANT: nodeTypes must be defined outside the component to avoid re-renders\nconst nodeTypes = { agent: AgentNode };\n\ninterface AgentWithHealth extends AgentManifest {\n  healthStatus?: 'active' | 'inactive' | 'stale';\n}\n\n/**\n * Layout agents as nodes using dagre's directed graph algorithm.\n *\n * Uses LTR (left-to-right) layout with 60px node separation and 100px rank separation.\n * Returns positioned nodes and empty edges array (no edges for v1 flat topology).\n */\nfunction layoutWithDagre(agents: AgentWithHealth[]) {\n  const g = new dagre.graphlib.Graph();\n  g.setGraph({ rankdir: 'LR', nodesep: 60, ranksep: 100 });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  agents.forEach((agent) => {\n    g.setNode(agent.id, { width: 200, height: 80 });\n  });\n\n  dagre.layout(g);\n\n  const nodes = agents.map((agent) => {\n    const pos = g.node(agent.id);\n    return {\n      id: agent.id,\n      type: 'agent' as const,\n      position: { x: pos.x - 100, y: pos.y - 40 },\n      data: {\n        id: agent.id,\n        name: agent.name,\n        runtime: agent.runtime,\n        capabilities: agent.capabilities,\n        healthStatus: agent.healthStatus ?? 'stale',\n      },\n    };\n  });\n\n  return { nodes, edges: [] as never[] };\n}\n\n/** Topology network graph showing agents as cards with health status indicators. */\nexport function TopologyGraph({ agents }: { agents: AgentWithHealth[] }) {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const [selectedAgent, setSelectedAgent] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (agents.length === 0) return;\n    const { nodes: laid, edges: laidEdges } = layoutWithDagre(agents);\n    setNodes(laid);\n    setEdges(laidEdges);\n  }, [agents, setNodes, setEdges]);\n\n  if (agents.length === 0) {\n    return (\n      <div className=\"flex h-full flex-col items-center justify-center gap-2 text-muted-foreground\">\n        <p className=\"text-sm\">No agents registered.</p>\n        <p className=\"text-xs\">Discover and register agents from the Discovery tab.</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"h-full w-full\">\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        nodeTypes={nodeTypes}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onNodeClick={(_, node) => setSelectedAgent(node.id)}\n        fitView\n      >\n        <Controls />\n        <Background />\n      </ReactFlow>\n      {selectedAgent && (\n        <AgentHealthDetail\n          agentId={selectedAgent}\n          onClose={() => setSelectedAgent(null)}\n        />\n      )}\n    </div>\n  );\n}\n```\n\n**Acceptance Criteria:**\n- [ ] `AgentNode` renders agent name, health status dot (green/amber/grey), runtime badge, and up to 2 capability badges\n- [ ] `AgentNode` is wrapped in `React.memo` for performance\n- [ ] `TopologyGraph` uses dagre to position nodes in LTR layout\n- [ ] `TopologyGraph` shows empty state message when no agents\n- [ ] Clicking a node opens `AgentHealthDetail` panel\n- [ ] `nodeTypes` is defined outside component (React Flow requirement)\n- [ ] Handles are invisible (no edges in v1) but present for future compatibility\n- [ ] `npm run typecheck` passes",
      "activeForm": "Creating topology graph and agent node components",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1", "3.3"],
      "parallelWith": ["3.5"]
    },
    {
      "id": "3.5",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Create MeshStatsHeader and AgentHealthDetail components",
      "description": "Create the stats header and agent health detail panel components.\n\n**Implementation Steps:**\n\n1. Create `apps/client/src/layers/features/mesh/ui/MeshStatsHeader.tsx`:\n\n```typescript\nimport { useMeshStatus } from '@/layers/entities/mesh';\n\ninterface MeshStatsHeaderProps {\n  enabled: boolean;\n}\n\n/** Compact stats bar showing aggregate agent health counts. */\nexport function MeshStatsHeader({ enabled }: MeshStatsHeaderProps) {\n  const { data: status, isLoading } = useMeshStatus(enabled);\n\n  if (!enabled || isLoading || !status) return null;\n\n  return (\n    <div className=\"mx-4 mt-3 flex items-center gap-3 text-xs text-muted-foreground\">\n      <span>{status.totalAgents} agents</span>\n      <span className=\"text-green-600 dark:text-green-400\">\n        {status.activeCount} active\n      </span>\n      <span className=\"text-amber-600 dark:text-amber-400\">\n        {status.inactiveCount} inactive\n      </span>\n      <span>{status.staleCount} stale</span>\n    </div>\n  );\n}\n```\n\n2. Create `apps/client/src/layers/features/mesh/ui/AgentHealthDetail.tsx`:\n\n```typescript\nimport { X, Loader2 } from 'lucide-react';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { useMeshAgentHealth } from '@/layers/entities/mesh';\n\ninterface AgentHealthDetailProps {\n  agentId: string;\n  onClose: () => void;\n}\n\n/**\n * Format an ISO timestamp as a relative time string.\n * Uses simple logic: seconds, minutes, hours, or days ago.\n */\nfunction formatRelative(isoString: string): string {\n  const diff = Date.now() - new Date(isoString).getTime();\n  const seconds = Math.floor(diff / 1000);\n  if (seconds < 60) return `${seconds}s ago`;\n  const minutes = Math.floor(seconds / 60);\n  if (minutes < 60) return `${minutes}m ago`;\n  const hours = Math.floor(minutes / 60);\n  if (hours < 24) return `${hours}h ago`;\n  const days = Math.floor(hours / 24);\n  return `${days}d ago`;\n}\n\n/** Detail panel shown when clicking an agent node — shows health, runtime, capabilities. */\nexport function AgentHealthDetail({ agentId, onClose }: AgentHealthDetailProps) {\n  const { data: health, isLoading } = useMeshAgentHealth(agentId);\n\n  if (isLoading) {\n    return (\n      <div className=\"absolute right-0 top-0 z-10 flex w-80 items-center justify-center rounded-xl border bg-card p-8 shadow-lg\">\n        <Loader2 className=\"size-4 animate-spin\" />\n      </div>\n    );\n  }\n\n  if (!health) return null;\n\n  return (\n    <div className=\"absolute right-0 top-0 z-10 w-80 rounded-xl border bg-card p-4 shadow-lg\">\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"font-medium\">{health.name}</h3>\n        <button\n          type=\"button\"\n          onClick={onClose}\n          aria-label=\"Close health detail\"\n          className=\"rounded p-1 text-muted-foreground hover:bg-muted\"\n        >\n          <X className=\"size-4\" />\n        </button>\n      </div>\n      <div className=\"mt-3 space-y-2 text-sm\">\n        <div className=\"flex justify-between\">\n          <span className=\"text-muted-foreground\">Status</span>\n          <Badge variant={health.status === 'active' ? 'default' : 'secondary'}>\n            {health.status}\n          </Badge>\n        </div>\n        <div className=\"flex justify-between\">\n          <span className=\"text-muted-foreground\">Last seen</span>\n          <span>{health.lastSeenAt ? formatRelative(health.lastSeenAt) : 'Never'}</span>\n        </div>\n        <div className=\"flex justify-between\">\n          <span className=\"text-muted-foreground\">Last event</span>\n          <span>{health.lastSeenEvent ?? 'N/A'}</span>\n        </div>\n        <div className=\"flex justify-between\">\n          <span className=\"text-muted-foreground\">Runtime</span>\n          <Badge variant=\"secondary\">{health.runtime}</Badge>\n        </div>\n        <div className=\"flex justify-between\">\n          <span className=\"text-muted-foreground\">Registered</span>\n          <span>{formatRelative(health.registeredAt)}</span>\n        </div>\n        {health.capabilities.length > 0 && (\n          <div className=\"flex flex-wrap gap-1 pt-1\">\n            {health.capabilities.map((cap) => (\n              <Badge key={cap} variant=\"outline\" className=\"text-xs\">{cap}</Badge>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n**Testing — create `apps/client/src/layers/features/mesh/__tests__/MeshStatsHeader.test.tsx`:**\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { MeshStatsHeader } from '../ui/MeshStatsHeader';\n\n// Mock useMeshStatus\nvi.mock('@/layers/entities/mesh', () => ({\n  useMeshStatus: vi.fn(),\n}));\n\nimport { useMeshStatus } from '@/layers/entities/mesh';\n\nit('renders nothing when disabled', () => {\n  vi.mocked(useMeshStatus).mockReturnValue({ data: undefined, isLoading: false } as any);\n  const { container } = render(<MeshStatsHeader enabled={false} />);\n  expect(container.firstChild).toBeNull();\n});\n\nit('renders nothing when loading', () => {\n  vi.mocked(useMeshStatus).mockReturnValue({ data: undefined, isLoading: true } as any);\n  const { container } = render(<MeshStatsHeader enabled={true} />);\n  expect(container.firstChild).toBeNull();\n});\n\nit('displays correct counts', () => {\n  vi.mocked(useMeshStatus).mockReturnValue({\n    data: { totalAgents: 10, activeCount: 5, inactiveCount: 3, staleCount: 2, byRuntime: {}, byProject: {} },\n    isLoading: false,\n  } as any);\n  render(<MeshStatsHeader enabled={true} />);\n  expect(screen.getByText('10 agents')).toBeInTheDocument();\n  expect(screen.getByText('5 active')).toBeInTheDocument();\n  expect(screen.getByText('3 inactive')).toBeInTheDocument();\n  expect(screen.getByText('2 stale')).toBeInTheDocument();\n});\n\nit('uses correct color classes for status counts', () => {\n  vi.mocked(useMeshStatus).mockReturnValue({\n    data: { totalAgents: 3, activeCount: 1, inactiveCount: 1, staleCount: 1, byRuntime: {}, byProject: {} },\n    isLoading: false,\n  } as any);\n  render(<MeshStatsHeader enabled={true} />);\n  const activeEl = screen.getByText('1 active');\n  expect(activeEl.className).toContain('text-green');\n  const inactiveEl = screen.getByText('1 inactive');\n  expect(inactiveEl.className).toContain('text-amber');\n});\n```\n\n**Acceptance Criteria:**\n- [ ] `MeshStatsHeader` renders null when disabled, loading, or no data\n- [ ] `MeshStatsHeader` displays total, active (green), inactive (amber), and stale counts\n- [ ] `AgentHealthDetail` shows health status, last seen (relative time), last event, runtime, registered time, and capabilities\n- [ ] `AgentHealthDetail` shows loading spinner while fetching\n- [ ] `AgentHealthDetail` has close button with aria-label\n- [ ] All 4 MeshStatsHeader tests pass",
      "activeForm": "Creating MeshStatsHeader and AgentHealthDetail components",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.3"],
      "parallelWith": ["3.4"]
    },
    {
      "id": "3.6",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Update MeshPanel with Topology tab, stats header, and lazy-loaded graph",
      "description": "Update `apps/client/src/layers/features/mesh/ui/MeshPanel.tsx` to add the Topology tab as the new default, include the stats header, and lazy-load the TopologyGraph.\n\n**Implementation Steps:**\n\n1. Add imports at the top of `MeshPanel.tsx`:\n\n```typescript\nimport { lazy, Suspense } from 'react';\nimport { MeshStatsHeader } from './MeshStatsHeader';\n```\n\n2. Add the lazy-loaded TopologyGraph before the MeshPanel component:\n\n```typescript\nconst LazyTopologyGraph = lazy(() =>\n  import('./TopologyGraph').then((m) => ({ default: m.TopologyGraph }))\n);\n```\n\n3. Modify the `MeshPanel` component's return JSX:\n\n- Change the default tab from `\"discovery\"` to `\"topology\"`\n- Add `<MeshStatsHeader enabled={meshEnabled} />` before the TabsList\n- Add a new Topology tab trigger and content\n- Add `mt-2` to TabsList (instead of `mt-3`) to account for the stats header taking space\n\nUpdated MeshPanel return:\n\n```typescript\nreturn (\n  <Tabs defaultValue=\"topology\" className=\"flex h-full flex-col\">\n    <MeshStatsHeader enabled={meshEnabled} />\n    <TabsList className=\"mx-4 mt-2 shrink-0\">\n      <TabsTrigger value=\"topology\">Topology</TabsTrigger>\n      <TabsTrigger value=\"discovery\">Discovery</TabsTrigger>\n      <TabsTrigger value=\"agents\">Agents</TabsTrigger>\n      <TabsTrigger value=\"denied\">Denied</TabsTrigger>\n    </TabsList>\n\n    <TabsContent value=\"topology\" className=\"relative min-h-0 flex-1\">\n      <Suspense fallback={\n        <div className=\"flex items-center justify-center p-8\">\n          <Loader2 className=\"size-5 animate-spin text-muted-foreground\" />\n        </div>\n      }>\n        <LazyTopologyGraph agents={agents} />\n      </Suspense>\n    </TabsContent>\n\n    <TabsContent value=\"discovery\" className=\"min-h-0 flex-1 overflow-y-auto\">\n      <DiscoveryTab />\n    </TabsContent>\n\n    <TabsContent value=\"agents\" className=\"min-h-0 flex-1 overflow-y-auto\">\n      <AgentsTab agents={agents} isLoading={agentsLoading} />\n    </TabsContent>\n\n    <TabsContent value=\"denied\" className=\"min-h-0 flex-1 overflow-y-auto\">\n      <DeniedTab denied={denied} isLoading={deniedLoading} />\n    </TabsContent>\n  </Tabs>\n);\n```\n\n4. Update the existing MeshPanel test at `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx` to account for the new default tab and the fourth Topology tab.\n\n**Testing — update `apps/client/src/layers/features/mesh/__tests__/MeshPanel.test.tsx`:**\n\n```typescript\nit('renders Topology tab as default', () => {\n  render(<MeshPanel />, { wrapper: Wrapper });\n  const topologyTab = screen.getByRole('tab', { name: /topology/i });\n  expect(topologyTab).toHaveAttribute('data-state', 'active');\n});\n\nit('renders stats header with aggregate counts', () => {\n  // Mock useMeshStatus to return data\n  render(<MeshPanel />, { wrapper: Wrapper });\n  // Verify stats header renders\n});\n\nit('renders all four tabs', () => {\n  render(<MeshPanel />, { wrapper: Wrapper });\n  expect(screen.getByRole('tab', { name: /topology/i })).toBeInTheDocument();\n  expect(screen.getByRole('tab', { name: /discovery/i })).toBeInTheDocument();\n  expect(screen.getByRole('tab', { name: /agents/i })).toBeInTheDocument();\n  expect(screen.getByRole('tab', { name: /denied/i })).toBeInTheDocument();\n});\n```\n\n**Acceptance Criteria:**\n- [ ] MeshPanel default tab is `\"topology\"` (was `\"discovery\"`)\n- [ ] Stats header renders above the tab list when mesh is enabled\n- [ ] Topology tab contains lazy-loaded `TopologyGraph` with Suspense fallback\n- [ ] All four tabs (Topology, Discovery, Agents, Denied) are present\n- [ ] Existing Discovery, Agents, and Denied tabs are unchanged\n- [ ] TopologyGraph bundle is lazy-loaded (not in initial page load)\n- [ ] All MeshPanel tests pass (existing + 3 new)\n- [ ] `npm run typecheck` passes",
      "activeForm": "Updating MeshPanel with Topology tab and stats header",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.4", "3.5"],
      "parallelWith": []
    },
    {
      "id": "3.7",
      "phase": 3,
      "phaseName": "Client UI",
      "subject": "[mesh-observability-lifecycle] [P3] Update feature barrel exports for new mesh UI components",
      "description": "Update the mesh feature barrel export at `apps/client/src/layers/features/mesh/index.ts` to export the new components.\n\n**Implementation Steps:**\n\n1. The mesh feature barrel at `apps/client/src/layers/features/mesh/index.ts` should export `MeshPanel` (which already exists) and any new components that need to be accessible from other features or widgets.\n\nSince `TopologyGraph`, `AgentNode`, `MeshStatsHeader`, and `AgentHealthDetail` are internal to the mesh feature (used only within `MeshPanel`), they do NOT need barrel exports. Only `MeshPanel` needs to be exported as the public API.\n\n2. Verify the existing barrel at `apps/client/src/layers/features/mesh/index.ts` exports `MeshPanel`. If it already does, no changes needed.\n\n3. Ensure no internal component paths are imported from outside the mesh feature — all usage should go through the `MeshPanel` barrel.\n\n**Acceptance Criteria:**\n- [ ] `MeshPanel` is exported from the mesh feature barrel\n- [ ] Internal components (`TopologyGraph`, `AgentNode`, `MeshStatsHeader`, `AgentHealthDetail`) are NOT exported from the barrel (they are internal to the feature)\n- [ ] No FSD layer violations exist (feature internals are encapsulated)\n- [ ] `npm run typecheck` passes",
      "activeForm": "Updating feature barrel exports for mesh UI components",
      "size": "small",
      "priority": "low",
      "dependencies": ["3.6"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Documentation",
      "subject": "[mesh-observability-lifecycle] [P4] Update CLAUDE.md with new mesh observability endpoints and MCP tools",
      "description": "Update `CLAUDE.md` to document the new mesh observability routes and MCP tools.\n\n**Implementation Steps:**\n\n1. In the `routes/mesh.ts` description in the routes list, append the new endpoints:\n\nUpdate the `routes/mesh.ts` line from:\n```\n- **`routes/mesh.ts`** - Mesh agent discovery and registry (POST /discover, POST/GET/PATCH/DELETE /agents, POST /deny, GET/DELETE /denied). Feature-flag guarded via `mesh-state.ts`. Factory: `createMeshRouter(meshCore)`\n```\n\nTo:\n```\n- **`routes/mesh.ts`** - Mesh agent discovery, registry, and observability (POST /discover, POST/GET/PATCH/DELETE /agents, POST /deny, GET/DELETE /denied, GET /status, GET /agents/:id/health, POST /agents/:id/heartbeat). Feature-flag guarded via `mesh-state.ts`. Factory: `createMeshRouter(meshCore)`\n```\n\n2. In the MCP tool server description, add `mesh_status` and `mesh_inspect` to the Mesh tools list:\n\nUpdate from:\n```\nMesh tools: `mesh_discover`, `mesh_register`, `mesh_deny`, `mesh_list`, `mesh_unregister`.\n```\n\nTo:\n```\nMesh tools: `mesh_discover`, `mesh_register`, `mesh_deny`, `mesh_list`, `mesh_unregister`, `mesh_status`, `mesh_inspect`.\n```\n\n3. In the entities/mesh section of the client FSD table, add the new hooks:\n\nUpdate from:\n```\n| `entities/mesh/`         | useMeshEnabled, useRegisteredAgents, useDiscoverAgents, useRegisterAgent, useDenyAgent, useUnregisterAgent, useUpdateAgent, useDeniedAgents | Mesh discovery domain hooks |\n```\n\nTo:\n```\n| `entities/mesh/`         | useMeshEnabled, useRegisteredAgents, useDiscoverAgents, useRegisterAgent, useDenyAgent, useUnregisterAgent, useUpdateAgent, useDeniedAgents, useMeshStatus, useMeshAgentHealth, useMeshHeartbeat | Mesh discovery & observability domain hooks |\n```\n\n4. In the features/mesh section, update the component list:\n\nUpdate from:\n```\n| `features/mesh/`         | MeshPanel, CandidateCard, AgentCard, RegisterAgentDialog          | Mesh discovery & registry UI|\n```\n\nTo:\n```\n| `features/mesh/`         | MeshPanel, CandidateCard, AgentCard, RegisterAgentDialog, TopologyGraph, AgentNode, MeshStatsHeader, AgentHealthDetail | Mesh discovery, registry & observability UI|\n```\n\n**Acceptance Criteria:**\n- [ ] CLAUDE.md routes/mesh.ts line includes GET /status, GET /agents/:id/health, POST /agents/:id/heartbeat\n- [ ] CLAUDE.md MCP tools list includes mesh_status and mesh_inspect\n- [ ] CLAUDE.md entities/mesh row includes useMeshStatus, useMeshAgentHealth, useMeshHeartbeat\n- [ ] CLAUDE.md features/mesh row includes TopologyGraph, AgentNode, MeshStatsHeader, AgentHealthDetail\n- [ ] No other CLAUDE.md content is modified",
      "activeForm": "Updating CLAUDE.md with mesh observability documentation",
      "size": "small",
      "priority": "medium",
      "dependencies": ["3.6"],
      "parallelWith": []
    }
  ]
}
