{
  "spec": "specs/mesh-registry-integrity/02-specification.md",
  "slug": "mesh-registry-integrity",
  "generatedAt": "2026-02-26T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Schema + Upsert (Foundation)",
      "subject": "[mesh-registry-integrity] [P1] Add scan_root, behavior_json, budget_json columns to agents table",
      "description": "Add three new columns to the Drizzle schema for the `agents` table and generate the corresponding SQL migration.\n\n## Files to modify\n\n### `packages/db/src/schema/mesh.ts`\n\nAdd three columns to the `agents` table definition and extend the `status` enum to include `'unreachable'`:\n\n```typescript\nexport const agents = sqliteTable('agents', {\n  // ... existing columns unchanged ...\n  status: text('status', {\n    enum: ['active', 'inactive', 'unreachable'],\n  }).notNull().default('active'),\n  // New columns:\n  scanRoot: text('scan_root').notNull().default(''),\n  behaviorJson: text('behavior_json').notNull().default('{\"responseMode\":\"always\"}'),\n  budgetJson: text('budget_json').notNull().default('{\"maxHopsPerMessage\":5,\"maxCallsPerHour\":100}'),\n});\n```\n\nThe `status` column is `TEXT` in SQLite, so adding `'unreachable'` to the Drizzle enum requires no ALTER statement — it is application-level validation only.\n\n### Migration file: `packages/db/drizzle/0003_*.sql`\n\nGenerate the migration using `drizzle-kit generate`. The migration SQL should be:\n\n```sql\nALTER TABLE agents ADD COLUMN scan_root TEXT NOT NULL DEFAULT '';\nALTER TABLE agents ADD COLUMN behavior_json TEXT NOT NULL DEFAULT '{\"responseMode\":\"always\"}';\nALTER TABLE agents ADD COLUMN budget_json TEXT NOT NULL DEFAULT '{\"maxHopsPerMessage\":5,\"maxCallsPerHour\":100}';\n```\n\nNo data migration is needed — the defaults cover all existing rows.\n\n## Acceptance criteria\n\n- The three new columns exist in the Drizzle schema with correct types and defaults\n- The `status` enum includes `'unreachable'`\n- Migration file is generated and applies cleanly to an existing database\n- Existing rows get default values for all three new columns\n- Run existing migration tests to verify no regressions\n- Add a test in `packages/db/src/__tests__/migrations.test.ts` (or equivalent) that verifies:\n  - `scan_root` column exists with empty string default\n  - `behavior_json` column exists with `{\"responseMode\":\"always\"}` default\n  - `budget_json` column exists with `{\"maxHopsPerMessage\":5,\"maxCallsPerHour\":100}` default\n  - Existing rows receive the default values after migration",
      "activeForm": "Adding schema columns and generating migration",
      "size": "small",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Schema + Upsert (Foundation)",
      "subject": "[mesh-registry-integrity] [P1] Replace insert() with idempotent upsert() in AgentRegistry",
      "description": "Replace the bare `insert()` method in `AgentRegistry` with an idempotent `upsert()` method that uses `ON CONFLICT(id) DO UPDATE`. This eliminates crash bugs caused by UNIQUE constraint violations on `id` and `project_path`.\n\n## File to modify\n\n### `packages/mesh/src/agent-registry.ts`\n\nAdd the `and` and `lt` imports from `drizzle-orm` (needed for later orphan methods too):\n\n```typescript\nimport { eq, desc, and, lt } from 'drizzle-orm';\n```\n\nReplace the existing `insert()` method with `upsert()`:\n\n```typescript\n/**\n * Insert or update an agent in the registry.\n * Uses ON CONFLICT(id) DO UPDATE for idempotent registration.\n * Handles path conflicts by removing the stale entry first.\n */\nupsert(agent: AgentRegistryEntry): void {\n  const now = new Date().toISOString();\n\n  // Check for path conflict: different agent ID at same path\n  const existingAtPath = this.getByPath(agent.projectPath);\n  if (existingAtPath && existingAtPath.id !== agent.id) {\n    this.remove(existingAtPath.id);\n  }\n\n  this.db.insert(agents).values({\n    id: agent.id,\n    name: agent.name,\n    description: agent.description ?? '',\n    projectPath: agent.projectPath,\n    runtime: agent.runtime,\n    capabilities: JSON.stringify(agent.capabilities),\n    namespace: agent.namespace ?? 'default',\n    scanRoot: agent.scanRoot ?? '',\n    behaviorJson: JSON.stringify(agent.behavior),\n    budgetJson: JSON.stringify(agent.budget),\n    approver: agent.registeredBy,\n    registeredAt: agent.registeredAt,\n    updatedAt: now,\n  }).onConflictDoUpdate({\n    target: agents.id,\n    set: {\n      name: agent.name,\n      description: agent.description ?? '',\n      projectPath: agent.projectPath,\n      runtime: agent.runtime,\n      capabilities: JSON.stringify(agent.capabilities),\n      namespace: agent.namespace ?? 'default',\n      scanRoot: agent.scanRoot ?? '',\n      behaviorJson: JSON.stringify(agent.behavior),\n      budgetJson: JSON.stringify(agent.budget),\n      updatedAt: now,\n      status: 'active', // Re-registration clears unreachable\n    },\n  }).run();\n}\n```\n\nUpdate all existing callers of `insert()` in `mesh-core.ts` to use `upsert()` instead. Search for `.insert(` calls on the registry object.\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/agent-registry.test.ts`:\n\n```typescript\ndescribe('upsert()', () => {\n  it('inserts new agent when no conflict exists', () => {\n    registry.upsert(makeEntry({ id: 'agent-1', projectPath: '/path/a' }));\n    expect(registry.get('agent-1')).toBeDefined();\n  });\n\n  it('updates existing agent when same ID re-registered', () => {\n    registry.upsert(makeEntry({ id: 'agent-1', name: 'V1' }));\n    registry.upsert(makeEntry({ id: 'agent-1', name: 'V2' }));\n    expect(registry.get('agent-1')?.name).toBe('V2');\n    expect(registry.list()).toHaveLength(1);\n  });\n\n  it('replaces stale entry when different ID registered at same path', () => {\n    registry.upsert(makeEntry({ id: 'old-id', projectPath: '/same/path' }));\n    registry.upsert(makeEntry({ id: 'new-id', projectPath: '/same/path' }));\n    expect(registry.get('old-id')).toBeUndefined();\n    expect(registry.get('new-id')).toBeDefined();\n  });\n\n  it('clears unreachable status on re-registration', () => {\n    registry.upsert(makeEntry({ id: 'agent-1' }));\n    registry.markUnreachable('agent-1');\n    registry.upsert(makeEntry({ id: 'agent-1' }));\n    // Agent should be active again (status cleared by ON CONFLICT SET)\n  });\n\n  it('persists behavior_json and budget_json from entry', () => {\n    const behavior = { responseMode: 'on-mention' as const };\n    const budget = { maxHopsPerMessage: 3, maxCallsPerHour: 50 };\n    registry.upsert(makeEntry({ id: 'agent-1', behavior, budget }));\n    const entry = registry.get('agent-1');\n    expect(entry?.behavior).toEqual(behavior);\n    expect(entry?.budget).toEqual(budget);\n  });\n\n  it('persists scan_root from entry', () => {\n    registry.upsert(makeEntry({ id: 'agent-1', scanRoot: '/projects' }));\n    expect(registry.get('agent-1')?.scanRoot).toBe('/projects');\n  });\n});\n```\n\n## Acceptance criteria\n\n- `insert()` method is removed and replaced with `upsert()`\n- All callers in `mesh-core.ts` updated to call `upsert()`\n- No UNIQUE constraint crash on re-registration at same ID\n- No UNIQUE constraint crash on re-registration at same path with different ID\n- All six test cases pass\n- Existing agent-registry tests still pass",
      "activeForm": "Replacing insert with idempotent upsert",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Schema + Upsert (Foundation)",
      "subject": "[mesh-registry-integrity] [P1] Update rowToEntry() and update() to use new DB columns",
      "description": "Update `rowToEntry()` to read `behavior_json`, `budget_json`, and `scan_root` from DB columns instead of using hardcoded defaults. Update `update()` to persist all mutable fields including the new columns.\n\n## File to modify\n\n### `packages/mesh/src/agent-registry.ts`\n\nReplace the existing `rowToEntry()` method:\n\n```typescript\nprivate rowToEntry(row: typeof agents.$inferSelect): AgentRegistryEntry {\n  return {\n    id: row.id,\n    name: row.name,\n    description: row.description ?? '',\n    runtime: row.runtime as AgentRuntime,\n    capabilities: JSON.parse(row.capabilities) as string[],\n    behavior: JSON.parse(row.behaviorJson),\n    budget: JSON.parse(row.budgetJson),\n    namespace: row.namespace,\n    registeredAt: row.registeredAt,\n    registeredBy: row.approver ?? 'mesh',\n    projectPath: row.projectPath,\n    scanRoot: row.scanRoot,\n  };\n}\n```\n\nKey changes from existing code:\n- `behavior` now reads from `row.behaviorJson` via `JSON.parse()` instead of hardcoded `{ responseMode: 'always' }`\n- `budget` now reads from `row.budgetJson` via `JSON.parse()` instead of hardcoded `{ maxHopsPerMessage: 5, maxCallsPerHour: 100 }`\n- `scanRoot` now reads from `row.scanRoot` instead of hardcoded `''`\n\nReplace the existing `update()` method to include all mutable fields:\n\n```typescript\nupdate(id: string, partial: Partial<AgentRegistryEntry>): boolean {\n  const existing = this.get(id);\n  if (!existing) return false;\n\n  const merged = { ...existing, ...partial, id };\n  const now = new Date().toISOString();\n  const result = this.db.update(agents).set({\n    name: merged.name,\n    description: merged.description,\n    runtime: merged.runtime,\n    capabilities: JSON.stringify(merged.capabilities),\n    namespace: merged.namespace,\n    scanRoot: merged.scanRoot,\n    behaviorJson: JSON.stringify(merged.behavior),\n    budgetJson: JSON.stringify(merged.budget),\n    updatedAt: now,\n  }).where(eq(agents.id, id)).run();\n  return result.changes > 0;\n}\n```\n\nKey changes: Added `scanRoot`, `behaviorJson`, and `budgetJson` to the `.set()` call.\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/agent-registry.test.ts`:\n\n```typescript\ndescribe('rowToEntry()', () => {\n  it('parses behavior_json from DB column', () => {\n    const behavior = { responseMode: 'on-mention' as const };\n    registry.upsert(makeEntry({ id: 'a1', behavior }));\n    const entry = registry.get('a1');\n    expect(entry?.behavior).toEqual(behavior);\n  });\n\n  it('parses budget_json from DB column', () => {\n    const budget = { maxHopsPerMessage: 10, maxCallsPerHour: 200 };\n    registry.upsert(makeEntry({ id: 'a1', budget }));\n    const entry = registry.get('a1');\n    expect(entry?.budget).toEqual(budget);\n  });\n\n  it('reads scanRoot from DB column', () => {\n    registry.upsert(makeEntry({ id: 'a1', scanRoot: '/my/root' }));\n    expect(registry.get('a1')?.scanRoot).toBe('/my/root');\n  });\n});\n\ndescribe('update()', () => {\n  it('persists namespace and scanRoot changes', () => {\n    registry.upsert(makeEntry({ id: 'a1', namespace: 'old', scanRoot: '/old' }));\n    registry.update('a1', { namespace: 'new', scanRoot: '/new' });\n    const entry = registry.get('a1');\n    expect(entry?.namespace).toBe('new');\n    expect(entry?.scanRoot).toBe('/new');\n  });\n\n  it('persists behavior and budget changes', () => {\n    registry.upsert(makeEntry({ id: 'a1' }));\n    registry.update('a1', {\n      behavior: { responseMode: 'on-mention' },\n      budget: { maxHopsPerMessage: 1, maxCallsPerHour: 10 },\n    });\n    const entry = registry.get('a1');\n    expect(entry?.behavior.responseMode).toBe('on-mention');\n    expect(entry?.budget.maxCallsPerHour).toBe(10);\n  });\n});\n```\n\n## Acceptance criteria\n\n- `rowToEntry()` reads all three new fields from DB columns, no hardcoded defaults\n- `update()` persists `scanRoot`, `behaviorJson`, `budgetJson` to DB\n- Round-trip test: upsert with custom values, get back, verify values match\n- All existing tests pass",
      "activeForm": "Updating rowToEntry and update methods for new columns",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.2"]
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Schema + Upsert (Foundation)",
      "subject": "[mesh-registry-integrity] [P1] Add orphan management methods to AgentRegistry",
      "description": "Add `markUnreachable()`, `listUnreachable()`, and `listUnreachableBefore()` methods to `AgentRegistry` for managing agents whose project paths no longer exist on disk.\n\n## File to modify\n\n### `packages/mesh/src/agent-registry.ts`\n\nEnsure `and` and `lt` are imported from `drizzle-orm`:\n\n```typescript\nimport { eq, desc, and, lt } from 'drizzle-orm';\n```\n\nAdd three new methods to the `AgentRegistry` class:\n\n```typescript\n/** Mark an agent as unreachable (path no longer accessible). */\nmarkUnreachable(id: string): boolean {\n  const now = new Date().toISOString();\n  const result = this.db.update(agents).set({\n    status: 'unreachable',\n    updatedAt: now,\n  }).where(eq(agents.id, id)).run();\n  return result.changes > 0;\n}\n\n/** List all agents with unreachable status. */\nlistUnreachable(): AgentRegistryEntry[] {\n  const rows = this.db.select().from(agents)\n    .where(eq(agents.status, 'unreachable'))\n    .all();\n  return rows.map((row) => this.rowToEntry(row));\n}\n\n/** List unreachable agents whose updatedAt is before the given ISO cutoff. */\nlistUnreachableBefore(cutoffIso: string): AgentRegistryEntry[] {\n  const rows = this.db.select().from(agents)\n    .where(and(\n      eq(agents.status, 'unreachable'),\n      lt(agents.updatedAt, cutoffIso),\n    ))\n    .all();\n  return rows.map((row) => this.rowToEntry(row));\n}\n```\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/agent-registry.test.ts`:\n\n```typescript\ndescribe('markUnreachable()', () => {\n  it('sets status to unreachable and updates timestamp', () => {\n    registry.upsert(makeEntry({ id: 'a1' }));\n    const result = registry.markUnreachable('a1');\n    expect(result).toBe(true);\n    const unreachable = registry.listUnreachable();\n    expect(unreachable).toHaveLength(1);\n    expect(unreachable[0].id).toBe('a1');\n  });\n\n  it('returns false for non-existent agent', () => {\n    expect(registry.markUnreachable('nonexistent')).toBe(false);\n  });\n});\n\ndescribe('listUnreachableBefore()', () => {\n  it('returns only unreachable agents with updatedAt before cutoff', () => {\n    registry.upsert(makeEntry({ id: 'a1' }));\n    registry.upsert(makeEntry({ id: 'a2' }));\n    registry.markUnreachable('a1');\n    registry.markUnreachable('a2');\n    // a1 and a2 are both unreachable, set cutoff in the future\n    const future = new Date(Date.now() + 100000).toISOString();\n    const expired = registry.listUnreachableBefore(future);\n    expect(expired).toHaveLength(2);\n  });\n\n  it('excludes active agents and recently-unreachable agents', () => {\n    registry.upsert(makeEntry({ id: 'active-agent' }));\n    registry.upsert(makeEntry({ id: 'unreachable-agent' }));\n    registry.markUnreachable('unreachable-agent');\n    // Cutoff in the past — recently-unreachable agent should NOT be returned\n    const past = new Date(Date.now() - 100000).toISOString();\n    const expired = registry.listUnreachableBefore(past);\n    expect(expired).toHaveLength(0);\n  });\n});\n```\n\n## Acceptance criteria\n\n- `markUnreachable()` sets status to `'unreachable'` and updates `updatedAt`\n- `listUnreachable()` returns only agents with status `'unreachable'`\n- `listUnreachableBefore()` filters by both status and timestamp cutoff\n- All three methods handle edge cases (non-existent ID, empty results)\n- All tests pass",
      "activeForm": "Adding orphan management methods to AgentRegistry",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["1.2", "1.3"]
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Compensating Registration",
      "subject": "[mesh-registry-integrity] [P2] Implement file-first register() with compensating cleanup in MeshCore",
      "description": "Reorder the `register()` method in `MeshCore` to follow a file-first pattern: write manifest to disk first, then upsert into DB, then register with Relay. On failure at any step, compensating cleanup undoes the previous successful steps.\n\n## File to modify\n\n### `packages/mesh/src/mesh-core.ts`\n\nUpdate the `register()` method to follow this sequence:\n\n```typescript\nasync register(candidate, overrides?, approver?, scanRoot?): Promise<AgentManifest> {\n  const manifest = buildManifest(candidate, overrides, approver);\n  const namespace = resolveNamespace(candidate.path, scanRoot, manifest.namespace);\n  const entry = toRegistryEntry(manifest, candidate.path, namespace, scanRoot);\n\n  // Step 1: Write manifest to disk (atomic tmp+rename)\n  await writeManifest(candidate.path, manifest);\n\n  // Step 2: Upsert into DB (idempotent)\n  try {\n    this.registry.upsert(entry);\n  } catch (err) {\n    // Compensate: remove manifest file\n    await removeManifest(candidate.path);\n    throw err;\n  }\n\n  // Step 3: Register with Relay\n  try {\n    await this.relayBridge.registerAgent(manifest, candidate.path, namespace, scanRoot);\n  } catch (err) {\n    // Compensate: remove DB entry\n    this.registry.remove(manifest.id);\n    throw err;\n  }\n\n  this.emitLifecycleEvent('registered', manifest);\n  return manifest;\n}\n```\n\n### `packages/mesh/src/manifest.ts`\n\nAdd a `removeManifest()` helper function:\n\n```typescript\nimport { unlink } from 'node:fs/promises';\nimport { join } from 'node:path';\n\n/**\n * Remove the agent manifest file from a project directory.\n * Used for compensating cleanup when registration fails after file write.\n *\n * @param projectPath - Absolute path to the agent's project directory\n */\nexport async function removeManifest(projectPath: string): Promise<void> {\n  try {\n    await unlink(join(projectPath, '.dork', 'agent.json'));\n  } catch {\n    // Best-effort cleanup — ignore if file already gone\n  }\n}\n```\n\nExport `removeManifest` from the manifest module barrel if one exists.\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/mesh-core.test.ts`:\n\n```typescript\ndescribe('register() compensation', () => {\n  it('removes manifest file when DB upsert fails', async () => {\n    // Mock registry.upsert to throw\n    vi.spyOn(registry, 'upsert').mockImplementation(() => {\n      throw new Error('DB error');\n    });\n    // Mock writeManifest and removeManifest\n    const removeSpy = vi.spyOn(manifest, 'removeManifest').mockResolvedValue(undefined);\n\n    await expect(meshCore.register(candidate)).rejects.toThrow('DB error');\n    expect(removeSpy).toHaveBeenCalledWith(candidate.path);\n  });\n\n  it('removes DB entry when Relay registration fails', async () => {\n    vi.spyOn(relayBridge, 'registerAgent').mockRejectedValue(new Error('Relay error'));\n    const removeSpy = vi.spyOn(registry, 'remove');\n\n    await expect(meshCore.register(candidate)).rejects.toThrow('Relay error');\n    expect(removeSpy).toHaveBeenCalled();\n  });\n\n  it('succeeds on re-registration at same path', async () => {\n    // First registration\n    await meshCore.register(candidate);\n    // Second registration at same path should not crash\n    await expect(meshCore.register(candidate)).resolves.toBeDefined();\n  });\n});\n```\n\n## Acceptance criteria\n\n- Registration follows disk -> DB -> Relay order\n- DB failure triggers manifest file removal\n- Relay failure triggers DB entry removal\n- Re-registration at the same path succeeds without crashes\n- All compensation test cases pass\n- Existing registration tests still pass",
      "activeForm": "Implementing file-first registration with compensating cleanup",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Compensating Registration",
      "subject": "[mesh-registry-integrity] [P2] Update upsertAutoImported() to sync instead of skip",
      "description": "Replace the skip-if-exists logic in `upsertAutoImported()` with sync-aware upsert. Currently, if `getByPath()` finds an existing entry, the method returns early without syncing any updated manifest data. The new implementation always upserts, handling both new and existing agents.\n\n## File to modify\n\n### `packages/mesh/src/mesh-core.ts`\n\nReplace the existing `upsertAutoImported()` method:\n\n```typescript\nprivate async upsertAutoImported(\n  manifest: AgentManifest,\n  projectPath: string,\n): Promise<void> {\n  const namespace = resolveNamespace(\n    projectPath,\n    this.defaultScanRoot,\n    manifest.namespace,\n  );\n  const entry: AgentRegistryEntry = {\n    ...manifest,\n    projectPath,\n    namespace,\n    scanRoot: this.defaultScanRoot,\n  };\n\n  // Upsert handles both new and existing agents\n  this.registry.upsert(entry);\n\n  // Ensure Relay endpoint exists\n  await this.relayBridge.registerAgent(\n    manifest, projectPath, namespace, this.defaultScanRoot,\n  );\n}\n```\n\nKey change: Remove the early-return `if (this.registry.getByPath(projectPath)) return;` guard. The `upsert()` call is idempotent and handles both insert and update cases.\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/mesh-core.test.ts`:\n\n```typescript\ndescribe('upsertAutoImported()', () => {\n  it('updates DB when manifest file has changed', async () => {\n    // First auto-import\n    await meshCore.upsertAutoImported(manifestV1, '/path/a');\n    // Second auto-import with updated name\n    const manifestV2 = { ...manifestV1, name: 'Updated Name' };\n    await meshCore.upsertAutoImported(manifestV2, '/path/a');\n    const entry = registry.get(manifestV1.id);\n    expect(entry?.name).toBe('Updated Name');\n  });\n\n  it('handles moved folder (same ID, different path)', async () => {\n    await meshCore.upsertAutoImported(manifest, '/old/path');\n    await meshCore.upsertAutoImported(manifest, '/new/path');\n    const entry = registry.get(manifest.id);\n    expect(entry?.projectPath).toBe('/new/path');\n  });\n});\n```\n\n## Acceptance criteria\n\n- `upsertAutoImported()` no longer skips when an entry exists at the same path\n- Manifest changes on disk are reflected in DB after auto-import\n- Moved folders (same agent ID at new path) are handled without crashes\n- Relay endpoint is ensured on every call\n- All tests pass",
      "activeForm": "Updating upsertAutoImported to sync instead of skip",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.2"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Reconciliation",
      "subject": "[mesh-registry-integrity] [P3] Create reconciler module with anti-entropy sweep",
      "description": "Create a new `reconciler.ts` module that implements full anti-entropy reconciliation between the filesystem and DB. The reconciler checks each DB entry's path on disk, syncs updated manifests, marks missing paths as unreachable, and auto-removes orphans past a 24-hour grace period.\n\n## New file\n\n### `packages/mesh/src/reconciler.ts`\n\n```typescript\nimport { access } from 'node:fs/promises';\nimport type { AgentRegistry, AgentRegistryEntry } from './agent-registry.js';\nimport type { RelayBridge } from './relay-bridge.js';\nimport { readManifest } from './manifest.js';\nimport { resolveNamespace } from './namespace-resolver.js';\nimport type { AgentManifest } from '@dorkos/shared/mesh-schemas';\n\nconst ORPHAN_GRACE_MS = 24 * 60 * 60 * 1000; // 24 hours\n\nexport interface ReconcileResult {\n  synced: number;       // DB entries updated from file\n  unreachable: number;  // Newly marked unreachable\n  removed: number;      // Auto-removed after grace period\n  discovered: number;   // New agents found on disk (reserved for future use)\n}\n\n/**\n * Full anti-entropy reconciliation between filesystem and DB.\n *\n * 1. Check each DB entry's path exists on disk\n * 2. For existing paths, sync file -> DB if data differs\n * 3. Mark missing paths as unreachable\n * 4. Auto-remove unreachable entries past grace period\n *\n * @param registry - The agent registry to reconcile\n * @param relayBridge - Relay bridge for unregistering orphaned agents\n * @param defaultScanRoot - Default scan root for namespace resolution\n * @returns Summary of reconciliation actions taken\n */\nexport async function reconcile(\n  registry: AgentRegistry,\n  relayBridge: RelayBridge,\n  defaultScanRoot: string,\n): Promise<ReconcileResult> {\n  const result: ReconcileResult = {\n    synced: 0, unreachable: 0, removed: 0, discovered: 0,\n  };\n  const entries = registry.list();\n\n  for (const entry of entries) {\n    const pathExists = await pathAccessible(entry.projectPath);\n\n    if (!pathExists) {\n      // Mark unreachable (idempotent)\n      if ((entry as any).status !== 'unreachable') {\n        registry.markUnreachable(entry.id);\n        result.unreachable++;\n      }\n      continue;\n    }\n\n    // Path exists — sync file -> DB\n    const manifest = await readManifest(entry.projectPath);\n    if (!manifest) continue; // Corrupt/missing manifest, skip\n\n    // Compare and sync if file data differs\n    if (manifestDiffersFromEntry(manifest, entry)) {\n      const namespace = resolveNamespace(\n        entry.projectPath, entry.scanRoot || defaultScanRoot, manifest.namespace,\n      );\n      registry.update(entry.id, {\n        name: manifest.name,\n        description: manifest.description,\n        runtime: manifest.runtime,\n        capabilities: manifest.capabilities,\n        behavior: manifest.behavior,\n        budget: manifest.budget,\n        namespace,\n      });\n      result.synced++;\n    }\n  }\n\n  // Auto-remove orphans past grace period\n  const cutoff = new Date(Date.now() - ORPHAN_GRACE_MS).toISOString();\n  const expired = registry.listUnreachableBefore(cutoff);\n  for (const entry of expired) {\n    await relayBridge.unregisterAgent(entry.id, entry.namespace);\n    registry.remove(entry.id);\n    result.removed++;\n  }\n\n  return result;\n}\n\n/** Check if a filesystem path is accessible. */\nasync function pathAccessible(p: string): Promise<boolean> {\n  try {\n    await access(p);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/** Compare manifest fields against registry entry. */\nfunction manifestDiffersFromEntry(\n  manifest: AgentManifest,\n  entry: AgentRegistryEntry,\n): boolean {\n  return (\n    manifest.name !== entry.name ||\n    manifest.description !== entry.description ||\n    manifest.runtime !== entry.runtime ||\n    JSON.stringify(manifest.capabilities) !== JSON.stringify(entry.capabilities) ||\n    JSON.stringify(manifest.behavior) !== JSON.stringify(entry.behavior) ||\n    JSON.stringify(manifest.budget) !== JSON.stringify(entry.budget)\n  );\n}\n```\n\nExport `reconcile` and `ReconcileResult` from the package barrel (`packages/mesh/src/index.ts`).\n\n## Tests\n\nCreate `packages/mesh/src/__tests__/reconciler.test.ts`:\n\n```typescript\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { reconcile } from '../reconciler.js';\nimport * as fsPromises from 'node:fs/promises';\nimport * as manifestModule from '../manifest.js';\n\nvi.mock('node:fs/promises');\nvi.mock('../manifest.js');\n\ndescribe('reconcile()', () => {\n  let registry: MockRegistry;\n  let relayBridge: MockRelayBridge;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    registry = createMockRegistry();\n    relayBridge = createMockRelayBridge();\n  });\n\n  it('marks agents with missing paths as unreachable', async () => {\n    registry.list.mockReturnValue([makeEntry({ id: 'a1', projectPath: '/gone' })]);\n    vi.mocked(fsPromises.access).mockRejectedValue(new Error('ENOENT'));\n\n    const result = await reconcile(registry, relayBridge, '/root');\n    expect(result.unreachable).toBe(1);\n    expect(registry.markUnreachable).toHaveBeenCalledWith('a1');\n  });\n\n  it('syncs updated manifest fields to DB', async () => {\n    registry.list.mockReturnValue([makeEntry({ id: 'a1', name: 'Old' })]);\n    vi.mocked(fsPromises.access).mockResolvedValue(undefined);\n    vi.mocked(manifestModule.readManifest).mockResolvedValue(\n      makeManifest({ id: 'a1', name: 'New' }),\n    );\n\n    const result = await reconcile(registry, relayBridge, '/root');\n    expect(result.synced).toBe(1);\n    expect(registry.update).toHaveBeenCalledWith('a1', expect.objectContaining({ name: 'New' }));\n  });\n\n  it('auto-removes unreachable agents past 24h grace period', async () => {\n    registry.list.mockReturnValue([]);\n    const oldEntry = makeEntry({ id: 'old' });\n    registry.listUnreachableBefore.mockReturnValue([oldEntry]);\n\n    const result = await reconcile(registry, relayBridge, '/root');\n    expect(result.removed).toBe(1);\n    expect(relayBridge.unregisterAgent).toHaveBeenCalledWith('old', oldEntry.namespace);\n    expect(registry.remove).toHaveBeenCalledWith('old');\n  });\n\n  it('skips agents with corrupt/unparseable manifests', async () => {\n    registry.list.mockReturnValue([makeEntry({ id: 'a1' })]);\n    vi.mocked(fsPromises.access).mockResolvedValue(undefined);\n    vi.mocked(manifestModule.readManifest).mockResolvedValue(null);\n\n    const result = await reconcile(registry, relayBridge, '/root');\n    expect(result.synced).toBe(0);\n    expect(result.unreachable).toBe(0);\n  });\n\n  it('handles empty registry gracefully', async () => {\n    registry.list.mockReturnValue([]);\n    registry.listUnreachableBefore.mockReturnValue([]);\n\n    const result = await reconcile(registry, relayBridge, '/root');\n    expect(result).toEqual({ synced: 0, unreachable: 0, removed: 0, discovered: 0 });\n  });\n});\n```\n\n## Acceptance criteria\n\n- `reconciler.ts` created with `reconcile()` function\n- Missing paths are marked unreachable\n- Updated manifests sync to DB\n- Orphans past 24h grace period are auto-removed (Relay unregistered + DB removed)\n- Corrupt manifests are skipped without error\n- Empty registry handled gracefully\n- All 5+ test cases pass\n- Exported from package barrel",
      "activeForm": "Creating reconciler module with anti-entropy sweep",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.2", "1.4"],
      "parallelWith": []
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Reconciliation",
      "subject": "[mesh-registry-integrity] [P3] Wire reconciliation into MeshCore and server startup",
      "description": "Add `reconcileOnStartup()` and periodic reconciliation timer methods to `MeshCore`, then wire them into the server startup and shutdown in `apps/server/src/index.ts`.\n\n## Files to modify\n\n### `packages/mesh/src/mesh-core.ts`\n\nAdd imports:\n\n```typescript\nimport { reconcile, type ReconcileResult } from './reconciler.js';\n```\n\nAdd three methods to the `MeshCore` class:\n\n```typescript\nprivate reconcileTimer: ReturnType<typeof setInterval> | null = null;\n\n/**\n * Run a one-time reconciliation sweep on startup.\n * Syncs DB state with filesystem and cleans up orphans.\n *\n * @returns Summary of reconciliation actions taken\n */\nasync reconcileOnStartup(): Promise<ReconcileResult> {\n  return reconcile(this.registry, this.relayBridge, this.defaultScanRoot);\n}\n\n/**\n * Start periodic reconciliation at the given interval.\n *\n * @param intervalMs - Milliseconds between reconciliation sweeps (default: 300000 = 5 min)\n */\nstartPeriodicReconciliation(intervalMs = 300_000): void {\n  if (this.reconcileTimer) return; // Already running\n  this.reconcileTimer = setInterval(async () => {\n    try {\n      await reconcile(this.registry, this.relayBridge, this.defaultScanRoot);\n    } catch (err) {\n      // Log but don't crash — periodic task should be resilient\n      console.error('[Mesh] Periodic reconciliation failed:', err);\n    }\n  }, intervalMs);\n  // Don't keep process alive just for reconciliation\n  this.reconcileTimer.unref();\n}\n\n/**\n * Stop periodic reconciliation.\n */\nstopPeriodicReconciliation(): void {\n  if (this.reconcileTimer) {\n    clearInterval(this.reconcileTimer);\n    this.reconcileTimer = null;\n  }\n}\n```\n\nNote: `this.reconcileTimer.unref()` ensures the interval timer doesn't prevent Node.js process exit.\n\n### `apps/server/src/index.ts`\n\nAfter the existing MeshCore initialization block, add:\n\n```typescript\nif (meshCore) {\n  // Startup reconciliation — sync DB with filesystem\n  try {\n    const result = await meshCore.reconcileOnStartup();\n    logger.info('[Mesh] Startup reconciliation complete', result);\n  } catch (err) {\n    logger.error('[Mesh] Startup reconciliation failed', {\n      error: err instanceof Error ? err.message : String(err),\n    });\n  }\n\n  // Periodic reconciliation (every 5 minutes)\n  meshCore.startPeriodicReconciliation(300_000);\n}\n```\n\nIn the existing SIGINT/SIGTERM shutdown handler, add before the process exit:\n\n```typescript\nmeshCore?.stopPeriodicReconciliation();\n```\n\n## Tests\n\nExtend `packages/mesh/src/__tests__/mesh-core.test.ts`:\n\n```typescript\ndescribe('reconciliation integration', () => {\n  it('reconcileOnStartup() calls reconcile and returns result', async () => {\n    const result = await meshCore.reconcileOnStartup();\n    expect(result).toHaveProperty('synced');\n    expect(result).toHaveProperty('unreachable');\n    expect(result).toHaveProperty('removed');\n  });\n\n  it('startPeriodicReconciliation() sets up interval', () => {\n    meshCore.startPeriodicReconciliation(60000);\n    // Verify timer is set (implementation detail, but important for cleanup)\n    meshCore.stopPeriodicReconciliation();\n  });\n\n  it('stopPeriodicReconciliation() clears interval', () => {\n    meshCore.startPeriodicReconciliation(60000);\n    meshCore.stopPeriodicReconciliation();\n    // Should be safe to call multiple times\n    meshCore.stopPeriodicReconciliation();\n  });\n});\n```\n\n## Acceptance criteria\n\n- `reconcileOnStartup()` runs reconciliation and returns `ReconcileResult`\n- `startPeriodicReconciliation()` creates an interval timer with `.unref()`\n- `stopPeriodicReconciliation()` clears the timer cleanly\n- Server startup calls reconciliation after MeshCore init\n- Server shutdown stops periodic reconciliation\n- Periodic reconciliation errors are caught and logged, not thrown\n- All tests pass",
      "activeForm": "Wiring reconciliation into MeshCore and server startup",
      "size": "medium",
      "priority": "high",
      "dependencies": ["3.1"],
      "parallelWith": ["3.3"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Reconciliation",
      "subject": "[mesh-registry-integrity] [P3] Add unreachableCount to MeshStatusResponse schema",
      "description": "Surface the count of unreachable agents in the `MeshStatusResponseSchema` so the client can display it.\n\n## File to modify\n\n### `packages/shared/src/mesh-schemas.ts`\n\nAdd `unreachableCount` to the `MeshStatusResponseSchema`:\n\n```typescript\nunreachableCount: z.number().int().nonneg(),\n```\n\nThis field should be populated by the server when computing mesh status. The server handler (in `apps/server/src/routes/mesh.ts` or the MeshCore status method) should call `registry.listUnreachable().length` to populate this field.\n\n### Server-side: update the mesh status endpoint handler\n\nIn the mesh status computation (wherever `MeshStatusResponseSchema` is populated), add:\n\n```typescript\nunreachableCount: registry.listUnreachable().length,\n```\n\n## Tests\n\n- Verify the schema accepts `unreachableCount: 0` and `unreachableCount: 5`\n- Verify the status endpoint returns `unreachableCount` in its response\n\n## Acceptance criteria\n\n- `MeshStatusResponseSchema` includes `unreachableCount` field\n- Mesh status endpoint returns the unreachable count\n- Existing status response tests still pass\n- Client type is automatically updated via Zod inference",
      "activeForm": "Adding unreachableCount to MeshStatusResponse schema",
      "size": "small",
      "priority": "medium",
      "dependencies": ["1.4"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Reconciliation",
      "subject": "[mesh-registry-integrity] [P3] Update architecture documentation with reconciliation lifecycle",
      "description": "Update `contributing/architecture.md` to document the Mesh reconciliation lifecycle in the existing Mesh section.\n\n## File to modify\n\n### `contributing/architecture.md`\n\nIn the Mesh section, add a subsection documenting:\n\n1. **Registration flow**: File-first with compensating cleanup (disk -> DB -> Relay, with rollback on failure)\n2. **Reconciliation**: Startup sweep + periodic (5-minute) anti-entropy reconciliation that syncs filesystem state to DB\n3. **Orphan handling**: 24-hour grace period for unreachable agents before auto-removal\n4. **Source of truth**: `.dork/agent.json` on disk is canonical; `agents` table is a derived index\n\nKeep the documentation concise (a few paragraphs + the data flow diagram from the spec).\n\n## Acceptance criteria\n\n- Architecture doc updated with reconciliation lifecycle\n- Registration flow documented with compensation steps\n- Orphan grace period documented\n- No new documentation files created",
      "activeForm": "Updating architecture documentation with reconciliation lifecycle",
      "size": "small",
      "priority": "low",
      "dependencies": ["3.1", "3.2"],
      "parallelWith": []
    }
  ]
}
