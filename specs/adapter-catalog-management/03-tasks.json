{
  "spec": "specs/adapter-catalog-management/02-specification.md",
  "slug": "adapter-catalog-management",
  "generatedAt": "2026-02-27T12:00:00.000Z",
  "mode": "full",
  "lastDecomposeDate": null,
  "tasks": [
    {
      "id": "1.1",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-catalog-management] [P1] Add ConfigField, AdapterManifest, and CatalogEntry Zod schemas to shared package",
      "description": "Add the foundational Zod schemas and TypeScript types for the adapter catalog system to `packages/shared/src/relay-schemas.ts`. These schemas define the shape of config field descriptors, adapter manifests, and catalog entries that flow between server and client.\n\n## Implementation Steps\n\n1. Open `packages/shared/src/relay-schemas.ts` and add the following schemas after the existing adapter schemas.\n\n2. Add `ConfigFieldTypeSchema`:\n```typescript\nexport const ConfigFieldTypeSchema = z.enum([\n  'text',\n  'password',\n  'number',\n  'boolean',\n  'select',\n  'textarea',\n  'url',\n]);\n```\n\n3. Add `ConfigFieldOptionSchema`:\n```typescript\nexport const ConfigFieldOptionSchema = z.object({\n  label: z.string(),\n  value: z.string(),\n});\n```\n\n4. Add `ConfigFieldSchema`:\n```typescript\nexport const ConfigFieldSchema = z.object({\n  key: z.string(),\n  label: z.string(),\n  type: ConfigFieldTypeSchema,\n  required: z.boolean(),\n  default: z.union([z.string(), z.number(), z.boolean()]).optional(),\n  placeholder: z.string().optional(),\n  description: z.string().optional(),\n  options: z.array(ConfigFieldOptionSchema).optional(),\n  section: z.string().optional(),\n  showWhen: z.object({\n    field: z.string(),\n    equals: z.union([z.string(), z.boolean(), z.number()]),\n  }).optional(),\n});\n```\n\n5. Add `AdapterSetupStepSchema`:\n```typescript\nexport const AdapterSetupStepSchema = z.object({\n  stepId: z.string(),\n  title: z.string(),\n  description: z.string().optional(),\n  fields: z.array(z.string()),\n});\n```\n\n6. Add `AdapterCategorySchema`:\n```typescript\nexport const AdapterCategorySchema = z.enum([\n  'messaging',\n  'automation',\n  'internal',\n  'custom',\n]);\n```\n\n7. Add `AdapterManifestSchema`:\n```typescript\nexport const AdapterManifestSchema = z.object({\n  type: z.string(),\n  displayName: z.string(),\n  description: z.string(),\n  iconEmoji: z.string().optional(),\n  category: AdapterCategorySchema,\n  docsUrl: z.string().url().optional(),\n  builtin: z.boolean(),\n  configFields: z.array(ConfigFieldSchema),\n  setupSteps: z.array(AdapterSetupStepSchema).optional(),\n  setupInstructions: z.string().optional(),\n  multiInstance: z.boolean().default(false),\n});\n```\n\n8. Add `CatalogInstanceSchema` and `CatalogEntrySchema`:\n```typescript\nexport const CatalogInstanceSchema = z.object({\n  id: z.string(),\n  enabled: z.boolean(),\n  status: AdapterStatusSchema,\n});\n\nexport const CatalogEntrySchema = z.object({\n  manifest: AdapterManifestSchema,\n  instances: z.array(CatalogInstanceSchema),\n});\n```\n\n9. Export all inferred types:\n```typescript\nexport type ConfigField = z.infer<typeof ConfigFieldSchema>;\nexport type ConfigFieldType = z.infer<typeof ConfigFieldTypeSchema>;\nexport type AdapterManifest = z.infer<typeof AdapterManifestSchema>;\nexport type AdapterCategory = z.infer<typeof AdapterCategorySchema>;\nexport type AdapterSetupStep = z.infer<typeof AdapterSetupStepSchema>;\nexport type CatalogInstance = z.infer<typeof CatalogInstanceSchema>;\nexport type CatalogEntry = z.infer<typeof CatalogEntrySchema>;\n```\n\n10. Ensure `AdapterStatusSchema` already exists in the file (it should from the relay-external-adapters spec). If the `AdapterStatusSchema` uses the shape `{ state, messageCount, errorCount, ... }`, verify `CatalogInstanceSchema` references it correctly.\n\n11. Run `pnpm typecheck` to ensure no type errors.\n\n## Acceptance Criteria\n- [ ] All seven schemas (`ConfigFieldTypeSchema`, `ConfigFieldOptionSchema`, `ConfigFieldSchema`, `AdapterSetupStepSchema`, `AdapterCategorySchema`, `AdapterManifestSchema`, `CatalogEntrySchema`) are exported from `packages/shared/src/relay-schemas.ts`\n- [ ] All inferred types are exported alongside the schemas\n- [ ] `pnpm typecheck` passes with no errors\n- [ ] A test file `packages/shared/src/__tests__/relay-catalog-schemas.test.ts` validates that example manifests (Telegram, Webhook, ClaudeCode) parse successfully against `AdapterManifestSchema`\n- [ ] A test validates that invalid manifests (missing required fields, wrong types) are rejected by `AdapterManifestSchema.safeParse()`\n- [ ] A test validates `ConfigFieldSchema` with and without optional fields (`showWhen`, `options`, `section`, `default`)",
      "activeForm": "Adding ConfigField and AdapterManifest Zod schemas to shared package",
      "size": "medium",
      "priority": "high",
      "dependencies": [],
      "parallelWith": []
    },
    {
      "id": "1.2",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-catalog-management] [P1] Export built-in adapter manifests from relay package",
      "description": "Add static `AdapterManifest` constant exports to each built-in adapter file in `packages/relay/src/adapters/` and re-export them from the package barrel.\n\n## Implementation Steps\n\n1. **TelegramAdapter manifest** ‚Äî Add to `packages/relay/src/adapters/telegram-adapter.ts`:\n```typescript\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nexport const TELEGRAM_MANIFEST: AdapterManifest = {\n  type: 'telegram',\n  displayName: 'Telegram',\n  description: 'Send and receive messages via a Telegram bot.',\n  iconEmoji: '‚úàÔ∏è',\n  category: 'messaging',\n  docsUrl: 'https://core.telegram.org/bots',\n  builtin: true,\n  multiInstance: false,\n  configFields: [\n    {\n      key: 'token',\n      label: 'Bot Token',\n      type: 'password',\n      required: true,\n      placeholder: '123456789:ABCDefGHijklMNOpqrSTUvwxYZ',\n      description: 'Token from @BotFather on Telegram.',\n    },\n    {\n      key: 'mode',\n      label: 'Receiving Mode',\n      type: 'select',\n      required: true,\n      default: 'polling',\n      options: [\n        { label: 'Long Polling', value: 'polling' },\n        { label: 'Webhook', value: 'webhook' },\n      ],\n      description: 'Polling requires no public URL. Webhook is recommended for production.',\n    },\n    {\n      key: 'webhookUrl',\n      label: 'Webhook URL',\n      type: 'url',\n      required: true,\n      placeholder: 'https://your-domain.com/relay/webhooks/telegram',\n      description: 'Public HTTPS URL where Telegram sends updates.',\n      showWhen: { field: 'mode', equals: 'webhook' },\n    },\n    {\n      key: 'webhookPort',\n      label: 'Webhook Port',\n      type: 'number',\n      required: false,\n      default: 8443,\n      description: 'Port for the webhook HTTP server.',\n      showWhen: { field: 'mode', equals: 'webhook' },\n    },\n  ],\n  setupInstructions: 'Open Telegram and search for **@BotFather**. Send `/newbot`, choose a name and username. Copy the token provided.',\n};\n```\n\n2. **WebhookAdapter manifest** ‚Äî Add to `packages/relay/src/adapters/webhook-adapter.ts`:\n```typescript\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nexport const WEBHOOK_MANIFEST: AdapterManifest = {\n  type: 'webhook',\n  displayName: 'Webhook',\n  description: 'Send and receive messages via HMAC-signed HTTP webhooks.',\n  iconEmoji: 'üîó',\n  category: 'automation',\n  builtin: true,\n  multiInstance: true,\n  configFields: [\n    {\n      key: 'inbound.subject',\n      label: 'Inbound Subject',\n      type: 'text',\n      required: true,\n      placeholder: 'relay.webhook.my-service',\n      description: 'Relay subject to publish inbound messages to.',\n      section: 'Inbound',\n    },\n    {\n      key: 'inbound.secret',\n      label: 'Inbound Secret',\n      type: 'password',\n      required: true,\n      description: 'HMAC-SHA256 secret for verifying inbound webhooks (min 16 characters).',\n      section: 'Inbound',\n    },\n    {\n      key: 'outbound.url',\n      label: 'Outbound URL',\n      type: 'url',\n      required: true,\n      placeholder: 'https://api.example.com/webhook',\n      description: 'URL to POST outbound messages to.',\n      section: 'Outbound',\n    },\n    {\n      key: 'outbound.secret',\n      label: 'Outbound Secret',\n      type: 'password',\n      required: true,\n      description: 'HMAC-SHA256 secret for signing outbound requests (min 16 characters).',\n      section: 'Outbound',\n    },\n    {\n      key: 'outbound.headers',\n      label: 'Custom Headers',\n      type: 'textarea',\n      required: false,\n      placeholder: '{\"Authorization\": \"Bearer xxx\"}',\n      description: 'JSON object of custom HTTP headers for outbound requests.',\n      section: 'Outbound',\n    },\n  ],\n};\n```\n\n3. **ClaudeCodeAdapter manifest** ‚Äî Add to `packages/relay/src/adapters/claude-code-adapter.ts`:\n```typescript\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nexport const CLAUDE_CODE_MANIFEST: AdapterManifest = {\n  type: 'claude-code',\n  displayName: 'Claude Code',\n  description: 'Routes messages to Claude Agent SDK sessions. Auto-configured.',\n  iconEmoji: 'ü§ñ',\n  category: 'internal',\n  builtin: true,\n  multiInstance: false,\n  configFields: [\n    {\n      key: 'maxConcurrent',\n      label: 'Max Concurrent Sessions',\n      type: 'number',\n      required: false,\n      default: 3,\n      description: 'Maximum number of concurrent agent sessions.',\n    },\n    {\n      key: 'defaultTimeoutMs',\n      label: 'Default Timeout (ms)',\n      type: 'number',\n      required: false,\n      default: 300000,\n      description: 'Default timeout for agent sessions in milliseconds.',\n    },\n  ],\n};\n```\n\n4. **Re-export from barrel** ‚Äî Add to `packages/relay/src/index.ts`:\n```typescript\nexport { TELEGRAM_MANIFEST } from './adapters/telegram-adapter.js';\nexport { WEBHOOK_MANIFEST } from './adapters/webhook-adapter.js';\nexport { CLAUDE_CODE_MANIFEST } from './adapters/claude-code-adapter.js';\n```\n\n5. Run `pnpm typecheck` to confirm no type errors.\n\n## Acceptance Criteria\n- [ ] `TELEGRAM_MANIFEST`, `WEBHOOK_MANIFEST`, and `CLAUDE_CODE_MANIFEST` are exported from `@dorkos/relay`\n- [ ] Each manifest validates against `AdapterManifestSchema.safeParse()` without errors\n- [ ] A test file `packages/relay/src/__tests__/manifests.test.ts` validates all three manifests parse correctly\n- [ ] Each manifest's `configFields` keys match the keys used in the corresponding `TelegramAdapterConfig`, `WebhookAdapterConfig`, and `ClaudeCodeAdapterConfig` TypeScript interfaces\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Exporting built-in adapter manifests from relay package",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": []
    },
    {
      "id": "1.3",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-catalog-management] [P1] Add getCatalog and sensitive field masking to AdapterManager",
      "description": "Extend the existing `AdapterManager` class in `apps/server/src/services/relay/adapter-manager.ts` to support catalog queries with sensitive field masking.\n\n## Implementation Steps\n\n1. Add new imports to `adapter-manager.ts`:\n```typescript\nimport type { AdapterManifest, CatalogEntry } from '@dorkos/shared/relay-schemas';\nimport {\n  TELEGRAM_MANIFEST,\n  WEBHOOK_MANIFEST,\n  CLAUDE_CODE_MANIFEST,\n} from '@dorkos/relay';\n```\n\n2. Add a `manifests` map field to the `AdapterManager` class:\n```typescript\nprivate manifests = new Map<string, AdapterManifest>();\n```\n\n3. Add `populateBuiltinManifests()` private method:\n```typescript\nprivate populateBuiltinManifests(): void {\n  this.manifests.set('telegram', TELEGRAM_MANIFEST);\n  this.manifests.set('webhook', WEBHOOK_MANIFEST);\n  this.manifests.set('claude-code', CLAUDE_CODE_MANIFEST);\n}\n```\n\n4. Call `this.populateBuiltinManifests()` at the beginning of `initialize()`.\n\n5. Add `maskSensitiveFields()` private method that handles dot-notation keys:\n```typescript\nprivate maskSensitiveFields(\n  config: Record<string, unknown>,\n  manifest?: AdapterManifest,\n): Record<string, unknown> {\n  if (!manifest) return config;\n  const masked = structuredClone(config) as Record<string, unknown>;\n  for (const field of manifest.configFields) {\n    if (field.type !== 'password') continue;\n    const parts = field.key.split('.');\n    let current: Record<string, unknown> = masked;\n    let found = true;\n    for (let i = 0; i < parts.length - 1; i++) {\n      if (current[parts[i]] && typeof current[parts[i]] === 'object') {\n        current = current[parts[i]] as Record<string, unknown>;\n      } else {\n        found = false;\n        break;\n      }\n    }\n    const lastKey = parts.at(-1)!;\n    if (found && lastKey in current) {\n      current[lastKey] = '***';\n    }\n  }\n  return masked;\n}\n```\n\n6. Add `getCatalog()` public method:\n```typescript\ngetCatalog(): CatalogEntry[] {\n  const entries: CatalogEntry[] = [];\n  for (const [type, manifest] of this.manifests) {\n    const instances = this.configs\n      .filter((c) => c.type === type)\n      .map((c) => {\n        const adapter = this.registry.get(c.id);\n        const status = adapter?.getStatus() ?? {\n          state: 'disconnected' as const,\n          messageCount: { inbound: 0, outbound: 0 },\n          errorCount: 0,\n        };\n        return {\n          id: c.id,\n          enabled: c.enabled,\n          status,\n        };\n      });\n    entries.push({ manifest, instances });\n  }\n  return entries;\n}\n```\n\n7. Update the existing `listAdapters()` method to also mask sensitive fields using the manifest lookup:\n```typescript\nlistAdapters(): Array<{ config: AdapterConfig; status: AdapterStatus }> {\n  return this.configs.map((config) => {\n    const adapter = this.registry.get(config.id);\n    const status: AdapterStatus = adapter?.getStatus() ?? {\n      state: 'disconnected',\n      messageCount: { inbound: 0, outbound: 0 },\n      errorCount: 0,\n    };\n    const manifest = this.manifests.get(config.type);\n    const maskedConfig = {\n      ...config,\n      config: this.maskSensitiveFields(\n        config.config as Record<string, unknown>,\n        manifest,\n      ),\n    };\n    return { config: maskedConfig, status };\n  });\n}\n```\n\n8. Add a `getManifest(type: string)` accessor for use by CRUD methods in Phase 2:\n```typescript\ngetManifest(type: string): AdapterManifest | undefined {\n  return this.manifests.get(type);\n}\n```\n\n9. Add a `registerPluginManifest(type: string, manifest: AdapterManifest)` method for Phase 2 plugin discovery:\n```typescript\nregisterPluginManifest(type: string, manifest: AdapterManifest): void {\n  this.manifests.set(type, manifest);\n}\n```\n\n## Tests (`apps/server/src/services/relay/__tests__/adapter-manager.test.ts`)\n\nAdd tests to the existing test file (or create if it does not exist):\n\n- `getCatalog()` returns all three built-in manifests (telegram, webhook, claude-code) with their configured instances\n- `getCatalog()` returns empty `instances` array for adapter types with no configured instances\n- `getCatalog()` returns correct `enabled` and `status` for configured instances\n- `maskSensitiveFields()` replaces top-level password fields (e.g., `token`) with `'***'`\n- `maskSensitiveFields()` replaces nested dot-notation password fields (e.g., `inbound.secret` in webhook config) with `'***'`\n- `maskSensitiveFields()` preserves non-password fields unchanged\n- `maskSensitiveFields()` handles missing nested paths gracefully (no throw)\n- `listAdapters()` returns masked config values for password fields\n\n## Acceptance Criteria\n- [ ] `getCatalog()` returns `CatalogEntry[]` with all built-in manifests\n- [ ] Password fields in adapter configs are masked with `'***'` in both `getCatalog()` and `listAdapters()`\n- [ ] Dot-notation keys (e.g., `inbound.secret`, `outbound.secret`) are correctly traversed and masked\n- [ ] All tests pass via `pnpm vitest run apps/server/src/services/relay/__tests__/adapter-manager.test.ts`\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding getCatalog and sensitive field masking to AdapterManager",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": []
    },
    {
      "id": "1.4",
      "phase": 1,
      "phaseName": "Foundation",
      "subject": "[adapter-catalog-management] [P1] Add GET /adapters/catalog route and Transport interface methods",
      "description": "Add the catalog endpoint to the Relay routes, and add `getAdapterCatalog()` to the Transport interface with HttpTransport and DirectTransport implementations.\n\n## Implementation Steps\n\n### Server Route\n\n1. Open `apps/server/src/routes/relay.ts` and add the catalog GET route. **Important:** This route must be defined BEFORE any `GET /adapters/:id` route to prevent 'catalog' from being matched as an adapter ID parameter.\n\n```typescript\n// GET /api/relay/adapters/catalog\nrouter.get('/adapters/catalog', (_req, res) => {\n  try {\n    const catalog = adapterManager.getCatalog();\n    res.json(catalog);\n  } catch (err) {\n    res.status(500).json({ error: 'Failed to retrieve adapter catalog' });\n  }\n});\n```\n\n### Transport Interface\n\n2. Open `packages/shared/src/transport.ts` and add the following method to the `Transport` interface:\n```typescript\n/** Retrieve the adapter catalog with available types and configured instances. */\ngetAdapterCatalog(): Promise<CatalogEntry[]>;\n```\n\n3. Add the `CatalogEntry` import at the top of `transport.ts`:\n```typescript\nimport type { CatalogEntry } from './relay-schemas.js';\n```\n\n### HttpTransport\n\n4. Open `apps/client/src/layers/shared/lib/transports/http-transport.ts` and add the implementation:\n```typescript\nasync getAdapterCatalog(): Promise<CatalogEntry[]> {\n  return this.fetchJSON<CatalogEntry[]>('/api/relay/adapters/catalog');\n}\n```\n\n### DirectTransport\n\n5. Open `apps/obsidian-plugin/src/direct-transport.ts` (or wherever DirectTransport lives) and add a stub:\n```typescript\nasync getAdapterCatalog(): Promise<CatalogEntry[]> {\n  return [];\n}\n```\n\n## Route Tests (`apps/server/src/routes/__tests__/relay-adapters.test.ts`)\n\nCreate or extend the test file:\n- `GET /api/relay/adapters/catalog` returns 200 with an array of `CatalogEntry` objects\n- Response includes all three built-in manifests\n- Response includes configured instances with masked password fields\n- Response returns empty array when Relay is disabled (if the route is feature-flag guarded)\n\n## Acceptance Criteria\n- [ ] `GET /api/relay/adapters/catalog` returns 200 with `CatalogEntry[]`\n- [ ] Route is defined before any parameterized adapter routes to avoid conflicts\n- [ ] `Transport` interface includes `getAdapterCatalog()` method\n- [ ] `HttpTransport` implements the method with `fetchJSON`\n- [ ] `DirectTransport` returns an empty array (no mutation support in embedded mode)\n- [ ] Route test validates response shape\n- [ ] `pnpm typecheck` passes across all packages",
      "activeForm": "Adding catalog route and Transport interface methods",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": []
    },
    {
      "id": "2.1",
      "phase": 2,
      "phaseName": "Server CRUD & Connection Test",
      "subject": "[adapter-catalog-management] [P2] Add addAdapter, removeAdapter, updateConfig methods to AdapterManager",
      "description": "Extend `AdapterManager` in `apps/server/src/services/relay/adapter-manager.ts` with CRUD methods for adapter instances.\n\n## Implementation Steps\n\n1. **addAdapter method:**\n```typescript\nasync addAdapter(\n  type: string,\n  id: string,\n  config: Record<string, unknown>,\n  enabled = true,\n): Promise<void> {\n  // Check for duplicate ID\n  if (this.configs.some((c) => c.id === id)) {\n    throw new AdapterError(`Adapter with ID '${id}' already exists`, 'DUPLICATE_ID');\n  }\n\n  // Check that the type is known (has a manifest)\n  const manifest = this.manifests.get(type);\n  if (!manifest) {\n    throw new AdapterError(`Unknown adapter type: ${type}`, 'UNKNOWN_TYPE');\n  }\n\n  // Check multiInstance constraint\n  if (!manifest.multiInstance) {\n    const existing = this.configs.find((c) => c.type === type);\n    if (existing) {\n      throw new AdapterError(\n        `Adapter type '${type}' does not support multiple instances. Existing: '${existing.id}'`,\n        'MULTI_INSTANCE_DENIED',\n      );\n    }\n  }\n\n  // Build the AdapterConfig entry\n  const adapterConfig: AdapterConfig = {\n    id,\n    type: type as AdapterConfig['type'],\n    enabled,\n    builtin: manifest.builtin,\n    config,\n  };\n\n  this.configs.push(adapterConfig);\n  await this.saveConfig();\n\n  // Start the adapter if enabled\n  if (enabled) {\n    const adapter = await this.createAdapter(adapterConfig);\n    if (adapter) {\n      await this.registry.register(adapter);\n    }\n  }\n}\n```\n\n2. **removeAdapter method:**\n```typescript\nasync removeAdapter(id: string): Promise<void> {\n  const index = this.configs.findIndex((c) => c.id === id);\n  if (index === -1) {\n    throw new AdapterError(`Adapter '${id}' not found`, 'NOT_FOUND');\n  }\n\n  const config = this.configs[index];\n\n  // Prevent removing the sole built-in claude-code adapter\n  if (config.type === 'claude-code' && config.builtin) {\n    throw new AdapterError(\n      'Cannot remove the built-in claude-code adapter',\n      'REMOVE_BUILTIN_DENIED',\n    );\n  }\n\n  // Stop the adapter if running\n  try {\n    await this.registry.unregister(id);\n  } catch {\n    // Adapter might not be running ‚Äî that's fine\n  }\n\n  // Remove from config and persist\n  this.configs.splice(index, 1);\n  await this.saveConfig();\n}\n```\n\n3. **updateConfig method** ‚Äî Preserves password fields when submitted as empty strings:\n```typescript\nasync updateConfig(id: string, newConfig: Record<string, unknown>): Promise<void> {\n  const existing = this.configs.find((c) => c.id === id);\n  if (!existing) {\n    throw new AdapterError(`Adapter '${id}' not found`, 'NOT_FOUND');\n  }\n\n  const manifest = this.manifests.get(existing.type);\n  const mergedConfig = this.mergeWithPasswordPreservation(\n    existing.config as Record<string, unknown>,\n    newConfig,\n    manifest,\n  );\n\n  existing.config = mergedConfig;\n  await this.saveConfig();\n\n  // Restart adapter if it was running\n  if (existing.enabled && this.registry.get(id)) {\n    try {\n      await this.registry.unregister(id);\n    } catch {\n      // Ignore unregister errors\n    }\n    const adapter = await this.createAdapter(existing);\n    if (adapter) {\n      await this.registry.register(adapter);\n    }\n  }\n}\n```\n\n4. **mergeWithPasswordPreservation helper:**\n```typescript\nprivate mergeWithPasswordPreservation(\n  existing: Record<string, unknown>,\n  incoming: Record<string, unknown>,\n  manifest?: AdapterManifest,\n): Record<string, unknown> {\n  const result = { ...existing, ...incoming };\n  if (!manifest) return result;\n\n  for (const field of manifest.configFields) {\n    if (field.type !== 'password') continue;\n    const parts = field.key.split('.');\n    // Check if incoming value is empty/masked\n    const incomingValue = this.getNestedValue(incoming, parts);\n    if (incomingValue === '' || incomingValue === '***' || incomingValue === undefined) {\n      // Preserve existing value\n      const existingValue = this.getNestedValue(existing, parts);\n      if (existingValue !== undefined) {\n        this.setNestedValue(result, parts, existingValue);\n      }\n    }\n  }\n  return result;\n}\n\nprivate getNestedValue(obj: Record<string, unknown>, parts: string[]): unknown {\n  let current: unknown = obj;\n  for (const part of parts) {\n    if (current && typeof current === 'object' && part in (current as Record<string, unknown>)) {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return undefined;\n    }\n  }\n  return current;\n}\n\nprivate setNestedValue(obj: Record<string, unknown>, parts: string[], value: unknown): void {\n  let current: Record<string, unknown> = obj;\n  for (let i = 0; i < parts.length - 1; i++) {\n    current[parts[i]] ??= {};\n    current = current[parts[i]] as Record<string, unknown>;\n  }\n  current[parts.at(-1)!] = value;\n}\n```\n\n5. **AdapterError class** ‚Äî Add at the top of the file or in a separate `adapter-errors.ts`:\n```typescript\nexport class AdapterError extends Error {\n  constructor(\n    message: string,\n    public readonly code: 'DUPLICATE_ID' | 'NOT_FOUND' | 'UNKNOWN_TYPE' | 'MULTI_INSTANCE_DENIED' | 'REMOVE_BUILTIN_DENIED',\n  ) {\n    super(message);\n    this.name = 'AdapterError';\n  }\n}\n```\n\n## Tests\n\nAdd to `apps/server/src/services/relay/__tests__/adapter-manager.test.ts`:\n\n- `addAdapter()` adds a new adapter to configs and persists to disk\n- `addAdapter()` starts the adapter if enabled\n- `addAdapter()` rejects duplicate IDs with code `DUPLICATE_ID`\n- `addAdapter()` rejects unknown adapter types with code `UNKNOWN_TYPE`\n- `addAdapter()` rejects second instance of non-multiInstance type\n- `addAdapter()` allows second instance of multiInstance type (webhook)\n- `removeAdapter()` stops the adapter, removes from config, and persists\n- `removeAdapter()` returns NOT_FOUND for unknown IDs\n- `removeAdapter()` rejects removing built-in claude-code\n- `updateConfig()` merges new config and persists\n- `updateConfig()` preserves password fields when empty string is submitted\n- `updateConfig()` preserves nested password fields (e.g., `inbound.secret`)\n- `updateConfig()` restarts adapter after config change\n- `updateConfig()` returns NOT_FOUND for unknown IDs\n\n## Acceptance Criteria\n- [ ] `addAdapter()` creates adapter, persists config, and starts if enabled\n- [ ] `removeAdapter()` stops adapter, removes from config, persists; rejects built-in claude-code\n- [ ] `updateConfig()` merges config with password preservation; restarts adapter\n- [ ] All error cases throw `AdapterError` with appropriate code\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding CRUD methods to AdapterManager",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.2"]
    },
    {
      "id": "2.2",
      "phase": 2,
      "phaseName": "Server CRUD & Connection Test",
      "subject": "[adapter-catalog-management] [P2] Add testConnection method to AdapterManager",
      "description": "Add a `testConnection` method to `AdapterManager` that creates a transient adapter instance, attempts to start it, and returns success/failure without registering it in the adapter registry.\n\n## Implementation Steps\n\n1. Add `testConnection()` to `AdapterManager` in `apps/server/src/services/relay/adapter-manager.ts`:\n\n```typescript\n/** Timeout for connection test attempts (ms). */\nconst CONNECTION_TEST_TIMEOUT_MS = 15_000;\n\nasync testConnection(\n  type: string,\n  config: Record<string, unknown>,\n): Promise<{ ok: boolean; error?: string }> {\n  const manifest = this.manifests.get(type);\n  if (!manifest) {\n    return { ok: false, error: `Unknown adapter type: ${type}` };\n  }\n\n  // Create a temporary config entry for adapter instantiation\n  const tempConfig: AdapterConfig = {\n    id: `__test_${type}_${Date.now()}`,\n    type: type as AdapterConfig['type'],\n    enabled: true,\n    builtin: manifest.builtin,\n    config,\n  };\n\n  let adapter: RelayAdapter | null = null;\n  try {\n    adapter = await this.createAdapter(tempConfig);\n    if (!adapter) {\n      return { ok: false, error: 'Failed to create adapter instance' };\n    }\n\n    // Create a relay stub that does nothing (test adapter is not registered)\n    const noopRelay: RelayPublisher = {\n      publish: async () => ({ messageId: '', deliveredTo: 0 }),\n      onSignal: () => () => {},\n    };\n\n    // Race start() against the timeout\n    await Promise.race([\n      adapter.start(noopRelay),\n      new Promise<never>((_, reject) =>\n        setTimeout(() => reject(new Error('Connection test timed out')), CONNECTION_TEST_TIMEOUT_MS),\n      ),\n    ]);\n\n    return { ok: true };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    return { ok: false, error: message };\n  } finally {\n    // Always clean up the transient adapter\n    if (adapter) {\n      try {\n        await adapter.stop();\n      } catch {\n        // Swallow stop errors during cleanup\n      }\n    }\n  }\n}\n```\n\n2. Import `RelayPublisher` type if not already imported:\n```typescript\nimport type { RelayPublisher } from '@dorkos/relay';\n```\n\n## Tests\n\nAdd to `apps/server/src/services/relay/__tests__/adapter-manager.test.ts`:\n\n- `testConnection()` returns `{ ok: true }` when adapter starts successfully\n- `testConnection()` returns `{ ok: false, error: '...' }` when adapter start fails\n- `testConnection()` returns `{ ok: false, error: 'Unknown adapter type: ...' }` for unknown types\n- `testConnection()` always calls `stop()` on the adapter, even on failure\n- `testConnection()` does NOT register the adapter in the registry (verify `registry.get(tempId)` returns undefined)\n- `testConnection()` times out after 15 seconds if start() hangs\n\n## Acceptance Criteria\n- [ ] `testConnection()` creates a transient adapter, calls `start()`, returns `{ ok: true }` or `{ ok: false, error }`\n- [ ] Transient adapter is always cleaned up via `stop()` in a `finally` block\n- [ ] Adapter is never registered in the registry\n- [ ] 15-second timeout prevents hanging\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding testConnection method to AdapterManager",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.3"],
      "parallelWith": ["2.1"]
    },
    {
      "id": "2.3",
      "phase": 2,
      "phaseName": "Server CRUD & Connection Test",
      "subject": "[adapter-catalog-management] [P2] Add CRUD and test routes to relay router",
      "description": "Add POST, DELETE, PATCH, and test routes to `apps/server/src/routes/relay.ts` for adapter management, and add corresponding Transport interface methods.\n\n## Implementation Steps\n\n### Server Routes\n\n1. Import `AdapterError` at the top of `apps/server/src/routes/relay.ts`:\n```typescript\nimport { AdapterError } from '../services/relay/adapter-manager.js';\n```\n\n2. Add `POST /api/relay/adapters` route:\n```typescript\nrouter.post('/adapters', async (req, res) => {\n  const { type, id, config, enabled } = req.body as {\n    type: string;\n    id: string;\n    config: Record<string, unknown>;\n    enabled?: boolean;\n  };\n\n  if (!type || !id || !config) {\n    return res.status(400).json({ error: 'Missing required fields: type, id, config' });\n  }\n\n  try {\n    await adapterManager.addAdapter(type, id, config, enabled);\n    res.status(201).json({ ok: true, id });\n  } catch (err) {\n    if (err instanceof AdapterError) {\n      const statusMap: Record<string, number> = {\n        DUPLICATE_ID: 409,\n        UNKNOWN_TYPE: 400,\n        MULTI_INSTANCE_DENIED: 400,\n        NOT_FOUND: 404,\n        REMOVE_BUILTIN_DENIED: 400,\n      };\n      return res.status(statusMap[err.code] ?? 400).json({ error: err.message, code: err.code });\n    }\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n3. Add `DELETE /api/relay/adapters/:id` route:\n```typescript\nrouter.delete('/adapters/:id', async (req, res) => {\n  try {\n    await adapterManager.removeAdapter(req.params.id);\n    res.json({ ok: true });\n  } catch (err) {\n    if (err instanceof AdapterError) {\n      const status = err.code === 'NOT_FOUND' ? 404 : 400;\n      return res.status(status).json({ error: err.message, code: err.code });\n    }\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n4. Add `PATCH /api/relay/adapters/:id/config` route:\n```typescript\nrouter.patch('/adapters/:id/config', async (req, res) => {\n  const { config } = req.body as { config: Record<string, unknown> };\n  if (!config) {\n    return res.status(400).json({ error: 'Missing required field: config' });\n  }\n\n  try {\n    await adapterManager.updateConfig(req.params.id, config);\n    res.json({ ok: true });\n  } catch (err) {\n    if (err instanceof AdapterError) {\n      const status = err.code === 'NOT_FOUND' ? 404 : 400;\n      return res.status(status).json({ error: err.message, code: err.code });\n    }\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n5. Add `POST /api/relay/adapters/test` route (must be defined BEFORE `POST /adapters` to avoid conflict, or use a clearly distinct path):\n```typescript\nrouter.post('/adapters/test', async (req, res) => {\n  const { type, config } = req.body as { type: string; config: Record<string, unknown> };\n  if (!type || !config) {\n    return res.status(400).json({ error: 'Missing required fields: type, config' });\n  }\n\n  try {\n    const result = await adapterManager.testConnection(type, config);\n    res.json(result);\n  } catch (err) {\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\n### Transport Interface\n\n6. Add methods to `Transport` interface in `packages/shared/src/transport.ts`:\n```typescript\n/** Add a new relay adapter instance. */\naddRelayAdapter(type: string, id: string, config: Record<string, unknown>): Promise<{ ok: boolean }>;\n/** Remove a relay adapter instance by ID. */\nremoveRelayAdapter(id: string): Promise<{ ok: boolean }>;\n/** Update an existing relay adapter's configuration. */\nupdateRelayAdapterConfig(id: string, config: Record<string, unknown>): Promise<{ ok: boolean }>;\n/** Test a relay adapter connection without persisting. */\ntestRelayAdapterConnection(type: string, config: Record<string, unknown>): Promise<{ ok: boolean; error?: string }>;\n```\n\n### HttpTransport\n\n7. Add implementations to `http-transport.ts`:\n```typescript\nasync addRelayAdapter(type: string, id: string, config: Record<string, unknown>): Promise<{ ok: boolean }> {\n  return this.fetchJSON('/api/relay/adapters', {\n    method: 'POST',\n    body: JSON.stringify({ type, id, config }),\n  });\n}\n\nasync removeRelayAdapter(id: string): Promise<{ ok: boolean }> {\n  return this.fetchJSON(`/api/relay/adapters/${encodeURIComponent(id)}`, {\n    method: 'DELETE',\n  });\n}\n\nasync updateRelayAdapterConfig(id: string, config: Record<string, unknown>): Promise<{ ok: boolean }> {\n  return this.fetchJSON(`/api/relay/adapters/${encodeURIComponent(id)}/config`, {\n    method: 'PATCH',\n    body: JSON.stringify({ config }),\n  });\n}\n\nasync testRelayAdapterConnection(type: string, config: Record<string, unknown>): Promise<{ ok: boolean; error?: string }> {\n  return this.fetchJSON('/api/relay/adapters/test', {\n    method: 'POST',\n    body: JSON.stringify({ type, config }),\n  });\n}\n```\n\n### DirectTransport\n\n8. Add stubs to DirectTransport:\n```typescript\nasync addRelayAdapter(): Promise<{ ok: boolean }> {\n  throw new Error('Adapter management not supported in embedded mode');\n}\nasync removeRelayAdapter(): Promise<{ ok: boolean }> {\n  throw new Error('Adapter management not supported in embedded mode');\n}\nasync updateRelayAdapterConfig(): Promise<{ ok: boolean }> {\n  throw new Error('Adapter management not supported in embedded mode');\n}\nasync testRelayAdapterConnection(): Promise<{ ok: boolean; error?: string }> {\n  throw new Error('Adapter management not supported in embedded mode');\n}\n```\n\n## Route Tests\n\nAdd to or create `apps/server/src/routes/__tests__/relay-adapters.test.ts`:\n\n- `POST /adapters` returns 201 on success with `{ ok: true, id }`\n- `POST /adapters` returns 400 when body is missing required fields\n- `POST /adapters` returns 409 when adapter ID already exists\n- `DELETE /adapters/:id` returns 200 on success\n- `DELETE /adapters/:id` returns 404 when adapter not found\n- `DELETE /adapters/:id` returns 400 when attempting to remove built-in claude-code\n- `PATCH /adapters/:id/config` returns 200 on success\n- `PATCH /adapters/:id/config` returns 404 when adapter not found\n- `PATCH /adapters/:id/config` returns 400 when config is missing\n- `POST /adapters/test` returns 200 with `{ ok: true }` on successful connection\n- `POST /adapters/test` returns 200 with `{ ok: false, error }` on failed connection\n\n## Acceptance Criteria\n- [ ] All four routes work correctly with proper status codes and error handling\n- [ ] `AdapterError` codes map to correct HTTP status codes (409, 404, 400)\n- [ ] Transport interface, HttpTransport, and DirectTransport all updated\n- [ ] All route tests pass\n- [ ] `pnpm typecheck` passes across all packages",
      "activeForm": "Adding CRUD and test routes to relay router",
      "size": "large",
      "priority": "high",
      "dependencies": ["2.1", "2.2"],
      "parallelWith": ["2.4"]
    },
    {
      "id": "2.4",
      "phase": 2,
      "phaseName": "Server CRUD & Connection Test",
      "subject": "[adapter-catalog-management] [P2] Update plugin loader to extract manifests from plugin modules",
      "description": "Extend the adapter plugin loader in `packages/relay/src/adapter-plugin-loader.ts` to extract `AdapterManifest` from plugin modules when available, and return manifest alongside adapter instances.\n\n## Implementation Steps\n\n1. Update `AdapterPluginModule` interface in `packages/relay/src/adapter-plugin-loader.ts`:\n```typescript\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nexport interface AdapterPluginModule {\n  default: (config: Record<string, unknown>) => RelayAdapter;\n  getManifest?: () => AdapterManifest;\n}\n```\n\n2. Add `LoadedAdapter` return type:\n```typescript\nexport interface LoadedAdapter {\n  adapter: RelayAdapter;\n  manifest?: AdapterManifest;\n}\n```\n\n3. Update `loadAdapters` to return `LoadedAdapter[]` instead of `RelayAdapter[]`:\n```typescript\nexport async function loadAdapters(\n  configs: PluginAdapterConfig[],\n  builtinMap: Map<string, (config: Record<string, unknown>) => RelayAdapter>,\n  configDir: string,\n): Promise<LoadedAdapter[]> {\n  const results: LoadedAdapter[] = [];\n\n  for (const entry of configs) {\n    if (entry.enabled === false) continue;\n\n    try {\n      let adapter: RelayAdapter | null = null;\n      let manifest: AdapterManifest | undefined;\n\n      if (entry.builtin && builtinMap.has(entry.type)) {\n        const factory = builtinMap.get(entry.type)!;\n        adapter = factory(entry.config);\n        // Built-in manifests are handled by AdapterManager, not plugin loader\n      } else if (entry.plugin?.package) {\n        const mod = (await import(entry.plugin.package)) as AdapterPluginModule;\n        adapter = validateAndCreate(mod, entry);\n        manifest = extractManifest(mod, entry);\n      } else if (entry.plugin?.path) {\n        const absPath = isAbsolute(entry.plugin.path)\n          ? entry.plugin.path\n          : resolve(configDir, entry.plugin.path);\n        const mod = (await import(pathToFileURL(absPath).href)) as AdapterPluginModule;\n        adapter = validateAndCreate(mod, entry);\n        manifest = extractManifest(mod, entry);\n      }\n\n      if (adapter) {\n        results.push({ adapter, manifest });\n      }\n    } catch (err) {\n      console.warn(`[PluginLoader] Failed to load adapter '${entry.id}':`, err);\n    }\n  }\n\n  return results;\n}\n```\n\n4. Add `extractManifest` helper:\n```typescript\nimport { AdapterManifestSchema } from '@dorkos/shared/relay-schemas';\n\nfunction extractManifest(\n  mod: unknown,\n  entry: PluginAdapterConfig,\n): AdapterManifest | undefined {\n  const m = mod as Record<string, unknown>;\n  if (typeof m.getManifest === 'function') {\n    try {\n      const raw = (m.getManifest as () => unknown)();\n      const parsed = AdapterManifestSchema.safeParse(raw);\n      if (parsed.success) {\n        return parsed.data;\n      }\n      console.warn(\n        `[PluginLoader] Manifest from '${entry.id}' failed validation:`,\n        parsed.error.flatten(),\n      );\n    } catch (err) {\n      console.warn(`[PluginLoader] Failed to get manifest from '${entry.id}':`, err);\n    }\n  }\n\n  // Fallback: generate minimal manifest\n  return {\n    type: entry.type,\n    displayName: entry.id,\n    description: 'Custom adapter',\n    category: 'custom',\n    builtin: false,\n    configFields: [],\n    multiInstance: false,\n  };\n}\n```\n\n5. Update `packages/relay/src/index.ts` to export the new types:\n```typescript\nexport type { LoadedAdapter } from './adapter-plugin-loader.js';\n```\n\n6. Update `AdapterManager.loadPlugin()` in `apps/server/src/services/relay/adapter-manager.ts` to handle the new `LoadedAdapter` return type and register plugin manifests:\n```typescript\nprivate async loadPlugin(config: AdapterConfig): Promise<RelayAdapter | null> {\n  if (!config.plugin) {\n    logger.warn(`[AdapterManager] Plugin adapter '${config.id}' missing plugin source config`);\n    return null;\n  }\n\n  const builtinMap = new Map<string, (c: Record<string, unknown>) => RelayAdapter>();\n  const configDir = dirname(this.configPath);\n  const results = await loadAdapters(\n    [{\n      id: config.id,\n      type: config.type,\n      enabled: config.enabled,\n      plugin: config.plugin,\n      config: config.config as Record<string, unknown>,\n    }],\n    builtinMap,\n    configDir,\n  );\n\n  const result = results[0];\n  if (!result) return null;\n\n  // Register plugin manifest if discovered\n  if (result.manifest) {\n    this.registerPluginManifest(config.type, result.manifest);\n  }\n\n  return result.adapter;\n}\n```\n\n## Tests\n\nUpdate `packages/relay/src/__tests__/adapter-plugin-loader.test.ts`:\n\n- `loadAdapters()` returns `LoadedAdapter[]` with manifest when plugin exports `getManifest()`\n- `loadAdapters()` returns fallback minimal manifest when plugin does not export `getManifest()`\n- `loadAdapters()` validates manifest against schema and warns on invalid manifest\n- `loadAdapters()` still returns the adapter even if manifest extraction fails\n- Built-in adapters in the builtinMap return `{ adapter, manifest: undefined }` (manifests handled elsewhere)\n\n## Acceptance Criteria\n- [ ] `loadAdapters()` returns `LoadedAdapter[]` with optional manifest\n- [ ] Plugin modules with `getManifest()` have their manifest validated via `AdapterManifestSchema.safeParse()`\n- [ ] Plugins without `getManifest()` get a minimal fallback manifest\n- [ ] `AdapterManager.loadPlugin()` registers discovered manifests\n- [ ] All existing plugin loader tests still pass\n- [ ] New tests cover manifest extraction scenarios\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Updating plugin loader to extract manifests from plugin modules",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["1.1", "1.2"],
      "parallelWith": ["2.3"]
    },
    {
      "id": "3.1",
      "phase": 3,
      "phaseName": "Client Catalog UI",
      "subject": "[adapter-catalog-management] [P3] Add adapter catalog entity hooks",
      "description": "Add TanStack Query hooks for the adapter catalog CRUD operations to the client's relay entity layer at `apps/client/src/layers/entities/relay/`.\n\n## Implementation Steps\n\n1. Create or extend `apps/client/src/layers/entities/relay/model/use-adapter-catalog.ts`:\n\n```typescript\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useTransport } from '@/layers/shared/model';\nimport type { CatalogEntry } from '@dorkos/shared/relay-schemas';\n\nconst CATALOG_KEY = ['relay', 'adapters', 'catalog'] as const;\nconst ADAPTERS_KEY = ['relay', 'adapters'] as const;\n\n/**\n * Fetch the adapter catalog with available types and configured instances.\n *\n * @param enabled - Whether to enable the query (default: true)\n */\nexport function useAdapterCatalog(enabled = true) {\n  const transport = useTransport();\n  return useQuery<CatalogEntry[]>({\n    queryKey: [...CATALOG_KEY],\n    queryFn: () => transport.getAdapterCatalog(),\n    enabled,\n    refetchInterval: 30_000,\n  });\n}\n\n/**\n * Mutation to add a new adapter instance.\n *\n * Invalidates both catalog and adapter list queries on success.\n */\nexport function useAddAdapter() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ type, id, config }: { type: string; id: string; config: Record<string, unknown> }) =>\n      transport.addRelayAdapter(type, id, config),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [...CATALOG_KEY] });\n      queryClient.invalidateQueries({ queryKey: [...ADAPTERS_KEY] });\n    },\n  });\n}\n\n/**\n * Mutation to remove an adapter instance by ID.\n *\n * Invalidates both catalog and adapter list queries on success.\n */\nexport function useRemoveAdapter() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (id: string) => transport.removeRelayAdapter(id),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [...CATALOG_KEY] });\n      queryClient.invalidateQueries({ queryKey: [...ADAPTERS_KEY] });\n    },\n  });\n}\n\n/**\n * Mutation to update an existing adapter's configuration.\n *\n * Invalidates both catalog and adapter list queries on success.\n */\nexport function useUpdateAdapterConfig() {\n  const transport = useTransport();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({ id, config }: { id: string; config: Record<string, unknown> }) =>\n      transport.updateRelayAdapterConfig(id, config),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [...CATALOG_KEY] });\n      queryClient.invalidateQueries({ queryKey: [...ADAPTERS_KEY] });\n    },\n  });\n}\n\n/**\n * Mutation to test an adapter connection without persisting.\n *\n * Does not invalidate any queries since test is side-effect-free.\n */\nexport function useTestAdapterConnection() {\n  const transport = useTransport();\n  return useMutation({\n    mutationFn: ({ type, config }: { type: string; config: Record<string, unknown> }) =>\n      transport.testRelayAdapterConnection(type, config),\n  });\n}\n```\n\n2. Export the hooks from the relay entity barrel at `apps/client/src/layers/entities/relay/index.ts`:\n```typescript\nexport {\n  useAdapterCatalog,\n  useAddAdapter,\n  useRemoveAdapter,\n  useUpdateAdapterConfig,\n  useTestAdapterConnection,\n} from './model/use-adapter-catalog';\n```\n\n3. Add the `CatalogEntry` type re-export if not already available in the shared barrel.\n\n## Tests (`apps/client/src/layers/entities/relay/__tests__/use-adapter-catalog.test.ts`)\n\nUse `renderHook` with a wrapper that provides `TransportProvider` and `QueryClientProvider`:\n\n- `useAdapterCatalog()` calls `transport.getAdapterCatalog()` and returns data\n- `useAdapterCatalog(false)` does not fetch (enabled = false)\n- `useAddAdapter()` calls `transport.addRelayAdapter()` and invalidates catalog + adapters queries\n- `useRemoveAdapter()` calls `transport.removeRelayAdapter()` and invalidates queries\n- `useUpdateAdapterConfig()` calls `transport.updateRelayAdapterConfig()` and invalidates queries\n- `useTestAdapterConnection()` calls `transport.testRelayAdapterConnection()` and does NOT invalidate queries\n\n## Acceptance Criteria\n- [ ] All five hooks are exported from `@/layers/entities/relay`\n- [ ] Hooks use correct query keys for cache invalidation\n- [ ] Catalog query uses 30-second refetch interval\n- [ ] Test connection mutation does not invalidate any queries\n- [ ] All hook tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Adding adapter catalog entity hooks",
      "size": "medium",
      "priority": "high",
      "dependencies": ["1.4"],
      "parallelWith": ["3.2"]
    },
    {
      "id": "3.2",
      "phase": 3,
      "phaseName": "Client Catalog UI",
      "subject": "[adapter-catalog-management] [P3] Build ConfigFieldInput component",
      "description": "Create a generic form field renderer component that maps `ConfigField` descriptors to shadcn/ui input components, supporting all seven field types, conditional visibility, section grouping, and error display.\n\n## Implementation Steps\n\n1. Create `apps/client/src/layers/features/relay/ui/ConfigFieldInput.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Input } from '@/layers/shared/ui/input';\nimport { Switch } from '@/layers/shared/ui/switch';\nimport { Textarea } from '@/layers/shared/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/layers/shared/ui/select';\nimport { Label } from '@/layers/shared/ui/label';\nimport { Button } from '@/layers/shared/ui/button';\nimport { Eye, EyeOff } from 'lucide-react';\nimport { cn } from '@/layers/shared/lib';\nimport type { ConfigField } from '@dorkos/shared/relay-schemas';\n\ninterface ConfigFieldInputProps {\n  field: ConfigField;\n  value: unknown;\n  onChange: (key: string, value: unknown) => void;\n  error?: string;\n  /** Current form values ‚Äî used for showWhen conditional visibility */\n  allValues: Record<string, unknown>;\n}\n\nexport function ConfigFieldInput({\n  field,\n  value,\n  onChange,\n  error,\n  allValues,\n}: ConfigFieldInputProps) {\n  const [showPassword, setShowPassword] = useState(false);\n\n  // Conditional visibility check\n  if (field.showWhen) {\n    const dependentValue = allValues[field.showWhen.field];\n    if (dependentValue !== field.showWhen.equals) {\n      return null;\n    }\n  }\n\n  const fieldId = `config-field-${field.key}`;\n  const stringValue = value !== undefined && value !== null ? String(value) : '';\n\n  const renderInput = () => {\n    switch (field.type) {\n      case 'text':\n      case 'url':\n        return (\n          <Input\n            id={fieldId}\n            type={field.type === 'url' ? 'url' : 'text'}\n            value={stringValue}\n            onChange={(e) => onChange(field.key, e.target.value)}\n            placeholder={field.placeholder}\n          />\n        );\n\n      case 'password':\n        return (\n          <div className=\"relative\">\n            <Input\n              id={fieldId}\n              type={showPassword ? 'text' : 'password'}\n              value={stringValue}\n              onChange={(e) => onChange(field.key, e.target.value)}\n              placeholder={field.placeholder}\n            />\n            <Button\n              type=\"button\"\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"absolute right-0 top-0 h-full px-3\"\n              onClick={() => setShowPassword(!showPassword)}\n              aria-label={showPassword ? 'Hide password' : 'Show password'}\n            >\n              {showPassword ? (\n                <EyeOff className=\"size-4\" />\n              ) : (\n                <Eye className=\"size-4\" />\n              )}\n            </Button>\n          </div>\n        );\n\n      case 'number':\n        return (\n          <Input\n            id={fieldId}\n            type=\"number\"\n            value={stringValue}\n            onChange={(e) => onChange(field.key, e.target.value ? Number(e.target.value) : undefined)}\n            placeholder={field.placeholder}\n          />\n        );\n\n      case 'boolean':\n        return (\n          <Switch\n            id={fieldId}\n            checked={Boolean(value)}\n            onCheckedChange={(checked) => onChange(field.key, checked)}\n          />\n        );\n\n      case 'select':\n        return (\n          <Select\n            value={stringValue}\n            onValueChange={(v) => onChange(field.key, v)}\n          >\n            <SelectTrigger id={fieldId}>\n              <SelectValue placeholder={field.placeholder ?? 'Select...'} />\n            </SelectTrigger>\n            <SelectContent>\n              {field.options?.map((opt) => (\n                <SelectItem key={opt.value} value={opt.value}>\n                  {opt.label}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        );\n\n      case 'textarea':\n        return (\n          <Textarea\n            id={fieldId}\n            value={stringValue}\n            onChange={(e) => onChange(field.key, e.target.value)}\n            placeholder={field.placeholder}\n            rows={3}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"space-y-2\">\n      <Label\n        htmlFor={fieldId}\n        className={cn(field.required && 'after:ml-0.5 after:text-red-500 after:content-[\"*\"]')}\n      >\n        {field.label}\n      </Label>\n      {renderInput()}\n      {field.description && (\n        <p className=\"text-xs text-muted-foreground\">{field.description}</p>\n      )}\n      {error && (\n        <p className=\"text-xs text-red-500\">{error}</p>\n      )}\n    </div>\n  );\n}\n```\n\n2. Create a `ConfigFieldGroup` helper for section grouping:\n\n```typescript\nimport type { ConfigField } from '@dorkos/shared/relay-schemas';\n\ninterface ConfigFieldGroupProps {\n  fields: ConfigField[];\n  values: Record<string, unknown>;\n  onChange: (key: string, value: unknown) => void;\n  errors: Record<string, string>;\n}\n\nexport function ConfigFieldGroup({\n  fields,\n  values,\n  onChange,\n  errors,\n}: ConfigFieldGroupProps) {\n  // Group fields by section\n  const sections = new Map<string | undefined, ConfigField[]>();\n  for (const field of fields) {\n    const section = field.section;\n    if (!sections.has(section)) {\n      sections.set(section, []);\n    }\n    sections.get(section)!.push(field);\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {Array.from(sections.entries()).map(([section, sectionFields]) => (\n        <div key={section ?? '__default'} className=\"space-y-4\">\n          {section && (\n            <h4 className=\"text-sm font-medium text-muted-foreground\">{section}</h4>\n          )}\n          {sectionFields.map((field) => (\n            <ConfigFieldInput\n              key={field.key}\n              field={field}\n              value={values[field.key]}\n              onChange={onChange}\n              error={errors[field.key]}\n              allValues={values}\n            />\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n3. Export from the relay feature barrel `apps/client/src/layers/features/relay/index.ts`:\n```typescript\nexport { ConfigFieldInput, ConfigFieldGroup } from './ui/ConfigFieldInput';\n```\n\n## Tests (`apps/client/src/layers/features/relay/ui/__tests__/ConfigFieldInput.test.tsx`)\n\n```typescript\n/**\n * @vitest-environment jsdom\n */\nimport { describe, it, expect, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport { ConfigFieldInput } from '../ConfigFieldInput';\n```\n\nTest cases:\n- Renders `<Input type=\"text\">` for `type: 'text'` fields\n- Renders `<Input type=\"url\">` for `type: 'url'` fields\n- Renders `<Input type=\"password\">` for `type: 'password'` fields\n- Password eye toggle switches between password and text type\n- Renders `<Input type=\"number\">` for `type: 'number'` fields\n- Renders `<Switch>` for `type: 'boolean'` fields\n- Renders `<Select>` with options for `type: 'select'` fields\n- Renders `<Textarea>` for `type: 'textarea'` fields\n- Shows description text below the input\n- Shows error message in red text when `error` prop is provided\n- Shows required asterisk when `field.required` is true\n- Returns null (renders nothing) when `showWhen` condition is not met\n- Renders normally when `showWhen` condition is met\n- Calls `onChange` with correct key and value when user types\n\n## Acceptance Criteria\n- [ ] All seven field types render the correct shadcn/ui component\n- [ ] Password fields have a working eye toggle button\n- [ ] `showWhen` conditional visibility works correctly\n- [ ] Description and error messages display correctly\n- [ ] Required asterisk displays on required fields\n- [ ] `ConfigFieldGroup` groups fields by section with headings\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Building ConfigFieldInput component",
      "size": "large",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["3.1"]
    },
    {
      "id": "3.3",
      "phase": 3,
      "phaseName": "Client Catalog UI",
      "subject": "[adapter-catalog-management] [P3] Build CatalogCard component",
      "description": "Create a card component for displaying an available (unconfigured) adapter type in the catalog, with an \"Add\" button to trigger the setup wizard.\n\n## Implementation Steps\n\n1. Create `apps/client/src/layers/features/relay/ui/CatalogCard.tsx`:\n\n```typescript\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { Button } from '@/layers/shared/ui/button';\nimport { Plus } from 'lucide-react';\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nconst CATEGORY_COLORS: Record<string, string> = {\n  messaging: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',\n  automation: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200',\n  internal: 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200',\n  custom: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',\n};\n\ninterface CatalogCardProps {\n  manifest: AdapterManifest;\n  onAdd: () => void;\n}\n\n/**\n * Displays an available adapter type in the catalog.\n *\n * Shows icon, name, category badge, description, and an Add button.\n */\nexport function CatalogCard({ manifest, onAdd }: CatalogCardProps) {\n  return (\n    <div className=\"flex flex-col justify-between rounded-lg border p-4 transition-colors hover:bg-muted/50\">\n      <div className=\"space-y-2\">\n        <div className=\"flex items-center gap-2\">\n          {manifest.iconEmoji && (\n            <span className=\"text-lg\" role=\"img\" aria-hidden>\n              {manifest.iconEmoji}\n            </span>\n          )}\n          <span className=\"text-sm font-medium\">{manifest.displayName}</span>\n          <Badge\n            variant=\"secondary\"\n            className={CATEGORY_COLORS[manifest.category] ?? ''}\n          >\n            {manifest.category}\n          </Badge>\n        </div>\n        <p className=\"text-xs text-muted-foreground\">{manifest.description}</p>\n      </div>\n      <div className=\"mt-3\">\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"w-full\"\n          onClick={onAdd}\n        >\n          <Plus className=\"mr-1 size-3\" />\n          Add\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\n2. Export from the relay feature barrel:\n```typescript\nexport { CatalogCard } from './ui/CatalogCard';\n```\n\n## Tests (`apps/client/src/layers/features/relay/ui/__tests__/CatalogCard.test.tsx`)\n\n- Renders adapter display name, description, and category badge\n- Renders icon emoji when provided\n- Does not render icon emoji when not provided\n- Calls `onAdd` when the Add button is clicked\n- Shows correct category color for each category type\n\n## Acceptance Criteria\n- [ ] Card displays icon emoji, display name, category badge, and description\n- [ ] Add button calls `onAdd` callback\n- [ ] Category badge has appropriate color per category\n- [ ] Component follows FSD layer rules (only imports from shared/entities)\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Building CatalogCard component",
      "size": "small",
      "priority": "high",
      "dependencies": ["1.1"],
      "parallelWith": ["3.1", "3.2"]
    },
    {
      "id": "3.4",
      "phase": 3,
      "phaseName": "Client Catalog UI",
      "subject": "[adapter-catalog-management] [P3] Build AdapterSetupWizard component",
      "description": "Create a Dialog-based wizard component for adding and editing adapter instances, with dynamic form rendering, multi-step navigation, connection testing, and config submission.\n\n## Implementation Steps\n\n1. Create `apps/client/src/layers/features/relay/ui/AdapterSetupWizard.tsx`:\n\nThe wizard has three states:\n- **configure** ‚Äî Dynamic form from `manifest.configFields`\n- **test** ‚Äî Connection test with spinner and result display\n- **confirm** ‚Äî Summary of entered values with save button\n\n```typescript\nimport { useState, useMemo, useCallback } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n  DialogFooter,\n} from '@/layers/shared/ui/dialog';\nimport { Button } from '@/layers/shared/ui/button';\nimport { Input } from '@/layers/shared/ui/input';\nimport { Label } from '@/layers/shared/ui/label';\nimport { Loader2, CheckCircle2, XCircle, AlertTriangle } from 'lucide-react';\nimport { ConfigFieldGroup } from './ConfigFieldInput';\nimport { useAddAdapter, useUpdateAdapterConfig, useTestAdapterConnection } from '@/layers/entities/relay';\nimport type { AdapterManifest, CatalogInstance } from '@dorkos/shared/relay-schemas';\n\ntype WizardStep = 'configure' | 'test' | 'confirm';\n\ninterface AdapterSetupWizardProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  manifest: AdapterManifest;\n  /** Existing instance for edit mode; undefined for add mode */\n  existingInstance?: CatalogInstance & { config?: Record<string, unknown> };\n}\n\nexport function AdapterSetupWizard({\n  open,\n  onOpenChange,\n  manifest,\n  existingInstance,\n}: AdapterSetupWizardProps) {\n  const isEditMode = Boolean(existingInstance);\n\n  // Form state\n  const [values, setValues] = useState<Record<string, unknown>>(() =>\n    initializeValues(manifest, existingInstance?.config),\n  );\n  const [adapterId, setAdapterId] = useState(\n    existingInstance?.id ?? generateDefaultId(manifest),\n  );\n  const [step, setStep] = useState<WizardStep>('configure');\n  const [setupStepIndex, setSetupStepIndex] = useState(0);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n\n  // Mutations\n  const addAdapter = useAddAdapter();\n  const updateConfig = useUpdateAdapterConfig();\n  const testConnection = useTestAdapterConnection();\n\n  const handleFieldChange = useCallback((key: string, value: unknown) => {\n    setValues((prev) => ({ ...prev, [key]: value }));\n    setErrors((prev) => {\n      const next = { ...prev };\n      delete next[key];\n      return next;\n    });\n  }, []);\n\n  // Validate required fields\n  const validate = useCallback((): boolean => {\n    const newErrors: Record<string, string> = {};\n    for (const field of manifest.configFields) {\n      if (!field.required) continue;\n      // Skip fields hidden by showWhen\n      if (field.showWhen) {\n        if (values[field.showWhen.field] !== field.showWhen.equals) continue;\n      }\n      const val = values[field.key];\n      if (val === undefined || val === null || val === '') {\n        newErrors[field.key] = `${field.label} is required`;\n      }\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  }, [manifest.configFields, values]);\n\n  // Handle Test Connection\n  const handleTest = useCallback(async () => {\n    const unflattened = unflattenConfig(values);\n    testConnection.mutate({ type: manifest.type, config: unflattened });\n  }, [values, manifest.type, testConnection]);\n\n  // Handle Save\n  const handleSave = useCallback(async () => {\n    const unflattened = unflattenConfig(values);\n    if (isEditMode && existingInstance) {\n      updateConfig.mutate(\n        { id: existingInstance.id, config: unflattened },\n        {\n          onSuccess: () => onOpenChange(false),\n          onError: (err) => {\n            setErrors({ __form: err instanceof Error ? err.message : 'Failed to update' });\n          },\n        },\n      );\n    } else {\n      addAdapter.mutate(\n        { type: manifest.type, id: adapterId, config: unflattened },\n        {\n          onSuccess: () => onOpenChange(false),\n          onError: (err) => {\n            const message = err instanceof Error ? err.message : 'Failed to add';\n            if (message.includes('already exists')) {\n              setErrors({ __id: 'An adapter with this ID already exists' });\n              setStep('configure');\n            } else {\n              setErrors({ __form: message });\n            }\n          },\n        },\n      );\n    }\n  }, [values, adapterId, manifest.type, isEditMode, existingInstance, addAdapter, updateConfig, onOpenChange]);\n\n  // Multi-step fields filtering\n  const currentFields = useMemo(() => {\n    if (!manifest.setupSteps || manifest.setupSteps.length === 0) {\n      return manifest.configFields;\n    }\n    const currentStep = manifest.setupSteps[setupStepIndex];\n    if (!currentStep) return manifest.configFields;\n    return manifest.configFields.filter((f) => currentStep.fields.includes(f.key));\n  }, [manifest, setupStepIndex]);\n\n  const hasMultipleSteps = (manifest.setupSteps?.length ?? 0) > 1;\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-lg\">\n        <DialogHeader>\n          <DialogTitle>\n            {manifest.iconEmoji && `${manifest.iconEmoji} `}\n            {isEditMode ? `Configure ${manifest.displayName}` : `Add ${manifest.displayName}`}\n          </DialogTitle>\n          {manifest.description && (\n            <DialogDescription>{manifest.description}</DialogDescription>\n          )}\n        </DialogHeader>\n\n        {step === 'configure' && (\n          <div className=\"space-y-4\">\n            {manifest.setupInstructions && (\n              <div className=\"rounded-md bg-blue-50 p-3 text-sm text-blue-800 dark:bg-blue-950 dark:text-blue-200\">\n                {manifest.setupInstructions}\n              </div>\n            )}\n\n            {!isEditMode && (\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"adapter-id\">Adapter ID</Label>\n                <Input\n                  id=\"adapter-id\"\n                  value={adapterId}\n                  onChange={(e) => setAdapterId(e.target.value)}\n                  placeholder={manifest.type}\n                />\n                {errors.__id && (\n                  <p className=\"text-xs text-red-500\">{errors.__id}</p>\n                )}\n              </div>\n            )}\n\n            {hasMultipleSteps && manifest.setupSteps && (\n              <div className=\"text-xs text-muted-foreground\">\n                Step {setupStepIndex + 1} of {manifest.setupSteps.length}:\n                {' '}{manifest.setupSteps[setupStepIndex]?.title}\n              </div>\n            )}\n\n            <ConfigFieldGroup\n              fields={currentFields}\n              values={values}\n              onChange={handleFieldChange}\n              errors={errors}\n            />\n          </div>\n        )}\n\n        {step === 'test' && (\n          <div className=\"flex flex-col items-center gap-4 py-6\">\n            {testConnection.isPending && (\n              <>\n                <Loader2 className=\"size-8 animate-spin text-muted-foreground\" />\n                <p className=\"text-sm text-muted-foreground\">Testing connection...</p>\n              </>\n            )}\n            {testConnection.isSuccess && testConnection.data.ok && (\n              <>\n                <CheckCircle2 className=\"size-8 text-green-500\" />\n                <p className=\"text-sm text-green-600\">Connection successful!</p>\n              </>\n            )}\n            {testConnection.isSuccess && !testConnection.data.ok && (\n              <>\n                <XCircle className=\"size-8 text-red-500\" />\n                <p className=\"text-sm text-red-600\">\n                  Connection failed: {testConnection.data.error}\n                </p>\n              </>\n            )}\n            {testConnection.isError && (\n              <>\n                <AlertTriangle className=\"size-8 text-red-500\" />\n                <p className=\"text-sm text-red-600\">\n                  Test error: {testConnection.error instanceof Error ? testConnection.error.message : 'Unknown error'}\n                </p>\n              </>\n            )}\n          </div>\n        )}\n\n        {step === 'confirm' && (\n          <div className=\"space-y-3\">\n            <h4 className=\"text-sm font-medium\">Review Configuration</h4>\n            <div className=\"rounded-md border p-3 text-sm\">\n              <div className=\"space-y-1\">\n                {manifest.configFields.map((field) => {\n                  const val = values[field.key];\n                  if (val === undefined || val === null || val === '') return null;\n                  return (\n                    <div key={field.key} className=\"flex justify-between\">\n                      <span className=\"text-muted-foreground\">{field.label}:</span>\n                      <span className=\"font-mono text-xs\">\n                        {field.type === 'password' ? '***' : String(val)}\n                      </span>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n            {errors.__form && (\n              <p className=\"text-xs text-red-500\">{errors.__form}</p>\n            )}\n          </div>\n        )}\n\n        <DialogFooter className=\"gap-2\">\n          {step === 'configure' && (\n            <>\n              {hasMultipleSteps && setupStepIndex > 0 && (\n                <Button variant=\"outline\" onClick={() => setSetupStepIndex((i) => i - 1)}>Back</Button>\n              )}\n              {hasMultipleSteps && setupStepIndex < (manifest.setupSteps?.length ?? 1) - 1 ? (\n                <Button onClick={() => { if (validate()) setSetupStepIndex((i) => i + 1); }}>Next</Button>\n              ) : (\n                <Button onClick={() => { if (validate()) setStep('test'); }}>Continue</Button>\n              )}\n            </>\n          )}\n          {step === 'test' && (\n            <>\n              {!testConnection.isPending && (\n                <Button variant=\"ghost\" onClick={() => setStep('confirm')}>Skip</Button>\n              )}\n              <Button\n                onClick={handleTest}\n                disabled={testConnection.isPending}\n              >\n                {testConnection.isPending ? 'Testing...' : 'Test Connection'}\n              </Button>\n              {testConnection.isSuccess && (\n                <Button onClick={() => setStep('confirm')}>Continue</Button>\n              )}\n            </>\n          )}\n          {step === 'confirm' && (\n            <>\n              <Button variant=\"outline\" onClick={() => setStep('configure')}>Back</Button>\n              <Button\n                onClick={handleSave}\n                disabled={addAdapter.isPending || updateConfig.isPending}\n              >\n                {(addAdapter.isPending || updateConfig.isPending) ? 'Saving...' : 'Save'}\n              </Button>\n            </>\n          )}\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\n// --- Helpers ---\n\nfunction initializeValues(\n  manifest: AdapterManifest,\n  existingConfig?: Record<string, unknown>,\n): Record<string, unknown> {\n  const values: Record<string, unknown> = {};\n  for (const field of manifest.configFields) {\n    if (existingConfig) {\n      // Edit mode: pre-fill from existing config (except passwords)\n      if (field.type === 'password') {\n        values[field.key] = ''; // Don't pre-fill passwords\n      } else {\n        const parts = field.key.split('.');\n        let val: unknown = existingConfig;\n        for (const part of parts) {\n          if (val && typeof val === 'object') {\n            val = (val as Record<string, unknown>)[part];\n          } else {\n            val = undefined;\n            break;\n          }\n        }\n        values[field.key] = val ?? field.default;\n      }\n    } else {\n      // Add mode: use defaults\n      values[field.key] = field.default;\n    }\n  }\n  return values;\n}\n\nfunction generateDefaultId(manifest: AdapterManifest): string {\n  return manifest.type;\n}\n\nfunction unflattenConfig(flat: Record<string, unknown>): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(flat)) {\n    if (value === undefined) continue;\n    const parts = key.split('.');\n    let current = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      current[parts[i]] ??= {};\n      current = current[parts[i]] as Record<string, unknown>;\n    }\n    current[parts.at(-1)!] = value;\n  }\n  return result;\n}\n```\n\n2. Export from the relay feature barrel:\n```typescript\nexport { AdapterSetupWizard } from './ui/AdapterSetupWizard';\n```\n\n## Tests (`apps/client/src/layers/features/relay/ui/__tests__/AdapterSetupWizard.test.tsx`)\n\nWrap all tests in `TransportProvider` + `QueryClientProvider`.\n\n- Wizard opens in add mode with empty form and default values\n- Wizard opens in edit mode with pre-filled values (passwords empty)\n- Setup instructions display when provided in manifest\n- Adapter ID field shows in add mode but not in edit mode\n- Multi-step navigation shows step indicator and next/back buttons\n- Validate blocks Continue when required fields are empty\n- Test step shows spinner during pending, green check on success, red X on failure\n- Skip link on test step navigates to confirm step\n- Confirm step shows values summary with passwords masked as '***'\n- Save button calls `addAdapter` mutation in add mode\n- Save button calls `updateConfig` mutation in edit mode\n- Duplicate ID error sets error state and returns to configure step\n- `unflattenConfig` converts `{'inbound.subject': 'x'}` to `{inbound: {subject: 'x'}}`\n\n## Acceptance Criteria\n- [ ] Three-step wizard flow works (configure -> test -> confirm)\n- [ ] Dynamic form renders from manifest's configFields\n- [ ] Multi-step setup works when `manifest.setupSteps` is defined\n- [ ] Connection test shows appropriate UI states (pending, success, failure)\n- [ ] Edit mode pre-fills values but not passwords\n- [ ] Save calls correct mutation (add vs update)\n- [ ] Password fields are masked in confirm summary\n- [ ] `unflattenConfig` correctly handles dot-notation keys\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Building AdapterSetupWizard component",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1", "3.2"],
      "parallelWith": []
    },
    {
      "id": "3.5",
      "phase": 3,
      "phaseName": "Client Catalog UI",
      "subject": "[adapter-catalog-management] [P3] Upgrade AdaptersTab and enhance AdapterCard with kebab menu",
      "description": "Upgrade the AdaptersTab in RelayPanel to use the catalog data source with two sections (Configured Adapters + Available Adapters), and enhance AdapterCard with a kebab menu for Configure and Remove actions.\n\n## Implementation Steps\n\n### Enhanced AdapterCard\n\n1. Update `apps/client/src/layers/features/relay/ui/AdapterCard.tsx` to add a kebab menu:\n\n```typescript\nimport { useState } from 'react';\nimport { Badge } from '@/layers/shared/ui/badge';\nimport { Switch } from '@/layers/shared/ui/switch';\nimport { Button } from '@/layers/shared/ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/layers/shared/ui/dropdown-menu';\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/layers/shared/ui/alert-dialog';\nimport { MoreVertical, Settings, Trash2 } from 'lucide-react';\nimport { Tooltip, TooltipContent, TooltipTrigger } from '@/layers/shared/ui/tooltip';\nimport type { CatalogInstance } from '@dorkos/shared/relay-schemas';\nimport type { AdapterManifest } from '@dorkos/shared/relay-schemas';\n\nconst STATUS_COLORS: Record<string, string> = {\n  connected: 'bg-green-500',\n  disconnected: 'bg-gray-400',\n  error: 'bg-red-500',\n  starting: 'bg-yellow-500',\n  stopping: 'bg-yellow-500',\n};\n\ninterface AdapterCardProps {\n  instance: CatalogInstance;\n  manifest: AdapterManifest;\n  onToggle: (enabled: boolean) => void;\n  onConfigure: () => void;\n  onRemove: () => void;\n}\n\nexport function AdapterCard({\n  instance,\n  manifest,\n  onToggle,\n  onConfigure,\n  onRemove,\n}: AdapterCardProps) {\n  const [showRemoveDialog, setShowRemoveDialog] = useState(false);\n  const dotColor = STATUS_COLORS[instance.status.state] ?? 'bg-gray-400';\n  const isBuiltinClaudeCode = manifest.type === 'claude-code' && manifest.builtin;\n\n  return (\n    <>\n      <div className=\"flex items-center justify-between rounded-lg border p-3\">\n        <div className=\"flex items-center gap-3\">\n          <span className={`h-2 w-2 rounded-full ${dotColor}`} />\n          <div>\n            <div className=\"flex items-center gap-2\">\n              {manifest.iconEmoji && (\n                <span className=\"text-sm\" role=\"img\" aria-hidden>{manifest.iconEmoji}</span>\n              )}\n              <span className=\"text-sm font-medium\">{manifest.displayName}</span>\n              <Badge variant=\"outline\" className=\"text-xs\">\n                {manifest.category}\n              </Badge>\n            </div>\n            <div className=\"text-xs text-muted-foreground\">\n              In: {instance.status.messageCount.inbound} | Out: {instance.status.messageCount.outbound}\n              {instance.status.errorCount > 0 && ` | Errors: ${instance.status.errorCount}`}\n            </div>\n            {instance.status.lastError && (\n              <div className=\"mt-1 max-w-[200px] truncate text-xs text-red-500\">\n                {instance.status.lastError}\n              </div>\n            )}\n          </div>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Switch checked={instance.enabled} onCheckedChange={onToggle} />\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant=\"ghost\" size=\"sm\" className=\"size-8 p-0\">\n                <MoreVertical className=\"size-4\" />\n                <span className=\"sr-only\">Adapter options</span>\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\">\n              <DropdownMenuItem onClick={onConfigure}>\n                <Settings className=\"mr-2 size-4\" />\n                Configure\n              </DropdownMenuItem>\n              {isBuiltinClaudeCode ? (\n                <Tooltip>\n                  <TooltipTrigger asChild>\n                    <DropdownMenuItem disabled>\n                      <Trash2 className=\"mr-2 size-4\" />\n                      Remove\n                    </DropdownMenuItem>\n                  </TooltipTrigger>\n                  <TooltipContent>Built-in adapter cannot be removed.</TooltipContent>\n                </Tooltip>\n              ) : (\n                <DropdownMenuItem\n                  className=\"text-red-600\"\n                  onClick={() => setShowRemoveDialog(true)}\n                >\n                  <Trash2 className=\"mr-2 size-4\" />\n                  Remove\n                </DropdownMenuItem>\n              )}\n            </DropdownMenuContent>\n          </DropdownMenu>\n        </div>\n      </div>\n\n      <AlertDialog open={showRemoveDialog} onOpenChange={setShowRemoveDialog}>\n        <AlertDialogContent>\n          <AlertDialogHeader>\n            <AlertDialogTitle>Remove {manifest.displayName} adapter?</AlertDialogTitle>\n            <AlertDialogDescription>\n              This will stop the adapter and delete its configuration. This action cannot be undone.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel>Cancel</AlertDialogCancel>\n            <AlertDialogAction\n              className=\"bg-red-600 hover:bg-red-700\"\n              onClick={() => {\n                onRemove();\n                setShowRemoveDialog(false);\n              }}\n            >\n              Remove\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n    </>\n  );\n}\n```\n\n### Upgraded AdaptersTab\n\n2. Update the adapters tab section in `apps/client/src/layers/features/relay/ui/RelayPanel.tsx` (or wherever the adapters tab content lives) to use catalog data:\n\n```typescript\nimport { useState } from 'react';\nimport { useAdapterCatalog, useRemoveAdapter } from '@/layers/entities/relay';\nimport { AdapterCard } from './AdapterCard';\nimport { CatalogCard } from './CatalogCard';\nimport { AdapterSetupWizard } from './AdapterSetupWizard';\nimport type { AdapterManifest, CatalogEntry } from '@dorkos/shared/relay-schemas';\n\nfunction AdaptersTabContent() {\n  const { data: catalog = [] } = useAdapterCatalog();\n  const removeAdapter = useRemoveAdapter();\n  const [wizardState, setWizardState] = useState<{\n    open: boolean;\n    manifest?: AdapterManifest;\n    instanceId?: string;\n  }>({ open: false });\n\n  // Split catalog into configured (has instances) and available (no instances)\n  const configured = catalog.filter((entry) => entry.instances.length > 0);\n  const available = catalog.filter(\n    (entry) => entry.instances.length === 0 || entry.manifest.multiInstance,\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Configured Adapters */}\n      <div className=\"space-y-3\">\n        <h3 className=\"text-sm font-medium\">Configured Adapters</h3>\n        {configured.length === 0 ? (\n          <p className=\"text-sm text-muted-foreground\">No adapters configured.</p>\n        ) : (\n          <div className=\"space-y-2\">\n            {configured.flatMap((entry) =>\n              entry.instances.map((instance) => (\n                <AdapterCard\n                  key={instance.id}\n                  instance={instance}\n                  manifest={entry.manifest}\n                  onToggle={() => { /* enable/disable via existing hook */ }}\n                  onConfigure={() =>\n                    setWizardState({\n                      open: true,\n                      manifest: entry.manifest,\n                      instanceId: instance.id,\n                    })\n                  }\n                  onRemove={() => removeAdapter.mutate(instance.id)}\n                />\n              )),\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Available Adapters */}\n      {available.length > 0 && (\n        <div className=\"space-y-3\">\n          <h3 className=\"text-sm font-medium\">Available Adapters</h3>\n          <div className=\"grid grid-cols-2 gap-3\">\n            {available.map((entry) => (\n              <CatalogCard\n                key={entry.manifest.type}\n                manifest={entry.manifest}\n                onAdd={() =>\n                  setWizardState({\n                    open: true,\n                    manifest: entry.manifest,\n                  })\n                }\n              />\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Setup Wizard */}\n      {wizardState.manifest && (\n        <AdapterSetupWizard\n          open={wizardState.open}\n          onOpenChange={(open) => setWizardState((prev) => ({ ...prev, open }))}\n          manifest={wizardState.manifest}\n          existingInstance={\n            wizardState.instanceId\n              ? catalog\n                  .flatMap((e) => e.instances.map((i) => ({ ...i, manifest: e.manifest })))\n                  .find((i) => i.id === wizardState.instanceId)\n              : undefined\n          }\n        />\n      )}\n    </div>\n  );\n}\n```\n\n3. Export updated components from the relay feature barrel.\n\n## Tests\n\nUpdate `apps/client/src/layers/features/relay/__tests__/AdapterCard.test.tsx`:\n\n- Kebab menu opens when clicking the `...` button\n- \"Configure\" menu item calls `onConfigure` callback\n- \"Remove\" menu item opens confirmation AlertDialog\n- Confirmation dialog calls `onRemove` when confirmed\n- Remove is disabled for built-in claude-code adapter with tooltip text\n- Status dot reflects the adapter's state color\n\nAdd `apps/client/src/layers/features/relay/ui/__tests__/AdaptersTab.test.tsx`:\n\n- Renders \"Configured Adapters\" section with existing instances\n- Renders \"Available Adapters\" section with unconfigured types\n- Available section includes multiInstance types even when they have instances\n- Clicking \"Add\" on CatalogCard opens the wizard with correct manifest\n- Clicking \"Configure\" on AdapterCard opens wizard in edit mode\n\n## Acceptance Criteria\n- [ ] AdaptersTab shows two sections: Configured Adapters and Available Adapters\n- [ ] Data source is `useAdapterCatalog()` instead of `useRelayAdapters()`\n- [ ] AdapterCard has kebab menu with Configure and Remove options\n- [ ] Remove shows AlertDialog confirmation\n- [ ] Built-in claude-code adapter's Remove is disabled with tooltip\n- [ ] CatalogCard's Add button opens AdapterSetupWizard\n- [ ] AdapterCard's Configure opens wizard in edit mode\n- [ ] All tests pass\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Upgrading AdaptersTab and enhancing AdapterCard with kebab menu",
      "size": "large",
      "priority": "high",
      "dependencies": ["3.1", "3.3", "3.4"],
      "parallelWith": []
    },
    {
      "id": "4.1",
      "phase": 4,
      "phaseName": "Polish & Documentation",
      "subject": "[adapter-catalog-management] [P4] Handle edge cases and improve error UX",
      "description": "Add edge case handling for network errors, concurrent edits, and improved error feedback throughout the adapter catalog UI.\n\n## Implementation Steps\n\n1. **Network error handling in wizard** ‚Äî Wrap mutation calls in the wizard with toast notifications for unexpected errors. Use the existing toast system from the shared layer.\n\n2. **Optimistic UI for adapter toggle** ‚Äî When toggling enable/disable on an AdapterCard, optimistically update the local catalog cache so the switch responds immediately, then revert on error.\n\n3. **Loading states** ‚Äî Show skeleton cards in the \"Available Adapters\" section while catalog data is loading. Use the existing Skeleton component from shadcn/ui:\n```typescript\nif (isLoading) {\n  return (\n    <div className=\"grid grid-cols-2 gap-3\">\n      {[1, 2].map((i) => (\n        <div key={i} className=\"rounded-lg border p-4\">\n          <Skeleton className=\"mb-2 h-5 w-24\" />\n          <Skeleton className=\"h-4 w-full\" />\n          <Skeleton className=\"mt-3 h-8 w-full\" />\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n4. **Empty state** ‚Äî When catalog has no available adapters (all types are configured and none are multiInstance), show an informative empty state message.\n\n5. **Hot-reload safety** ‚Äî The AdapterManager already watches the config file for changes. When a wizard save triggers a config write, the hot-reload watcher will fire. The existing `reload()` method uses chokidar's `awaitWriteFinish` to debounce. No additional work is needed, but verify via manual testing that saving from the wizard does not cause duplicate adapter starts.\n\n6. **Stale data after external edit** ‚Äî Since the catalog polls every 30 seconds, external edits to `adapters.json` will be reflected within 30 seconds. No immediate action needed, but add a manual \"Refresh\" button to the AdaptersTab header:\n```typescript\n<Button variant=\"ghost\" size=\"sm\" onClick={() => queryClient.invalidateQueries({ queryKey: ['relay', 'adapters', 'catalog'] })}>\n  <RefreshCw className=\"size-4\" />\n</Button>\n```\n\n## Acceptance Criteria\n- [ ] Network errors during CRUD operations show user-friendly error messages\n- [ ] Enable/disable toggle responds immediately with optimistic update\n- [ ] Loading skeleton shows while catalog is fetching\n- [ ] Empty state message when no adapters are available to add\n- [ ] Manual refresh button triggers immediate catalog re-fetch\n- [ ] No duplicate adapter starts during config file hot-reload\n- [ ] `pnpm typecheck` passes",
      "activeForm": "Handling edge cases and improving error UX",
      "size": "medium",
      "priority": "medium",
      "dependencies": ["3.5"],
      "parallelWith": ["4.2"]
    },
    {
      "id": "4.2",
      "phase": 4,
      "phaseName": "Polish & Documentation",
      "subject": "[adapter-catalog-management] [P4] Update contributing docs with adapter manifest documentation",
      "description": "Update the internal developer documentation to cover the new AdapterManifest system, ConfigField descriptors, and how to create adapter plugins with manifests.\n\n## Implementation Steps\n\n1. **Update `contributing/relay-adapters.md`** (or create if it does not exist) with a new section \"Adapter Manifest\":\n\n  - Explain the `AdapterManifest` type and its purpose (automatic setup wizard generation)\n  - Document each field in the manifest schema with descriptions\n  - Document the `ConfigField` type with all seven field types and their UI rendering\n  - Explain `showWhen` conditional visibility with an example\n  - Explain `setupSteps` for multi-step wizards with an example\n  - Explain `section` grouping for organizing related fields\n  - Show the complete Telegram manifest as a reference example\n  - Show how to export a manifest from a plugin module via `getManifest()`\n\n2. **Update the \"Creating a Custom Adapter\" section** in the same file to include manifest declaration as part of the adapter creation workflow:\n  - Add a step: \"Export a manifest alongside your adapter factory\"\n  - Show the `AdapterPluginModule` interface with `getManifest()` optional method\n  - Explain that plugins without manifests get a minimal fallback manifest\n\n3. **Update `contributing/api-reference.md`** to document the new endpoints:\n  - `GET /api/relay/adapters/catalog` ‚Äî returns `CatalogEntry[]`\n  - `POST /api/relay/adapters` ‚Äî create adapter (body: `{ type, id, config, enabled? }`)\n  - `DELETE /api/relay/adapters/:id` ‚Äî remove adapter\n  - `PATCH /api/relay/adapters/:id/config` ‚Äî update config (body: `{ config }`)\n  - `POST /api/relay/adapters/test` ‚Äî test connection (body: `{ type, config }`)\n  - Include example request/response for each endpoint\n  - Document error codes and status codes\n\n## Acceptance Criteria\n- [ ] `contributing/relay-adapters.md` has an \"Adapter Manifest\" section with full documentation\n- [ ] The \"Creating a Custom Adapter\" section includes manifest export instructions\n- [ ] `contributing/api-reference.md` documents all five new endpoints\n- [ ] Documentation includes runnable examples (manifest declarations, API calls)\n- [ ] No broken internal links in documentation files",
      "activeForm": "Updating contributing docs with adapter manifest documentation",
      "size": "medium",
      "priority": "low",
      "dependencies": ["2.3"],
      "parallelWith": ["4.1"]
    }
  ]
}
